<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>项目总结 | IZDLOYL's Blog</title><meta name="author" content="IZDLOYL"><meta name="copyright" content="IZDLOYL"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="123456789（面试官您好）我叫朱晓霞，目前是杭州电子科技大学通信工程专业研三的学生，在校期间，我系统学习了前端开发的相关知识，比较熟悉JS，且在Vue开发方面也积累了一定的实践经验。目前，主要参与过两个前端项目的开发。一个是人力资源后台管理系统，另一个是一个响应式设计的图片分享平台，通过这些项目实践，我掌握了组件化开发、状态管理以及前后端接口联调等核心技能。同时呢，为了整理和分享自己的所学">
<meta property="og:type" content="article">
<meta property="og:title" content="项目总结">
<meta property="og:url" content="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="IZDLOYL&#39;s Blog">
<meta property="og:description" content="123456789（面试官您好）我叫朱晓霞，目前是杭州电子科技大学通信工程专业研三的学生，在校期间，我系统学习了前端开发的相关知识，比较熟悉JS，且在Vue开发方面也积累了一定的实践经验。目前，主要参与过两个前端项目的开发。一个是人力资源后台管理系统，另一个是一个响应式设计的图片分享平台，通过这些项目实践，我掌握了组件化开发、状态管理以及前后端接口联调等核心技能。同时呢，为了整理和分享自己的所学">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.izdloyl.cn/gallery/wallpaper7.jpg">
<meta property="article:published_time" content="2024-08-27T12:58:34.417Z">
<meta property="article:modified_time" content="2024-09-16T11:52:37.380Z">
<meta property="article:author" content="IZDLOYL">
<meta property="article:tag" content="秋招">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.izdloyl.cn/gallery/wallpaper7.jpg"><link rel="shortcut icon" href="/gallery/favicon.jpg"><link rel="canonical" href="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '项目总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-16 19:52:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/gallery/wallpaper7.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="IZDLOYL's Blog"><span class="site-name">IZDLOYL's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">项目总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-27T12:58:34.417Z" title="发表于 2024-08-27 20:58:34">2024-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-16T11:52:37.380Z" title="更新于 2024-09-16 19:52:37">2024-09-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="项目总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（面试官您好）我叫朱晓霞，目前是杭州电子科技大学通信工程专业研三的学生，</span><br><span class="line">在校期间，我系统学习了前端开发的相关知识，</span><br><span class="line">比较熟悉JS，且在Vue开发方面也积累了一定的实践经验。</span><br><span class="line">目前，主要参与过两个前端项目的开发。</span><br><span class="line">一个是人力资源后台管理系统，另一个是一个响应式设计的图片分享平台，</span><br><span class="line">通过这些项目实践，我掌握了组件化开发、状态管理以及前后端接口联调等核心技能。</span><br><span class="line">同时呢，为了整理和分享自己的所学知识，我基于hexo 搭建了自己的个人博客网站，</span><br><span class="line">主要记录自己学习前端的心得体会和开发中的一些日常积累。</span><br><span class="line">以上是我的一些基本情况。</span><br></pre></td></tr></table></figure>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="图享汇"><a href="#图享汇" class="headerlink" title="图享汇"></a>图享汇</h3><h4 id="1、登录注册"><a href="#1、登录注册" class="headerlink" title="1、登录注册"></a>1、登录注册</h4><h5 id="使用slideCaptcha完成滑动验证"><a href="#使用slideCaptcha完成滑动验证" class="headerlink" title="使用slideCaptcha完成滑动验证"></a>使用<code>slideCaptcha</code>完成滑动验证</h5><p>原理：将用户拖动行为的时间、精度，滑动轨迹等信息到服务器，然后进行后台算法验证。</p>
<p>过程：首先在人类行为验证组件完成对应<code>UI</code>样式，在组件挂载（<code>onMounted</code>）时初始化并配置一个滑动验证码（<code>sliderCaptcha</code>），并指定处理成功、失败的回调函数，在用户拼图成功这个回调中，通过调用 <code>getCaptcha</code> 方法发送行为数据给后端进行进一步的验证</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCaptcha &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/sys&#x27;</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  captcha = <span class="title function_">sliderCaptcha</span>(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;captcha&#x27;</span>, <span class="comment">// 渲染位置</span></span><br><span class="line">    <span class="comment">// 用户拼图成功之后的回调</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">onSuccess</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getCaptcha</span>(&#123;</span><br><span class="line">        <span class="attr">behavior</span>: arr</span><br><span class="line">        <span class="keyword">if</span> (res) &#123; <span class="comment">// 人类行为验证通过</span></span><br><span class="line">          <span class="title function_">emits</span>(<span class="variable constant_">EMITS_SUCCESS</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 用户拼图失败之后的回调</span></span><br><span class="line">    <span class="title function_">onFail</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onFail&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 默认的验证方法，咱们不在此处进行验证，而是选择在用户拼图成功之后进行验证，所以此处永远返回为 true</span></span><br><span class="line">    <span class="title function_">verify</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="实现第三方QQ、微信扫码登录。"><a href="#实现第三方QQ、微信扫码登录。" class="headerlink" title="实现第三方QQ、微信扫码登录。"></a>实现第三方<code>QQ</code>、微信扫码登录。</h5><p><code>OAuth</code> 的思路：<code>OAuth</code>是一个关于授权（<code>authorization</code>）的开放网络标准。<span style="color: #165689"><strong>应用通过引导用户在第三方平台的授权层进行登录授权，获得一个限制权限和有效时间的令牌（token），在令牌有效期内即可从第三方平台换取用户授权使用的信息</strong></span>。</p>
<p>客户端授权模式：授权码模式、简化模式、密码模式、客户端模式。</p>
<p><strong><em>授权码模式</em></strong> 是功能最完整、流程最严密的授权模式。基于授权码模式的第三方登录流程如下：</p>
<ol>
<li>用户访问应用，点击登录按钮，跳转至第三方平台的登录授权页。</li>
<li>用户授权成功后会跳转至应用在第三方平台设置的回调地址，并携带授权码（<code>code</code>）。</li>
<li>应用服务器处理从第三方平台的登录授权页跳转至回调地址产生的<code>get</code>请求并从<code>query</code>中获得授权码，使用授权码和其他信息（比如应用在第三方平台注册的<code>appId</code>和<code>appKey</code>，设置的回调地址等）向第三方平台请求访问令牌（<code>access token</code>）。</li>
<li>在访问令牌的有效期内，应用服务器请求第三方平台接口获取用户的身份标识（<code>openid</code>、<code>unionid</code>等）和用户授权使用的信息（比如用户昵称和头像等开放信息）。</li>
<li>应用服务器根据获取的用户信息，完成注册登录的逻辑并跳转至应用首页。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408272059929.jpg" alt=""></p>
<p><strong>QQ登录流程</strong>：【扫码登录之后，进入的地址为<strong>线上的回调地址</strong>，调试必须在线上进行】</p>
<ol>
<li><p>点击<code>QQ</code>登录按钮触发事件，进入第三方登录页（<code>window.open</code>）展示 <code>QQ</code> 登录二维码</p>
</li>
<li><p>获取用户信息：在执行<code>QQ</code>挂起登录时，由于<code>QQ</code>登录存在缓存，为防止下次进入时自动重新登录，在离开登录页面时，注销登录；获取当前用户唯一标识，作为判断用户是否已注册的依据，将获得的用户信息进行跨页面传输。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QQ 登录挂起</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable constant_">QC</span>.<span class="title class_">Login</span>(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">btnId</span>: <span class="string">&#x27;qqLoginBtn&#x27;</span> <span class="comment">//插入按钮的节点id</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 登录成功之后的回调，但是需要注意，这个回调只会在《登录回调页面中被执行》</span></span><br><span class="line">    <span class="comment">// 登录存在缓存，登录成功一次之后，下次进入会自动重新登录（即：触发该方法，所以我们应该在离开登录页面时，注销登录）</span></span><br><span class="line">    <span class="function">(<span class="params">data, opts</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable constant_">QC</span>.<span class="property">Login</span>.<span class="title function_">signOut</span>() <span class="comment">// 1. 注销登录，否则在后续登录中会直接触发该回调</span></span><br><span class="line">      <span class="comment">// 2. 获取当前用户唯一标识，作为判断用户是否已注册的依据</span></span><br><span class="line">      <span class="keyword">const</span> accessToken = <span class="regexp">/access_token=((.*))&amp;expires_in/</span>.<span class="title function_">exec</span>(</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span></span><br><span class="line">      )[<span class="number">1</span>]</span><br><span class="line">      <span class="comment">// 3. 拼接请求对象</span></span><br><span class="line">      <span class="keyword">const</span> oauthObj = &#123;</span><br><span class="line">        <span class="attr">nickname</span>: data.<span class="property">nickname</span>,</span><br><span class="line">        <span class="attr">figureurl_qq_2</span>: data.<span class="property">figureurl_qq_2</span>,</span><br><span class="line">        accessToken</span><br><span class="line">      &#125;</span><br><span class="line">      broadcast.<span class="title function_">send</span>(oauthObj)<span class="comment">// 4. 完成跨页面传输</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 针对于 移动端而言：通过移动端触发 QQ 登录会展示三个页面，原页面、QQ 吊起页面、回调页面。并且移动端一个页面展示整屏内容，且无法直接通过 window.close() 关闭，所以在移动端中，我们需要在当前页面继续进行后续操作。</span></span><br><span class="line">      <span class="title function_">oauthLogin</span>(<span class="variable constant_">LOGIN_TYPE_QQ</span>, oauthObj)</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">close</span>() <span class="comment">// 5. 在 PC 端下，关闭第三方窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成跨页面数据传输：</p>
</li>
<li><p>认证是否已注册</p>
</li>
<li><p>完成 <code>QQ</code> 对接</p>
</li>
</ol>
<p><strong>微信登录流程</strong>：</p>
<ol>
<li><p>通过 <strong>微信登录前置数据获取</strong> 接口，获取登录数据（比如 <code>APP ID</code>）</p>
</li>
<li><p>根据获取到的数据，拼接得到 <code>open url</code> 地址</p>
</li>
<li><p>打开该地址，展示微信登录二维码</p>
</li>
<li><p>移动端微信扫码确定登录</p>
</li>
<li><p>从当前窗口中解析 <code>window.location.search</code> 得到用户的 <code>code</code> 数据</p>
</li>
<li><p>根据 <code>appId、appSecret、code</code> 通过接口获取用户的 <code>access_token</code></p>
</li>
<li><p>根据 <code>access_token</code> 获取用户信息</p>
</li>
<li><p>通过用户信息触发 <code>oauthLogin</code> 方法</p>
</li>
</ol>
<h4 id="2、axios二次封装"><a href="#2、axios二次封装" class="headerlink" title="2、axios二次封装"></a>2、<code>axios</code>二次封装</h4><blockquote>
<p>在请求拦截器中设置接口基础地址、超时时间、登录成功后请求头携带<code>token</code>，响应拦截器做异常处理。</p>
</blockquote>
<p><strong><em>axios的使用</em></strong> ：请求方式：<code>axios.get()</code>、<code>axios.post()</code>、<code>axios(&#123;&#125;)</code></p>
<ul>
<li>get请求</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给后端传递的参数 ==&gt; 参数1=值&amp;参数2=值</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;url?参数1=值&amp;参数2=值&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>post请求</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;url&#x27;</span>,&#123;</span><br><span class="line">  参数<span class="number">1</span>: 值,</span><br><span class="line">  参数<span class="number">2</span>: 值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>axios(&#123;&#125;)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;xxxX&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post或get&#x27;</span></span><br><span class="line">  <span class="attr">params</span>:&#123;&#125;, <span class="comment">// get请求方式给后端传递的参数</span></span><br><span class="line">  <span class="attr">data</span>:&#123;&#125;, <span class="comment">// post请求方式给后端传递的参数</span></span><br><span class="line">  <span class="attr">header</span>:&#123;&#125;, <span class="comment">// 自定义请求头</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>, <span class="comment">// 请求时间超过timeout,则请求会被中断</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;默认为json格式数据&#x27;</span> <span class="comment">// 相应的数据类型</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong><em>axios二次封装</em></strong> ：</p>
<blockquote>
<ol>
<li>提高代码复用性，减少代码量，减低维护难度。</li>
<li>统一处理一些常规的问题一劳永逸，如http错误。</li>
<li>拦截请求和响应，提前对数据进行处理，如获取token，修改配置项。</li>
</ol>
</blockquote>
<p>步骤：</p>
<ol>
<li>在src目录下创建<code>request.js</code>对axios进行二次封装，并导入axios</li>
<li>配置全局的一些基础配置：baseURL、timeout、header、responseType、withCredentials</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 利用axios对象的方法create,去创建一个axios实例</span></span><br><span class="line"><span class="keyword">const</span> requests = axios.<span class="title function_">create</span>(&#123; <span class="comment">// requests就是axios,只不过稍微配置一下</span></span><br><span class="line">  <span class="attr">baseURL</span>: process.<span class="property">env</span>.<span class="property">VUE_APP_BASE_API</span>, <span class="comment">// 基础地址⭐</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>, <span class="comment">// 超出时间⭐</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span> <span class="comment">// 相应的数据类型</span></span><br><span class="line">  <span class="attr">header</span>:&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;123&quot;</span>&#125;, <span class="comment">// 自定义请求头</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>根据node环境变量区分开发、生产环境：文件<code>.env.production</code>和<code>.env.development</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .env.production文件：</span></span><br><span class="line"><span class="variable constant_">ENV</span> = <span class="string">&#x27;production&#x27;</span> # just a flag</span><br><span class="line"><span class="variable constant_">VUE_APP_BASE_API</span> = <span class="string">&#x27;/prod-api&#x27;</span> # 基地址</span><br><span class="line"></span><br><span class="line"><span class="comment">// .env.development文件：</span></span><br><span class="line"><span class="variable constant_">ENV</span> = <span class="string">&#x27;development&#x27;</span> # just a flag</span><br><span class="line"><span class="variable constant_">VUE_APP_BASE_API</span> = <span class="string">&#x27;/api&#x27;</span> # 基地址</span><br><span class="line"></span><br><span class="line">接着在package.<span class="property">json</span>文件中修改命令配置：</span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve --mode serveDwp&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;vue-cli-service serve --mode devDwp&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build --mode production&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;vue-cli-service build --mode test&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<ol>
<li>配置请求拦截器：token、密钥的设置</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器：在发请求之前，请求拦截器可以检测到,可以在请求发出去之前做一些事情</span></span><br><span class="line">requests.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 每次发送请求之前判断是否存在token</span></span><br><span class="line">  <span class="comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span></span><br><span class="line">  <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">token</span>) &#123;</span><br><span class="line">    config.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="string">`Bearer <span class="subst">$&#123;store.getters.token&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error) <span class="comment">// 失败执行promise</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>配置响应拦截器：响应的统一处理</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应拦截器：包含两个函数（一个是成功返回的函数，一个是失败的返回的函数）</span></span><br><span class="line">requests.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// axios默认包裹了data</span></span><br><span class="line">  <span class="comment">// 判断是不是Blob</span></span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">data</span> <span class="keyword">instanceof</span> <span class="title class_">Blob</span>) <span class="keyword">return</span> response.<span class="property">data</span> <span class="comment">// 返回了Blob对象</span></span><br><span class="line">  <span class="keyword">const</span> &#123; data, message, success &#125; = response.<span class="property">data</span> <span class="comment">// 默认json格式</span></span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title class_">Message</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>, message &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(message))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="title function_">async</span>(error) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">    <span class="title class_">Message</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span>, <span class="attr">message</span>: <span class="string">&#x27;token超时了&#x27;</span> &#125;)</span><br><span class="line">    <span class="comment">// 说明token超时了，主动跳到登录页</span></span><br><span class="line">    <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/logout&#x27;</span>) <span class="comment">// 调用action 退出登录</span></span><br><span class="line">    router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>) <span class="comment">// 跳转到登录页</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// error.message</span></span><br><span class="line">  <span class="title class_">Message</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>, <span class="attr">message</span>: error.<span class="property">message</span> &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="3、组件封装"><a href="#3、组件封装" class="headerlink" title="3、组件封装"></a>3、组件封装</h4><blockquote>
<p>封装了包括瀑布流、上拉加载等通用组件，用于改善用户界面的流畅性和响应速度，提升了整体用户体验。</p>
<p>小红书首页布局：<strong>瀑布流和虚拟列表的结合</strong></p>
</blockquote>
<h5 id="瀑布流组件："><a href="#瀑布流组件：" class="headerlink" title="瀑布流组件："></a><strong><em>瀑布流组件：</em></strong></h5><ol>
<li><p>瀑布流的核心就是：通过<code>relative</code> 和<code>absolute</code>定位的方式，来控制每个 <code>item</code> 的位置</p>
</li>
<li><p>影响瀑布流高度的主要元素，通常都是<code>img</code>标签</p>
</li>
<li><p>有些服务端会返回<strong>关键<code>img</code>的高度</strong>，有些不会，所以需要分别处理：</p>
<ul>
<li>当服务端<strong>不返回</strong>高度时：需要等待 <code>img</code> 加载完成之后(预加载)，再来计算高度，然后通过得到的高度计算定位。否则则会出现高度计算不准确导致定位计算不准确的问题。</li>
</ul>
</li>
</ol>
<ul>
<li>当服务端<strong>返回</strong>高度时：开发者则必须利用此高度为 <code>item</code> 进行高度设定。一旦 <code>item</code>具备指定高度，那么就不需要等待 <code>img</code>加载的过程，这样效率更高，并且可以业务的逻辑会变得更加简单。</li>
</ul>
<ol>
<li><p>当进行响应式切换时，同样需要区分对应场景：</p>
<ul>
<li><p>当服务端<strong>不返回</strong>高度时：需要<strong>重新执行整个渲染流程</strong>，虽然会耗费一些性能，但可以最大可能的避免出现逻辑错误。让组件拥有更强的普适性。</p>
</li>
<li><p>当服务端<strong>返回</strong>高度时：同样需要重新计算<strong>列宽</strong>和<strong>定位</strong>，但因为 <code>item</code>具备明确的高度，所以可以直接拿到具体的高度，而无需重复整个渲染流程，从而可以实现更多的交互逻辑。比如：位移动画、将来的图片懒加载占位…</p>
</li>
</ul>
</li>
</ol>
<p>瀑布流布局的核心实现思想：</p>
<ol>
<li><strong>控制容器内每一列卡片的宽度相同</strong>（不同图片尺寸等比例缩放）</li>
<li>第一行卡片紧挨着排列，<strong>第二行开始采取贪心思想，每张卡片摆放到当前所有列中高度最小的一列下面</strong></li>
</ol>
<p>每个卡片<code>item</code>必须使用<code>absolute</code>绝对布局，并通过<code>top</code>和<code>left</code>来手动控制位置</p>
<p>通过<code>props</code>传递关键数据：数据源、唯一标识<code>key</code>、列数、列间距、行间距、是否需要预加载</p>
<p>计算容器宽度【<code>offsetWidth -</code>左右边距】和列宽【（容器的宽度 - 所有的列间距宽度）/ 列数】</p>
<p>想要计算每列的<code>left</code>、<code>top</code>，必须要拿到每个<code>item</code>的高度，才可以判断下一列的第一个<code>item</code>的位置。根据<code>pitturePreReading</code>可以分为两种情况：①需要图片预加载时：图片高度未知  ②不需要图片预加载时：图片高度已知</p>
<p>计算下一个<code>item</code>位置：<code>left =</code>最小高度所在的列 * (列宽 + 间距) <code>top =</code>最小高度所在列高+列间距</p>
<p>适配移动端：自定义列数变化<code>:column = &quot;isMobileTerminal ? 2 : 5&quot;</code>，在<strong>列宽发生变化</strong>时，重新执行计算列宽</p>
<p>难点：当设置<code>:picturePreReading=&quot;false&quot;</code>，不进行图片预加载时，在切换PC端和移动端时会出现图片重叠现象（图片高度计算出现错误）。出现原因：不进行图片预加载时，会直接获取当前<code>item</code>的高度，因为没有等待图片加载完成，此时的高度是不包含图片的高度，从而使整个<code>item</code>高度计算错误。</p>
<p>根据服务端返回的图片接口数据使用作用域插槽返回图片宽度，进而计算等比例缩放后的图片高度【计算后的图片高度 = （计算得到宽度/图片真实宽度）* 图片真实高度】。重新监听列数变换，增加图片不进行预加载的情况</p>
<h5 id="上拉加载："><a href="#上拉加载：" class="headerlink" title="上拉加载："></a><strong><em>上拉加载：</em></strong></h5><p>当滚动到列表底部时，加载数据</p>
<p>构建<code>props</code>传递<code>是否处于加载状态</code>和<code>是否全部加载完成</code>配置，加载下一页数据的触发事件，处理双向数据绑定逻辑，利用<code>vueuse</code>提供的 <a target="_blank" rel="noopener" href="https://vueuse.org/core/useIntersectionObserver/">useIntersectionObserver</a> 方法，监听元素可见行为，用于判断列表滚动到底部</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> laodingTarget = <span class="title function_">ref</span>(<span class="literal">null</span>) <span class="comment">// 滚动的元素</span></span><br><span class="line"><span class="title function_">useIntersectionObserver</span>(laodingTarget, <span class="function">(<span class="params">[&#123; isIntersecting &#125;]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当加载更多的视图可见时，同时 loading 为 false，同时 数据尚未全部加载完</span></span><br><span class="line">    <span class="comment">// 处理加载更多的逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(isIntersecting &amp;&amp; !loading.<span class="property">value</span> &amp;&amp; !props.<span class="property">isFinished</span>)&#123;</span><br><span class="line">        loading.<span class="property">value</span> = <span class="literal">true</span> <span class="comment">// 修改加载数据标记</span></span><br><span class="line">        <span class="title function_">emits</span>(<span class="string">&#x27;onLoad&#x27;</span>) <span class="comment">// 触发加载更多行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="4、懒加裁"><a href="#4、懒加裁" class="headerlink" title="4、懒加裁"></a>4、懒加裁</h4><blockquote>
<p>使用<code>uselntersectionObserver</code>和<code>AsyncComponent</code>分别实现图片和组件的懒加裁，确保首屏加载速度。</p>
</blockquote>
<h5 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h5><p>当图片不可见时，不加载图片。当图片可见时，才去加载图片。</p>
<p><strong>可以监听所有图片是否被可见，如果图片处于不可见状态，那么就不加载图片，如果图片处于可见状态，那么开始加载图片。</strong>而这个功能的实现关键就是 <strong><code>IntersectionObserver</code></strong>。</p>
<p><code>vueuse</code>包提供的<code>useIntersectionObserver</code>方法：<code>const &#123;stop&#125; = useIntersectionObserver(target, fn, options)</code></p>
<ol>
<li><code>target</code>表示被监听的<code>DOM</code>元素</li>
<li>参数2是回调函数，用于通知监听的动作（回调函数的第一个形参<code>isIntersecting</code>表示被监听的元素已经进入了可视区）</li>
<li>参数3 表示配置选项</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useIntersectionObserver <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span><br><span class="line"><span class="comment">// 处理图片懒加载</span></span><br><span class="line"><span class="comment">// 1、在元素挂载到页面中的钩子函数中、保存img的src</span></span><br><span class="line"><span class="comment">// 2、将img的src属性置为 空 或者置位默认图片</span></span><br><span class="line"><span class="comment">// 3、监听图片是否在可视范围内？ 在可视范围内将img保存在src重新复制到img上 并 取消监听</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> imgSrc = el.<span class="property">src</span> <span class="comment">// 1、拿到当前 img 标签的 src</span></span><br><span class="line">    el.<span class="property">src</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 2、将img的src属性置为 空 或者置位默认图片</span></span><br><span class="line">    <span class="comment">//  3、监听图片是否在可视范围内</span></span><br><span class="line">    <span class="keyword">const</span> &#123; stop &#125; = <span class="title function_">useIntersectionObserver</span>(el, <span class="function">(<span class="params">&#123; isIntersecting &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isIntersecting) &#123;</span><br><span class="line">        el.<span class="property">src</span> = imgSrc <span class="comment">// 3. 当图片可见时,加载图片</span></span><br><span class="line">        <span class="title function_">stop</span>() <span class="comment">// 4. 停止监听</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h5><p><code>defineAsyncComponent</code> 方法接收一个返回<code>Promise</code>的加载函数。这个<code>Promise</code>的 <code>resolve</code> 回调方法应该在从服务器获得组件定义时调用。也可以调用 <code>reject(reason)</code> 表明加载失败。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动化注册组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; confirm &#125; <span class="keyword">from</span> <span class="string">&#x27;./confirm/index&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">&#x27;./message&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出对象、这个对象有install方法，这样既可以通过app.use(options)来使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、获取当前路径下所有文件夹中以index.vue结尾的文件</span></span><br><span class="line">    <span class="keyword">const</span> components = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;./*/index.vue&#x27;</span>)</span><br><span class="line">    <span class="comment">// 2、遍历获取到的组件模块：利用path生成组件名称, defineAsyncComponent生成动态组件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [path, fn] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(components)) &#123; <span class="comment">// path: ./popup/index.vue</span></span><br><span class="line">      <span class="comment">// 根据路径动态生成组件名称</span></span><br><span class="line">      <span class="keyword">const</span> componentName = <span class="string">&#x27;m-&#x27;</span> +  path.<span class="title function_">replace</span>(<span class="string">&#x27;./&#x27;</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">      <span class="comment">// 3、利用 app.component 将生成的组件名称和对应的异步组件注册到 Vue 应用上。使用 defineAsyncComponent 包装每个组件，这样组件会在第一次被使用时才加载，实现了组件的懒加载</span></span><br><span class="line">      app.<span class="title function_">component</span>(componentName, <span class="title function_">defineAsyncComponent</span>(fn))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、防抖搜索优化"><a href="#5、防抖搜索优化" class="headerlink" title="5、防抖搜索优化"></a>5、防抖搜索优化</h4><p>对输入框搜索功能实现防抖封装，减少了频繁请求，优化了页面性能和用户体验。</p>
<p>防抖主要用于减少频繁触发的事件处理次数，避免资源浪费和性能问题</p>
<p>防抖的核心思想：当触发一个事件时，不去立刻执行，而是延迟一段时间，该事件变为等待执行事件。如果在这段时间之内，该事件被再次触发，则上次等待执行的事件取消，本次触发的事件变为等待执行事件。循环往复，直到某一个等待事件被执行为止</p>
<p>项目中搜索提示组件是通过 <code>watch</code> 监听输入内容的变化，所以当输入内容发生变化时，就会立刻触发 <code>getHintData</code> 事件。此时需要做防抖处理， <code>vueuse</code> 中提供了对应的 <a target="_blank" rel="noopener" href="https://vueuse.org/shared/watchDebounced/">watchDebounced</a> ，可以直接利用这个 <code>API</code> 直接实现防抖的<code>watch</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; getHint &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/pexels&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; watchDebounced &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">// 监听搜索文本的变化，并获取对应提示数据</span></span><br><span class="line"><span class="title function_">watchDebounced</span>(<span class="function">() =&gt;</span> props.<span class="property">searchText</span>, getHintData, &#123;</span><br><span class="line">  <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">debounce</span>: <span class="number">500</span> <span class="comment">// 每次事件触发时，延迟的时间</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="移动端适配-响应式布局"><a href="#移动端适配-响应式布局" class="headerlink" title="移动端适配 - 响应式布局"></a>移动端适配 - 响应式布局</h4><ol>
<li><p><strong><em>百分比布局</em></strong>：通过百分比单位使浏览器中的组件的宽和高随着浏览器的变化而变化</p>
<ul>
<li><p><code>height</code>、<code>width</code>属性的百分比依托于父标签的宽高。但是<code>padding</code>、<code>border</code>、<code>margin</code>等属性的情况又不一样</p>
</li>
<li><p>1、子元素的<code>top</code>和<code>bottom</code>如果设置百分比，则相对于直接非<code>static</code>定位（默认定位）的父元素的高度，同样，子元素的<code>left</code>和<code>right</code>如果设置百分比，则相对于直接非<code>static</code>定位（默认定位的）父元素的宽度。<br>2、子元素的<code>padding</code>和<code>margin</code>如果设置百分比，不论是垂直方向或者是水平方向都相对于直接父亲元素的<code>width</code>，而与父元素的<code>height</code>无关。</p>
</li>
<li><p><code>border-radius</code>为百分比，则是相对于自身的宽度</p>
</li>
<li><p><strong>缺点：</strong>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位</p>
</li>
</ul>
</li>
<li><p><strong><em>媒体查询布局</em></strong>：通过<code>@media</code>媒体查询，给不同屏幕的大小编写不同的样式来实现。</p>
<ul>
<li>缺点：如果浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。</li>
</ul>
</li>
<li><p><strong><em><code>rem</code>布局</em></strong>： <code>rem</code> 是<code>CSS3</code>新增的一个相对单位，<em>1rem = 16px</em> </p>
<ul>
<li><p><code>rem</code>是相对于<code>html</code>根元素的字体大小的单位。</p>
</li>
<li><p>通过修改<code>html</code>中<code>font-size</code>的字体大小来控制<code>rem</code>的大小。</p>
</li>
</ul>
</li>
<li><p><strong><em><code>vw</code>、<code>vh</code>响应式布局</em></strong>：<code>vw</code>和<code>vh</code>分别相对的是视图窗口的宽度和高度。</p>
<ul>
<li><code>100vw = 100%</code>视图窗口宽度 ，<code>100vh = 100%</code> 视图窗口高度</li>
</ul>
</li>
<li><p><strong><em><code>flex</code>弹性布局</em></strong>：只需要依赖于<code>CSS</code>样式的实现响应式布局的方式</p>
<ol>
<li>父元素：常用的弹性布局的属性<ul>
<li><code>flex-direction</code> ：水平方向对齐方式（<code>wrap\wrap-reverse\colume\colume</code>）</li>
<li><code>flex-wrap</code> ：是否换行</li>
<li><code>justify-content</code> ： 水平方向对齐方式</li>
<li><code>align-items</code> ：控制子元素在垂直方向上的对齐方式</li>
<li><code>align-content</code>：垂直方向的对齐方式</li>
</ul>
</li>
<li>子元素：常用的弹性布局的属性<ul>
<li><code>order</code>：排序，给元素指定不同数值，数值越大越靠后</li>
<li><code>flex-grow</code>： 对容器剩余空间，按指定比例放大元素填充容器</li>
<li><code>flex-shrink</code>：对超出容器空间按数值比例收缩填充</li>
<li><code>flex-basis</code>：指定元素在主轴（水平）方向上的初始大小</li>
<li><code>align-self</code>：控制单个元素在交叉轴（垂直）上的对齐</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>项目中使用的是<strong><code>flex + rem</code></strong>响应式布局的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次加载成功时设置html跟标签的fontSize属性值；最大基准值为40px</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useREM</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">MAX_FONT_SIZE</span> = <span class="number">40</span> <span class="comment">// 最大基准值</span></span><br><span class="line">  <span class="comment">// 当文档被解析成功时调用</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;html&#x27;</span>)</span><br><span class="line">    <span class="comment">// 设置屏幕基准值的标准为 屏幕的宽度 / 10</span></span><br><span class="line">    <span class="keyword">const</span> fontSize = <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="number">10</span></span><br><span class="line">    html.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="title class_">Math</span>.<span class="title function_">min</span>(fontSize, <span class="variable constant_">MAX_FONT_SIZE</span>) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="人力资源后台项目"><a href="#人力资源后台项目" class="headerlink" title="人力资源后台项目"></a>人力资源后台项目</h3><h4 id="1、权限"><a href="#1、权限" class="headerlink" title="1、权限"></a>1、权限</h4><blockquote>
<p>使用<code>vue-router</code>配置路由切换视图，在权限模块中基于<code>RBAC</code>权限模型实现动态添加路由规则，完成不同角色的权限分配。（员工 - 角色 - 权限）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RBAC权限控制和Token认证的使用，流程大致如下:</span><br><span class="line">1.用户登录时，客户端向服务端发送登录请求，服务端验证用户名密码是否正确，如果正确则返回一个Token值给客户端。</span><br><span class="line">2.客户端在后续的请求中，在Header中携带这个Token值，服务端根据Token值来识别用户身份。</span><br><span class="line">3.服务端根据用户的身份和角色信息，对请求的API接口或页面元素进行权限判断，如果有权限则返回数据，否则返回403或401等错误码。</span><br></pre></td></tr></table></figure>
<p>权限管理就是让不同的用户只能访问自己权限内的资源，有以下几种</p>
<ul>
<li>路由权限，用户登录后只能看到自己权限内的导航菜单，且只能访问自己权限内的路由地址</li>
<li>视图权限，用户只能看到自己权限内的内容和按钮</li>
<li>请求权限，越权请求将其拦截</li>
</ul>
<p><strong>权限管理</strong>：接口权限、按钮权限、菜单权限、路由权限</p>
<ul>
<li><strong>接口权限</strong></li>
</ul>
<p>用户登录成功拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，请求头要携带<code>token</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.<span class="property">headers</span>[<span class="string">&#x27;token&#x27;</span>] = cookie.<span class="title function_">get</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;,&#123;response&#125;=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">203</span>) &#123; <span class="comment">//token过期或者错误</span></span><br><span class="line">    router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>路由权限</strong></li>
</ul>
<p><strong>方法1</strong>：在路由初始化的时候挂载全部路由，在路由上标记相应的权限信息，当路由跳转的时候做校验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = [</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/home&#x27;</span>),</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;homePage&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;主页&#x27;</span>,</span><br><span class="line">        <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;editor&#x27;</span>] <span class="comment">//权限</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>会加载所有的路由，当路由很多的时候，对性能会有影响；</li>
<li>每次路由跳转都要做权限判断；</li>
<li>菜单信息写在前端，需要修改标题的时候，需要重新编译；</li>
<li>菜单跟路由耦合在一起，路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<p><strong>方法2：项目</strong>：初始化的时候先挂载静态（不需要权限控制的）路由，比如登录页，404页。如果用户通过URL进行强制访问，会直接进入404。登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用<code>addRoutes</code>添加路由（⭐）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022028328.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拆分静态路由和动态路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态路由：没有权限的页面，所有角色都可以进入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> constantRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>, <span class="comment">// 登录页</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/login/index&#x27;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/404&#x27;</span>, <span class="comment">// 404页</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/404&#x27;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="comment">// 首页</span></span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/dashboard&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;dashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Dashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/dashboard/index&#x27;</span>),</span><br><span class="line">      <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;首页&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;dashboard&#x27;</span> &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// &#123; path: &#x27;*&#x27;, redirect: &#x27;/404&#x27;, hidden: true &#125;// 404 页必须放在末尾 !!!</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">// 动态路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> asyncRoutes = [</span><br><span class="line">  departmentRouter,</span><br><span class="line">  roleRouter,</span><br><span class="line">  employeeRouter,</span><br><span class="line">  permissionRouter,</span><br><span class="line">  attendanceRouter,</span><br><span class="line">  approvalRouter,</span><br><span class="line">  salaryRouter,</span><br><span class="line">  socialRouter</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createRouter</span> = (<span class="params"></span>) =&gt; <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="comment">// mode: &#x27;history&#x27;, // 需要服务支持</span></span><br><span class="line">  <span class="attr">scrollBehavior</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</span><br><span class="line">  <span class="attr">routes</span>: constantRoutes <span class="comment">// 默认引入静态路由</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resetRouter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newRouter = <span class="title function_">createRouter</span>()</span><br><span class="line">  router.<span class="property">matcher</span> = newRouter.<span class="property">matcher</span> <span class="comment">// 重置路由</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<p>使用<code>addRoutes</code>动态挂载路由：应用初始化的时候先挂载不需要权限控制的路由，比如登录页，404 页。登录成功后，获取用户资料的权限信息（vuex），然后筛选有权限访问的路由(asyncRoutes.filter)，再在全局路由守卫里调用addRoutes添加路由。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022028370.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> nprogress <span class="keyword">from</span> <span class="string">&#x27;nprogress&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;nprogress/nprogress.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; asyncRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置守卫</span></span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&#x27;/login&#x27;</span>, <span class="string">&#x27;/404&#x27;</span>] <span class="comment">// 白名单：不需要token也能访问</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="title function_">async</span>(to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  nprogress.<span class="title function_">start</span>() <span class="comment">// 开启进度条nprogress</span></span><br><span class="line">  <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">token</span>) &#123; <span class="comment">// 存在token</span></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) &#123; <span class="comment">// 跳转到主页 </span></span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/&#x27;</span>) <span class="comment">// 主页</span></span><br><span class="line">      nprogress.<span class="title function_">done</span>() <span class="comment">//next（地址）并没有执行后置守卫，需手动关闭进度条</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//////// 重点代码 ////////////////////////////////////////////////////</span></span><br><span class="line">      <span class="keyword">if</span> (!store.<span class="property">getters</span>.<span class="property">userId</span>) &#123; <span class="comment">// 判断是否获取过用户资料</span></span><br><span class="line">        <span class="keyword">const</span> &#123; roles &#125; = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/getUserInfo&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> filterRoutes = asyncRoutes.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> roles.<span class="property">menus</span>.<span class="title function_">includes</span>(item.<span class="property">name</span>)</span><br><span class="line">        &#125;) <span class="comment">// 筛选后的路由，filter返回一个布尔值</span></span><br><span class="line">        store.<span class="title function_">commit</span>(<span class="string">&#x27;user/setRoutes&#x27;</span>, filterRoutes)<span class="comment">//将筛选后的路由添加到vuex</span></span><br><span class="line">        router.<span class="title function_">addRoutes</span>([...filterRoutes, &#123; <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/404&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;]) <span class="comment">// 添加动态路由信息到路由表</span></span><br><span class="line">        <span class="title function_">next</span>(to.<span class="property">path</span>) <span class="comment">// router添加动态路由之后,需要转发一下,目的是让路由拥有信息(router的已知缺陷)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">next</span>() <span class="comment">// 放过</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">/////// 重点代码 ///////////////////////////////////////////////////////  </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有token</span></span><br><span class="line">    <span class="keyword">if</span> (whiteList.<span class="title function_">includes</span>(to.<span class="property">path</span>)) &#123;</span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) <span class="comment">// 中转到登录页</span></span><br><span class="line">      nprogress.<span class="title function_">done</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置守卫</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  nprogress.<span class="title function_">done</span>() <span class="comment">// 关闭进度条</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p>
<p><em>缺点</em> ：① 全局路由守卫里，每次路由跳转都要做判断     ② 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译     ③ 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</p>
<ul>
<li><strong>菜单权限</strong></li>
</ul>
<p>用户登录之后服务端返回一个数据，这个数据有菜单列表和<code>token</code>，我们把这个数据放入到<code>vuex</code>中，然后主页根据<code>vuex</code>中的数据进行菜单列表的渲染（⭐）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">在vuex用户模块添加路由信息state，筛选路由后提交mutation更新state，渲染左侧菜单</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; constantRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">token</span>: <span class="title function_">getToken</span>(), <span class="comment">// 从缓存中读取初始值</span></span><br><span class="line">  <span class="attr">userInfo</span>: &#123;&#125;, <span class="comment">// 存储用户基本资料状态</span></span><br><span class="line">  <span class="attr">routes</span>: constantRoutes <span class="comment">// 静态路由的数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="title function_">setRoutes</span>(<span class="params">state, newRoutes</span>) &#123;</span><br><span class="line">    state.<span class="property">routes</span> = [...constantRoutes, ...newRoutes] <span class="comment">// 静态路由 + 动态路由</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;user/setRoutes&#x27;</span>, filterRoutes)<span class="comment">//将筛选后的路由添加到vuex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染左侧菜单</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  .......</span><br><span class="line">  <span class="attr">routes</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">user</span>.<span class="property">routes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getters</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">SidebarItem</span>, <span class="title class_">Logo</span> &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapGetters</span>([</span><br><span class="line">      <span class="string">&#x27;sidebar&#x27;</span>, <span class="string">&#x27;routes&#x27;</span></span><br><span class="line">    ]),</span><br><span class="line">    <span class="comment">// 路由信息的计算属性</span></span><br><span class="line">    <span class="comment">// routes() &#123;</span></span><br><span class="line">    <span class="comment">//   // 返回所有的路由信息</span></span><br><span class="line">    <span class="comment">//   return this.$router.options.routes</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案1：菜单与路由分离，菜单由后端返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">name字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;login&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/pages/Login.vue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是对应的，后端返回的菜单就已经是经过权限过滤的。若根据路由name找不到对应的菜单，就表示用户有没权限访问。</span><br><span class="line"></span><br><span class="line">如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载（路由权限方法<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line">这种方式的缺点：</span><br><span class="line">菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</span><br><span class="line">全局路由守卫里，每次路由跳转都要做判断</span><br></pre></td></tr></table></figure>
<p>方案2：菜单和路由都由后端返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端统一定义路由组件：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../pages/Home.vue&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserInfo</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../pages/UserInfo.vue&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">home</span>: <span class="title class_">Home</span>,</span><br><span class="line">    <span class="attr">userInfo</span>: <span class="title class_">UserInfo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后端路由组件返回以下格式：</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">&quot;home&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/userinfo&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">&quot;userInfo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件</span><br><span class="line">如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理</span><br><span class="line"></span><br><span class="line">这种方法也会存在缺点：全局路由守卫里，每次路由跳转都要做判断；前后端的配合要求更高</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>按钮权限</strong></li>
</ul>
<p>方案1：用<code>v-if</code>判断。但如果页面过多，每个页面页面都要获取用户权限<code>role</code>和路由表里的<code>meta.btnPermissions</code>，然后再做判断。</p>
<p>方案2：通过自定义指令进行按钮权限的判断（⭐）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装自定义指令 用来控制操作权</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;permission&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 会在指令作用的元素插入到页面完成以后触发</span></span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(el) <span class="comment">// el 指令作用的元素的dom对象</span></span><br><span class="line">    <span class="keyword">const</span> points = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>?.<span class="property">roles</span>?.<span class="property">points</span> || [] <span class="comment">// 当前用户信息的操作权</span></span><br><span class="line">    <span class="keyword">if</span> (!points.<span class="title function_">includes</span>(binding.<span class="property">value</span>))&#123; <span class="comment">// 不存在就要删除或者禁用</span></span><br><span class="line">      el.<span class="title function_">remove</span>() <span class="comment">// 删除元素</span></span><br><span class="line">      <span class="comment">// el.disabled = true</span></span><br><span class="line">      <span class="comment">// 线上的权限数据和线下的代码进行对应</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用自定义指令</span></span><br><span class="line">&lt;el-button v-permission=<span class="string">&quot;&#x27;add-employee&#x27;&quot;</span> size=<span class="string">&quot;mini&quot;</span> type=<span class="string">&quot;primary&quot;</span> @click=<span class="string">&quot;$router.push(&#x27;/employee/detail&#x27;)&quot;</span>&gt;</span><br><span class="line">  添加员工</span><br><span class="line">&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2、vuex管理"><a href="#2、vuex管理" class="headerlink" title="2、vuex管理"></a>2、<code>vuex</code>管理</h4><blockquote>
<p>在<code>vuex</code>中对<code>token</code>进行管理，将用户的<code>token</code>状态共享，实现后续高效目方便的读取。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">项目登录流程：表单校验通过 --&gt; 调用<span class="title class_">Vuex</span>提供的登录的action --&gt; 登录的<span class="title class_">Action</span>中会调用接口 --&gt; 登录接口如果成功执行，会返回token --&gt; 利用<span class="title class_">Vuex</span>特性，将token共享的到<span class="title class_">Vuex</span>中，这样直接通过 <span class="title class_">Vuex</span> 就可以登录接口会调用单独封装的请求模块(api) --&gt; 请求模块中又会使用用到 axios 封装的请求工具 --&gt; 而请求工具又要考虑区分 开发环境和生产环境的问题 --&gt; 请求时还要考虑前后分离项目产生的跨域问题，要使用代理解决跨域</span><br><span class="line"><span class="title class_">Vuex</span>中声明用户信息状态，修改用户信息的mutations， 和获取用户信息的action</span><br><span class="line">实现token的<span class="title class_">Vue</span>数据持久化</span><br><span class="line"><span class="keyword">import</span> &#123; getToken, setToken, removeToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; login, getUserInfo &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; constantRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; resetRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">token</span>: <span class="title function_">getToken</span>(), <span class="comment">// 从缓存中读取初始值</span></span><br><span class="line">  <span class="attr">userInfo</span>: &#123;&#125;, <span class="comment">// 存储用户基本资料状态</span></span><br><span class="line">  <span class="attr">routes</span>: constantRoutes <span class="comment">// 静态路由的数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="title function_">setToken</span>(<span class="params">state, token</span>) &#123;</span><br><span class="line">    state.<span class="property">token</span> = token</span><br><span class="line">    <span class="title function_">setToken</span>(token) <span class="comment">// 同步到缓存</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">removeToken</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">token</span> = <span class="literal">null</span> <span class="comment">// 删除Vuex的token</span></span><br><span class="line">    <span class="title function_">removeToken</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setUserInfo</span>(<span class="params">state, userInfo</span>) &#123;</span><br><span class="line">    state.<span class="property">userInfo</span> = userInfo</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setRoutes</span>(<span class="params">state, newRoutes</span>) &#123;</span><br><span class="line">    state.<span class="property">routes</span> = [...constantRoutes, ...newRoutes] <span class="comment">// 静态路由 + 动态路由</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">login</span>(<span class="params">context, data</span>) &#123;<span class="comment">// context上下文，传入参数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    <span class="comment">// todo: 调用登录接口</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="keyword">await</span> <span class="title function_">login</span>(data)</span><br><span class="line">    <span class="comment">// 返回一个token 123456</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;setToken&#x27;</span>, token)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getUserInfo</span>(<span class="params">context</span>) &#123;<span class="comment">// 获取用户的基本资料</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getUserInfo</span>()</span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;setUserInfo&#x27;</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result <span class="comment">// 返回数据</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// token失效响应拦截器异常，会调用退出登录action</span></span><br><span class="line">  <span class="title function_">logout</span>(<span class="params">context</span>) &#123; <span class="comment">// 退出登录的action</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;removeToken&#x27;</span>) <span class="comment">// 删除token</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;setUserInfo&#x27;</span>, &#123;&#125;) <span class="comment">// 设置用户信息为空对象</span></span><br><span class="line">    <span class="title function_">resetRouter</span>()<span class="comment">// 重置路由</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用户信息不同于token，token是当前用户的唯一标识，在几个小时内都是有效的，但是用户信息可能会进行修改或者发生变化，所以用户信息在一般的项目或者业务中不进行缓存。</span><br></pre></td></tr></table></figure>
<h4 id="3、excel导入导出"><a href="#3、excel导入导出" class="headerlink" title="3、excel导入导出"></a>3、<code>excel</code>导入导出</h4><blockquote>
<p>使用FileSaver.js第三方库实现员工信息excel文件的导入导出。</p>
</blockquote>
<ul>
<li>员工管理 - excel导出</li>
</ul>
<p>导出员工接口返回的是二进制流，axios配置responseType为blob接收二进制流文件为Blob格式。安装file-saver包，实现下载Blob文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>封装导出员工excel的<span class="variable constant_">API</span></span><br><span class="line"><span class="comment">// 导出员工的excel</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">exportEmployee</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/sys/user/export&#x27;</span>,</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span> <span class="comment">// 改变接收数据的类型：使用blob接收二进制文件流</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>拦截器判断是不是blob类型，如果是直接返回数据，不再进行解构</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// axios默认包裹了data，判断是不是Blob</span></span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">data</span> <span class="keyword">instanceof</span> <span class="title class_">Blob</span>) <span class="keyword">return</span> response.<span class="property">data</span> <span class="comment">// 返回了Blob对象</span></span><br><span class="line">  <span class="keyword">const</span> &#123; data, message, success &#125; = response.<span class="property">data</span> <span class="comment">// 默认json格式</span></span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title class_">Message</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>, message &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(message))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>点击按钮调用接口，使用file-saver将blob转化成文件下载</span><br><span class="line">&lt;el-button size=<span class="string">&quot;mini&quot;</span> @click=<span class="string">&quot;exportEmployee&quot;</span>&gt;excel导出&lt;/el-button&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FileSaver</span> <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportEmployee &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/employee&#x27;</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">exportEmployee</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">exportEmployee</span>() <span class="comment">// 导出所有的员工接口</span></span><br><span class="line">  <span class="comment">// FileSaver.saveAs(blob对象, 文件名称)</span></span><br><span class="line">  <span class="title class_">FileSaver</span>.<span class="title function_">saveAs</span>(result, <span class="string">&#x27;员工信息表.xlsx&#x27;</span>) <span class="comment">// 下载文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>员工管理 - excel导入</li>
</ul>
<p><code>创建组件 --&gt; 点击按钮弹出组件 --&gt; 下载模板、上传excel、拖拽上传 --&gt; 导入成功、取消 --&gt; 关闭并重新加载、关闭</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>下载导入模板：调用下载模板接口 --&gt; 接收二进制blob --&gt; 下载文件</span><br><span class="line"><span class="comment">// 下载员工导入模版api</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getExportTemplate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/sys/user/import/template&#x27;</span>,</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span> <span class="comment">// 二进制文件流</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点击按钮进行下载模板</span></span><br><span class="line">&lt;el-button type=<span class="string">&quot;text&quot;</span> @click=<span class="string">&quot;getTemplate&quot;</span>&gt;下载导入模板&lt;/el-button&gt;</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getTemplate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">getExportTemplate</span>()</span><br><span class="line">  <span class="title class_">FileSaver</span>.<span class="title function_">saveAs</span>(data, <span class="string">&#x27;员工导入模版.xlsx&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>上传excel：弹出文件选择框 --&gt; 文件选择 --&gt; 调用上传接口 --&gt; 成功 --&gt; 重新加载数据-关闭弹窗 --&gt; 清空文件选择器</span><br><span class="line"><span class="comment">// 1、封装上传excel的API：上传用户的excel</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">uploadExcel</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/sys/user/import&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data <span class="comment">// form-data类型 因为要上传文件类型</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、点击上传-弹出文件选择框</span></span><br><span class="line">&lt;el-button type=<span class="string">&quot;text&quot;</span> @click=<span class="string">&quot;handleUpload&quot;</span>&gt;点击上传&lt;/el-button&gt;</span><br><span class="line"><span class="title function_">handleUpload</span>(<span class="params"></span>) &#123; <span class="comment">// 触发文件选择框的input的输入框，绑定ref值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>[<span class="string">&#x27;excel-upload-input&#x27;</span>].<span class="title function_">click</span>() <span class="comment">// this.$refs.属性名 和 this.$refs[属性名] 等价</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 3、监听文件改变-上传excel-关闭弹层</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">ref</span>=<span class="string">&quot;excel-upload-input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">class</span>=<span class="string">&quot;excel-upload-input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">accept</span>=<span class="string">&quot;.xlsx, .xls&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  @<span class="attr">change</span>=<span class="string">&quot;uploadChange&quot;</span> // ⭐</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">async uploadChange(event) &#123; // event.target.files[0]内为excel文件</span></span><br><span class="line"><span class="language-xml">  // 调用上传接口：uploadExcel() 中参数form-data 需要文件file</span></span><br><span class="line"><span class="language-xml">  const files = event.target.files // 文件选择框的input的文件列表</span></span><br><span class="line"><span class="language-xml">  if (files.length &gt; 0) &#123;// 大于0 说明有文件要上传</span></span><br><span class="line"><span class="language-xml">    const data = new FormData()</span></span><br><span class="line"><span class="language-xml">    data.append(&#x27;file&#x27;, files[0]) // file: file类型，将文件参数加入到formData中</span></span><br><span class="line"><span class="language-xml">    try &#123;</span></span><br><span class="line"><span class="language-xml">      await uploadExcel(data)</span></span><br><span class="line"><span class="language-xml">      this.$emit(&#x27;uploadSuccess&#x27;) // 通知父组件上传成功 -&gt; 重新加载数据</span></span><br><span class="line"><span class="language-xml">      this.$emit(&#x27;update:showExcelDialog&#x27;, false) // 关闭弹层</span></span><br><span class="line"><span class="language-xml">      // this.$refs[&#x27;excel-upload-input&#x27;].value = &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">    &#125; catch (error) &#123;// 捕获失败</span></span><br><span class="line"><span class="language-xml">      // this.$refs[&#x27;excel-upload-input&#x27;].value = &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">    &#125; finally &#123;</span></span><br><span class="line"><span class="language-xml">      // 不论成功或者失败都会执行finally，所以在这里执行清空文件选择器操作</span></span><br><span class="line"><span class="language-xml">      this.$refs[&#x27;excel-upload-input&#x27;].value = &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">// 4、父组件需要监听上传成功的事件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">import-excel</span> <span class="attr">:show-excel-dialog.sync</span>=<span class="string">&quot;showExcelDialog&quot;</span> @<span class="attr">uploadSuccess</span>=<span class="string">&quot;getEmployeeList&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="4、递归列表转树"><a href="#4、递归列表转树" class="headerlink" title="4、递归列表转树"></a>4、递归列表转树</h4><blockquote>
<p>使用递归算法将组织架构的树形组件中的列表型结构转换为树形结构。</p>
</blockquote>
<p>树形组件-用层级结构展示信息，可展开或折叠，<code>element-ui</code>提供了树组件<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN/component/tree">el-tree</a>的应用</p>
<p>default-expand-all (默认展开所有节点)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022013813.png" alt=""></p>
<ol>
<li>首先分析数据的关联关系（部门id是子部门的pid）</li>
<li>封装递归函数根据关联关系转化层级结构</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022013695.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、获取组织架构数据：① 封装获取组织的<span class="variable constant_">API</span>   ② 在组织架构初始化时调用方法</span><br><span class="line"><span class="comment">// 封装获取组织的API</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"><span class="comment">// 获取组织架构数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getDepartment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/company/department&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在组织架构初始化时调用方法</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; getDepartment &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/department&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>  &#123;</span><br><span class="line">      <span class="attr">depts</span>: [],</span><br><span class="line">      <span class="attr">defaultProps</span>: &#123;</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;children&#x27;</span>, <span class="comment">// 设置子节点的字段名</span></span><br><span class="line">        <span class="attr">label</span>: <span class="string">&#x27;name&#x27;</span> <span class="comment">// 设置显示内容的字段名</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getDepartment</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">   <span class="keyword">async</span> <span class="title function_">getDepartment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getDepartment</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depts</span> = result</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、递归转化树形结构</span><br><span class="line"><span class="comment">// 封装方法：列表型数据转化树形</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">transListToTreeData</span>(<span class="params">list, rootValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  list.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">pid</span> === rootValue) &#123;<span class="comment">// 找到了匹配的节点</span></span><br><span class="line">      <span class="comment">// 当前节点的id 和 当前节点的子节点的pid是想等的</span></span><br><span class="line">      <span class="keyword">const</span> children = <span class="title function_">transListToTreeData</span>(list, item.<span class="property">id</span>) <span class="comment">// 找到的节点的子节点⭐</span></span><br><span class="line">      item.<span class="property">children</span> = children  <span class="comment">// 将子节点赋值给当前节点</span></span><br><span class="line">      arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取完的组织数据使用转化方法转化成树形</span></span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getDepartment</span>() <span class="comment">// 调用获取数据的接口</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getDepartment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getDepartment</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depts</span> = <span class="title function_">transListToTreeData</span>(result, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归特点：① 一般用来处理未知层级的数据      ② 递归要有跳出条件     ③ 自身调用自身时参数不能重复</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型（栈）：直接存储在内存中的数据，值不可变</span><br><span class="line">	<span class="title class_">Number</span>、<span class="title class_">String</span>、<span class="title class_">Boolean</span>、<span class="title class_">Null</span>-空值、<span class="title class_">Undefined</span>-未定义、<span class="title class_">Symbol</span>(<span class="title class_">ES6</span>)、<span class="title class_">BigInt</span>(<span class="title class_">ES2020</span>)</span><br><span class="line">	<span class="title class_">Number</span>特殊值：<span class="title class_">Infinity</span>-正无穷大、-<span class="title class_">Infinity</span>-负无穷大、<span class="title class_">NaN</span>-非数值</span><br><span class="line">  当使用 <span class="keyword">var</span>或 <span class="keyword">let</span>声明了变量但没有初始化时，就相当于给变量赋予了 <span class="literal">undefined</span>值</span><br><span class="line">	<span class="title class_">Symbol</span>：表示一个独一无二的值，通常用于对象属性的唯一标识符。</span><br><span class="line">	<span class="title class_">BigInt</span>：表示任意大的整数，用来处理超过<span class="title class_">Number</span>类型能表示的安全整数范围<span class="number">2</span>^<span class="number">53</span>-<span class="number">1</span></span><br><span class="line">引用数据类型（堆）：存储的是对象的地址或引用，变量保存的是指向内存中某个对象的引用，而不是实际的值。</span><br><span class="line">	<span class="title class_">Object</span>、<span class="title class_">Array</span>、<span class="title class_">Function</span>、<span class="title class_">Date</span>、<span class="title class_">RegExp</span>(正则表达式)、<span class="title class_">Map</span>和<span class="title class_">Set</span>(<span class="title class_">ES6</span>)</span><br><span class="line">	<span class="title class_">Map</span> 是一个键值对的集合，键可以是任意类型;<span class="title class_">Set</span> 是一个值的集合，集合中的值都是唯一的。</span><br></pre></td></tr></table></figure>
<h3 id="判断数据类型的方法及区别"><a href="#判断数据类型的方法及区别" class="headerlink" title="判断数据类型的方法及区别"></a>判断数据类型的方法及区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">typeof</span> - 主要用于检测基本数据类型</span><br><span class="line">	注意：<span class="literal">null</span> 返回的是 <span class="title class_">Object</span> （js缺陷）；且对于引用类型返回的都是 object 因为所有的对象的原型最终都是 <span class="title class_">Object</span>。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">instanceof</span> - 用于检查某个对象是否是某个类或构造函数的实例，主要用于判断复杂的引用类型。原理就是查找目标对象的原型链。</span><br><span class="line">	示例：[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//true  function()&#123;&#125; instanceof Function // true</span></span><br><span class="line"><span class="number">3</span>、<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>() - 更精确的判断数据类型的方法，适合用于判断所有类型。</span><br><span class="line">	示例：<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line">       <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/regex/</span>) <span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line">	手写：<span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>)); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="number">4</span>、constructor 属性 - 每个<span class="variable constant_">JS</span>对象都有，用于指向创建该对象的构造函数。可通过该属性来判断类型。</span><br><span class="line">	注意：<span class="literal">null</span> 和 <span class="literal">undefined</span>是无效的对象，不会有 constructor 存在，无法据此属性判断。</span><br><span class="line">			 <span class="variable constant_">JS</span>对象的 constructor 是不稳定的，主要体现在自定义对象上，当开发者重写prototype 后，原有的 constructor会丢失，constructor 会默认为<span class="title class_">Object</span>。</span><br><span class="line">        类继承的也会出错，因为 <span class="title class_">Object</span> 被覆盖了，检测结果就不对了。</span><br><span class="line"><span class="number">5</span>、<span class="title class_">Array</span>.<span class="title function_">isArray</span>() - 专门用于判断某个值是否为数组的函数，返回<span class="literal">true</span>/<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="闭包和内存泄露"><a href="#闭包和内存泄露" class="headerlink" title="闭包和内存泄露"></a>闭包和内存泄露</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">闭包是指有权访问另一个函数作用域中变量的函数</span><br><span class="line">形成闭包的原因：内部的函数存在外部作用域的引用就会导致闭包。</span><br><span class="line"></span><br><span class="line">闭包的作用：保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 闭包是有权访问另一个函数作用域变量的函数 </span><br><span class="line">(<span class="number">2</span>) 闭包一般是函数嵌套，一个函数返回另外一个函数，内部函数访问外部函数的变量就形成了一个闭包 </span><br><span class="line">(<span class="number">3</span>) 闭包的优点是可以私有化变量，将变量私有化到函数内部，并在私有化的基础上进行数据保持 </span><br><span class="line">(<span class="number">4</span>) 闭包在防抖节流函数柯里化，都应用里数据保持这个特性 </span><br><span class="line">(<span class="number">5</span>) 在防抖函数中，第一次点击的时候，我们会<span class="keyword">let</span>一个time一个定时器，如果不采用闭包的话，下次触发函数会重新创建一个新的定时器，两个定时器的引用不同，是没有关联的，使用闭包可以直接在内存中找到之前创建的计时器，调用就可以直接拿到对应的定时器的时间 </span><br><span class="line">(<span class="number">6</span>) 闭包的缺点是容易造成内存泄露，因为闭包创建的变量会一直存在内存中，需要及时置空，否则会造成内存泄露，影响程序性能</span><br><span class="line"></span><br><span class="line">闭包导致内存泄漏：</span><br><span class="line"><span class="number">1.</span>持有了不再需要的函数引用，会导致函数关联的词法环境无法销毁，从而导致内存泄漏</span><br><span class="line"><span class="number">2.</span>当多个函数共享词法环境时，会导致词法环境膨胀，从而导致出现无法触达也无法回收的内存空间</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用于复制对象和数组</span><br><span class="line">浅拷贝</span><br><span class="line">	只复制对象的第一层属性，如果属性值是引用类型（如对象或数组），它们复制的只是引用地址，而不是实际的值。因此，如果修改嵌套对象或数组，浅拷贝和原对象都会受到影响。</span><br><span class="line">深拷贝</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="和"><a href="#和" class="headerlink" title="==和==="></a><code>==</code>和<code>===</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">等于操作符（==）：</span><br><span class="line">	在比较中会先进行类型转换，再确定操作数是否相等。如果操作数相等，则会返回 <span class="literal">true</span>。</span><br><span class="line">	<span class="number">1</span>、两个都为简单类型，字符串和布尔值都会转换成数值，再比较</span><br><span class="line">	<span class="number">2</span>、简单类型与引用类型比较，对象转化成其原始类型的值，再比较</span><br><span class="line">	<span class="number">3</span>、两个都为引用类型，则比较它们是否指向同一个对象</span><br><span class="line">	<span class="number">4</span>、<span class="literal">null</span> 和 <span class="literal">undefined</span> 相等</span><br><span class="line">	<span class="number">5</span>、存在 <span class="title class_">NaN</span> 则返回 <span class="literal">false</span></span><br><span class="line">全等操作符（===）：</span><br><span class="line">	只有两个操作数在不转换的前提下相等才返回 <span class="literal">true</span>。即类型相同，值也需相同</span><br><span class="line">区别：</span><br><span class="line">	相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换</span><br><span class="line">	<span class="literal">null</span> 和 <span class="literal">undefined</span> 比较，相等操作符（==）为<span class="literal">true</span>，全等为<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="如何封装组件"><a href="#如何封装组件" class="headerlink" title="如何封装组件"></a>如何封装组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先进行需求分析，确定组件功能和实现方式。再定义组件 <span class="variable constant_">API</span>，包括传入的 props 和事件。最后编写组件测试用例，确保组件功能正确。</span><br><span class="line"></span><br><span class="line">封装组件时要注意组件的可复用性、易维护性和可测试性。在编写组件时，应该遵循单一职责原则，尽量避免组件之间的耦合，提供清晰简洁的 <span class="variable constant_">API</span>，确保组件功能正确，并编写充分的测试用例，以便于其他开发者和用户使用和维护组件。</span><br></pre></td></tr></table></figure>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="css权重"><a href="#css权重" class="headerlink" title="css权重"></a>css权重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="number">1000</span> 内联样式：&lt;div style=<span class="string">&quot;color: red;&quot;</span>&gt;<span class="title class_">Hello</span>&lt;/div&gt;</span><br><span class="line"><span class="number">2.</span> <span class="number">100</span> id选择器：#header &#123; <span class="attr">color</span>: blue; &#125;</span><br><span class="line"><span class="number">3.</span> <span class="number">10</span> 类选择器【.<span class="property">button</span> &#123;&#125;】、属性选择器【[type=<span class="string">&quot;text&quot;</span>] &#123; &#125;】、伪类选择器【<span class="attr">a</span>:hover &#123; &#125;】</span><br><span class="line"><span class="number">4.</span> <span class="number">1</span> 元素选择器【div &#123; <span class="attr">color</span>: black; &#125;】、伪元素选择器【::before &#123; &#125;】</span><br></pre></td></tr></table></figure>
<h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">行内元素：span a</span><br><span class="line"><span class="number">1</span>、line-height 设置为与父容器的 height 一致 和 text-align：center</span><br><span class="line"><span class="number">2</span>、justify-<span class="attr">content</span>: center 水平居中，align-<span class="attr">items</span>: center 垂直居中。</span><br><span class="line"></span><br><span class="line">块元素：div</span><br><span class="line"><span class="number">1</span>、flex+margin</span><br><span class="line">  父元素：<span class="attr">display</span>: flex;</span><br><span class="line">         justify-<span class="attr">content</span>: center;</span><br><span class="line">         align-<span class="attr">items</span>: center</span><br><span class="line"><span class="number">2</span>、定位+tranform</span><br><span class="line">  父元素：<span class="attr">position</span>: relative</span><br><span class="line">  子元素：<span class="attr">position</span>: absolute;  使元素的左上角移动到父容器的正中央</span><br><span class="line">         <span class="attr">top</span>: <span class="number">50</span>%; <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">         <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">50</span>%)  使元素的中心点对齐</span><br><span class="line"><span class="number">3</span>、grid网格布局</span><br><span class="line">  父元素：<span class="attr">display</span>: grid;</span><br><span class="line">         place-<span class="attr">items</span>: center 让子元素在 <span class="title class_">Grid</span> 容器中水平和垂直方向居中</span><br></pre></td></tr></table></figure>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从内到外由四个部分构成：内容区域（content）、内边距（padding，内边距的颜色与内容区域相同，不能设置透明）、边框（border，会影响盒子占据的总空间）、外边距（margin）</span><br><span class="line"></span><br><span class="line">标准和模型<span class="title class_">Content</span>-box：</span><br><span class="line">	width只包含内容宽度，不包含border和padding。</span><br><span class="line">	offsetWidth = (width + padding + border),不算margin</span><br><span class="line"><span class="variable constant_">IE</span>盒模型border-box：怪异盒模型</span><br><span class="line">	width/height包括内容区、padding、border</span><br></pre></td></tr></table></figure>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">static</span>（默认值）：元素处于正常的文档流中。</span><br><span class="line"><span class="number">2</span>、relative：相对定位。元素在正常文档流中的位置不变，但可以通过设置top等属性来相对于其正常位置进行偏移。发生偏移时可能会覆盖其他元素，但不会影响其他元素的布局。</span><br><span class="line"><span class="number">3</span>、absolute：绝对定位。元素脱离正常文档流，并相对于最近的已定位祖先元素或 &lt;body&gt; 元素进行定位。如果没有已定位的祖先元素，则相对于视口进行定位。</span><br><span class="line"><span class="number">4</span>、fixed：固定定位。元素脱离正常文档流，并相对于视口进行定位。</span><br><span class="line"><span class="number">5</span>、sticky：粘性定位。元素根据正常文档流进行定位，然后相对于离它最近的具有滚动机制的祖先元素或视口进行定位。当用户滚动页面时，元素的定位会发生变化。</span><br></pre></td></tr></table></figure>
<h3 id="vw、vh、rem、em区别"><a href="#vw、vh、rem、em区别" class="headerlink" title="vw、vh、rem、em区别"></a>vw、vh、rem、em区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、vw：viewpoint width，视口宽度的百分比单位。100vw = <span class="number">100</span>% 视图窗口宽度。</span><br><span class="line"><span class="number">2</span>、vh：viewpoint height，视口高度的百分比单位。100vh = <span class="number">100</span>% 视图窗口高度。</span><br><span class="line"><span class="number">3</span>、rem（<span class="title class_">Root</span> <span class="variable constant_">EM</span>）：相对于根元素的字体大小的单位。默认情况下，根元素的字体大小等于浏览器的默认字体大小（16px）。如果根元素设置了字体大小为 16px，那么 1rem 相当于 16px。通过在根元素设置合适的字体大小，可以方便地进行整体的比例调整。</span><br><span class="line"><span class="number">4</span>、em（<span class="title class_">Emphasis</span>）：相对于父元素字体大小的单位。em 单位具有继承性，子元素的字体大小也会受到父元素字体大小的影响。</span><br><span class="line"></span><br><span class="line">主要区别如下：</span><br><span class="line">vw 和 vh 是相对于视口宽度和高度的单位，而 rem 和 em 是相对于字体大小的单位。</span><br><span class="line">vw 和 vh 单位可以直接根据屏幕尺寸进行调整，而 rem 和 em 单位则需要依赖于父元素的字体大小。</span><br><span class="line">rem 单位更适合用于整体的比例调整，而 em 单位更适合用于相对布局中的局部调整。</span><br></pre></td></tr></table></figure>
<h3 id="display：none和visibility-hidden区别"><a href="#display：none和visibility-hidden区别" class="headerlink" title="display：none和visibility: hidden区别"></a><code>display：none</code>和<code>visibility: hidden</code>区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">这两个属性都是让元素隐藏，不可见。两者的区别：</span><br><span class="line"><span class="number">1</span>、<span class="string">`display: none`</span>：让元素从文档流中移除，不占据任何空间；且是非继承属性，所有子元素都不可见，对页面的渲染性能影响较小。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="string">`visibility: hidden`</span>：元素仍占据空间，但内容不可见。只是将元素的可见性设置为隐藏，其他元素的布局不受影响。子元素也会被隐藏，但可以通过单独设置子元素的 <span class="attr">visibility</span>: visible 来让子元素显示，而父元素仍然保持隐藏状态。</span><br><span class="line"></span><br><span class="line">类似于v-<span class="keyword">if</span>和v-show</span><br><span class="line"></span><br><span class="line">渲染的时候，dom树和渲染树是一一对应的么</span><br><span class="line"><span class="variable constant_">DOM</span> 树和渲染树并不是一一对应的，<span class="variable constant_">DOM</span> 树是由浏览器解析 <span class="variable constant_">HTML</span> 文档而生成的，它表示了整个文档的结构和内容，包括<span class="variable constant_">HTML</span> 元素、文本节点和属性等。</span><br><span class="line">渲染树是在 <span class="variable constant_">DOM</span> 树和 <span class="variable constant_">CSSOM</span> 树结合之后生成的，用于表示页面上【需要渲染的元素及样式信息】。渲染树中的节点称为渲染对象(<span class="title class_">Render</span> <span class="title class_">Object</span>)，它们与 <span class="variable constant_">DOM</span> 树中的节点相对应，但不是一一对应的关系。</span><br><span class="line">在构建渲染树时，一些不需要显示的节点(如&lt;script&gt;、&lt;head&gt;、<span class="attr">display</span>:none 和一些不可见的元素)会被省略，而只有需要显示的元素才会被包含在渲染树中。</span><br></pre></td></tr></table></figure>
<h3 id="transform相较于margin的好处"><a href="#transform相较于margin的好处" class="headerlink" title="transform相较于margin的好处"></a><code>transform</code>相较于<code>margin</code>的好处</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、不影响文档流：使用 margin 属性实现元素的移动会影响到元素所在的文档流，可能会导致其他元素位置发生变化。而使用 transform 属性可将元素的位置进行调整，但不会影响到其他元素的布局和位置。</span><br><span class="line"><span class="number">2</span>、性能更好：使用 transform 属性来实现元素的移动、旋转等操作，浏览器不需要重新计算元素的布局和绘制，而是仅对元素进行单纯的变换。这样可以减少浏览器的重排（reflow）和重绘（repaint）操作，从而提高页面的渲染性能。</span><br><span class="line"><span class="number">3</span>、可以使用硬件加速：一些浏览器支持使用 <span class="variable constant_">GPU</span> 进行硬件加速来执行 transform 变换，这样可以进一步提高页面的渲染性能。</span><br></pre></td></tr></table></figure>
<h2 id="浏览器和网络"><a href="#浏览器和网络" class="headerlink" title="浏览器和网络"></a>浏览器和网络</h2><h3 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">XSS</span>（跨站脚本攻击）是一种常见的网络安全漏洞，攻击者通过在网页中注入恶意脚本代码，使得用户在浏览网页时执行该恶意脚本，从而达到攻击的目的。<span class="variable constant_">XSS</span> 攻击可以分为三种类型：</span><br><span class="line"><span class="number">1</span>、存储型 <span class="variable constant_">XSS</span>：将恶意脚本存储在服务端，当用户访问包含这些脚本的页面时，恶意脚本会被执行。</span><br><span class="line"><span class="number">2</span>、反射型 <span class="variable constant_">XSS</span>：将恶意脚本作为参数或路径的一部分发送给受害者，当受害者点击特定的链接时，恶意脚本会被执行。</span><br><span class="line"><span class="number">3</span>、<span class="variable constant_">DOM</span> 型 <span class="variable constant_">XSS</span>：攻击者通过修改页面的 <span class="variable constant_">DOM</span> 结构来执行恶意脚本，通常通过修改 <span class="variable constant_">URL</span> 参数、表单提交或者修改 <span class="variable constant_">JS</span> 脚本等方式实现。</span><br><span class="line"></span><br><span class="line">为了防止 <span class="variable constant_">XSS</span> 攻击，可以采取以下措施：</span><br><span class="line"><span class="number">1</span>、输入验证和过滤：对用户输入的数据进行验证和过滤，确保只接受合法的数据。可以使用白名单过滤器或转义特殊字符等方式来防止恶意脚本的注入。</span><br><span class="line"><span class="number">2</span>、输出编码：对输出到页面的数据进行编码，确保恶意脚本不能被执行。可以使用适当的编码函数，如 <span class="variable constant_">HTML</span> 编码、<span class="variable constant_">URL</span> 编码等。</span><br><span class="line"><span class="number">3</span>、设置 <span class="variable constant_">HTTP</span> 头部：通过设置 <span class="title class_">Content</span>-<span class="title class_">Security</span>-<span class="title class_">Policy</span>（<span class="variable constant_">CSP</span>）头部来限制页面中可以加载的资源和执行的脚本，减少攻击者的可操作空间。</span><br><span class="line"><span class="number">4</span>、使用安全的框架和库：使用经过安全验证的框架和库，这些框架和库通常提供了对 <span class="variable constant_">XSS</span> 攻击的防护机制。</span><br><span class="line"><span class="number">5</span>、定期更新和修补：保持软件系统和相关组件的更新，及时修补已知的漏洞。</span><br></pre></td></tr></table></figure>
<h3 id="csrf？localstorage存了token，怎么解决"><a href="#csrf？localstorage存了token，怎么解决" class="headerlink" title="csrf？localstorage存了token，怎么解决?"></a><code>csrf</code>？<code>localstorage</code>存了<code>token</code>，怎么解决?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">CSRF</span>（跨站请求伪造）是一种利用受信任用户的身份执行非意愿操作的攻击方式。</span><br><span class="line">在 <span class="variable constant_">CSRF</span> 攻击中，攻击者通过诱使受害者在登录状态下访问恶意网站或点击恶意链接，来执行受害者在其他网站上的非意愿操作，如修改密码、发表言论等。</span><br><span class="line"></span><br><span class="line">对于使用 <span class="variable language_">localStorage</span> 存储 token 的情况，可以采取以下措施来防止 <span class="variable constant_">CSRF</span> 攻击：</span><br><span class="line"><span class="number">1</span>、同源检测：在服务器端对请求进行同源检测，确保请求来自合法的源站点。可以通过检查请求头中的 <span class="title class_">Referer</span> 字段或 <span class="title class_">Origin</span> 字段来实现。</span><br><span class="line"><span class="number">2</span>、随机化 token：在生成 token 时使用随机数和时间戳等信息，使得每个 token 的值都是唯一的，并将 token 存储在 session 或 http-only 的 cookie 中，而不是 <span class="variable language_">localStorage</span> 中。</span><br><span class="line"><span class="number">3</span>、添加 <span class="variable constant_">CSRF</span> <span class="title class_">Token</span>：在每个需要进行敏感操作的请求中，添加一个 <span class="variable constant_">CSRF</span> <span class="title class_">Token</span> 参数。该参数的值由服务器生成，并在服务器端进行验证。攻击者无法获取到合法的 <span class="variable constant_">CSRF</span> <span class="title class_">Token</span> 值，从而无法成功执行 <span class="variable constant_">CSRF</span> 攻击。</span><br><span class="line"><span class="number">4</span>、设置 <span class="title class_">SameSite</span> 属性：对于支持 <span class="title class_">SameSite</span> 属性的浏览器，可以将 cookie 的 <span class="title class_">SameSite</span> 属性设置为 <span class="title class_">Strict</span> 或 <span class="title class_">Lax</span>，以限制跨站点的 cookie 发送，进一步减少 <span class="variable constant_">CSRF</span> 攻击的风险。</span><br><span class="line"><span class="number">5</span>、使用验证码：对于特别敏感的操作，如修改密码、删除账户等，可以要求用户输入验证码，增加安全性。</span><br></pre></td></tr></table></figure>
<h3 id="如何提高前端页面性能"><a href="#如何提高前端页面性能" class="headerlink" title="如何提高前端页面性能"></a>如何提高前端页面性能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 减少 <span class="variable constant_">HTTP</span> 请求：减少静态资源的请求次数，可通过使用 <span class="variable constant_">CSS</span> <span class="title class_">Sprites</span>、合并<span class="variable constant_">JS</span>和 <span class="variable constant_">CSS</span> 文件等手段实现。</span><br><span class="line"><span class="number">2.</span> 压缩文件大小：压缩 <span class="title class_">JavaScript</span>、<span class="variable constant_">CSS</span> 和图片等文件，可有效减小文件大小，加快下载速度。</span><br><span class="line"><span class="number">3.</span> 避免重复加载：避免重复加载相同的文件或资源，可以通过浏览器缓存、<span class="variable constant_">HTTP</span> 缓存和服务端缓存等手段来实现。</span><br><span class="line"><span class="number">4.</span> 异步加载资源：延迟加载非关键资源，可以通过懒加载和异步加载等手段来实现。</span><br><span class="line"><span class="number">5.</span> 减少 <span class="variable constant_">DOM</span> 操作：减少不必要的 <span class="variable constant_">DOM</span> 操作，可通过避免多次查询 <span class="variable constant_">DOM</span> 元素、使用文档片段、事件委托等手段来实现。</span><br><span class="line"><span class="number">6.</span> 优化 <span class="variable constant_">CSS</span> 选择器：避免使用过于复杂的 <span class="variable constant_">CSS</span> 选择器，可以通过简化选择器、使用 <span class="variable constant_">ID</span> 选择器、避免使用通配符等手段来实现。</span><br><span class="line"><span class="number">7.</span> 使用 <span class="title class_">Web</span> <span class="title class_">Workers</span> 和 <span class="title class_">Service</span> <span class="title class_">Workers</span>：使用 <span class="title class_">Web</span> <span class="title class_">Workers</span> 和 <span class="title class_">Service</span> <span class="title class_">Workers</span> 可以将一些耗时的计算和 I/O 操作转移到后台线程中，避免阻塞主线程，提高页面响应速度。</span><br><span class="line"><span class="number">8.</span> 移动端优化：移动端页面的性能优化可以通过图片压缩、使用 <span class="title class_">CSS3</span> 动画代替 <span class="variable constant_">JS</span> 动画、避免使用 fixed 定位等手段来实现。</span><br></pre></td></tr></table></figure>
<h2 id="Webpack与vite"><a href="#Webpack与vite" class="headerlink" title="Webpack与vite"></a>Webpack与vite</h2><p>了解webpack、vite 打包工具、依赖包管理器npm，了解基本配置</p>
<h3 id="webpack构建流程"><a href="#webpack构建流程" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><h3 id="instanceof方法"><a href="#instanceof方法" class="headerlink" title="instanceof方法"></a>instanceof方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left); <span class="comment">// 获取对象left原型</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 获取目标构造函数right原型</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(proto === <span class="literal">null</span>) &#123; <span class="comment">// 到达原型链顶端仍未找到目标原型，则返回 false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(proto === prototype) &#123; <span class="comment">// 找到目标原型，则返回 true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto); <span class="comment">// 继续查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(p, <span class="title class_">Person</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖：处理频繁触发的事件。函数被连续调用时，只执行最后一次调用。（输入框搜索、窗口调整、按钮点击）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);<span class="comment">//每一次时间清空，重新计时</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流：限制事件的触发频率，规定时间间隔只执行一次相应操作。（页面滚动、鼠标移动）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">            newObj[prop] = obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>项目总结</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/">http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>IZDLOYL</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-08-27</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-09-16</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A7%8B%E6%8B%9B/">秋招</a></div><div class="post_share"><div class="social-share" data-image="/gallery/wallpaper7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端八股</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/23/frontEnd-nodejs/" title="node"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">node</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">IZDLOYL</div><div class="author-info__description">🎬𝙏𝙪𝙧𝙣 𝙤𝙛𝙛 𝙬𝙤𝙧𝙧𝙮✨</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/IZDLOYL-G"><i class="fab fa-github"></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/IZDLOYL-G" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1215472755@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #dfc600;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1174008660" target="_blank" title="Weixin"><i class="fab fa-weixin" style="color: #48b700;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">welcome to my blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E4%BA%AB%E6%B1%87"><span class="toc-text">图享汇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C"><span class="toc-text">1、登录注册</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8slideCaptcha%E5%AE%8C%E6%88%90%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81"><span class="toc-text">使用slideCaptcha完成滑动验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E6%96%B9QQ%E3%80%81%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E3%80%82"><span class="toc-text">实现第三方QQ、微信扫码登录。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85"><span class="toc-text">2、axios二次封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85"><span class="toc-text">3、组件封装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%B5%81%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="toc-text">瀑布流组件：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%EF%BC%9A"><span class="toc-text">上拉加载：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%87%92%E5%8A%A0%E8%A3%81"><span class="toc-text">4、懒加裁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">图片懒加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">组件懒加载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E9%98%B2%E6%8A%96%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96"><span class="toc-text">5、防抖搜索优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">移动端适配 - 响应式布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE"><span class="toc-text">人力资源后台项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%9D%83%E9%99%90"><span class="toc-text">1、权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81vuex%E7%AE%A1%E7%90%86"><span class="toc-text">2、vuex管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="toc-text">3、excel导入导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%80%92%E5%BD%92%E5%88%97%E8%A1%A8%E8%BD%AC%E6%A0%91"><span class="toc-text">4、递归列表转树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">js数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-text">判断数据类型的方法及区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型和原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">闭包和内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C"><span class="toc-text">&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue"><span class="toc-text">vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6"><span class="toc-text">如何封装组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css%E6%9D%83%E9%87%8D"><span class="toc-text">css权重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">水平垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D"><span class="toc-text">定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vw%E3%80%81vh%E3%80%81rem%E3%80%81em%E5%8C%BA%E5%88%AB"><span class="toc-text">vw、vh、rem、em区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#display%EF%BC%9Anone%E5%92%8Cvisibility-hidden%E5%8C%BA%E5%88%AB"><span class="toc-text">display：none和visibility: hidden区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transform%E7%9B%B8%E8%BE%83%E4%BA%8Emargin%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">transform相较于margin的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C"><span class="toc-text">浏览器和网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xss%E6%94%BB%E5%87%BB"><span class="toc-text">xss攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csrf%EF%BC%9Flocalstorage%E5%AD%98%E4%BA%86token%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-text">csrf？localstorage存了token，怎么解决?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD"><span class="toc-text">如何提高前端页面性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack%E4%B8%8Evite"><span class="toc-text">Webpack与vite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">webpack构建流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node"><span class="toc-text">node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-text">HTML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-text">手写代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof%E6%96%B9%E6%B3%95"><span class="toc-text">instanceof方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-text">防抖节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E9%97%AE"><span class="toc-text">反问</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端八股"/></a><div class="content"><a class="title" href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股">前端八股</a><time datetime="2024-08-29T13:06:26.092Z" title="发表于 2024-08-29 21:06:26">2024-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/27/interview-%E6%80%BB%E7%BB%93/" title="项目总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目总结"/></a><div class="content"><a class="title" href="/2024/08/27/interview-%E6%80%BB%E7%BB%93/" title="项目总结">项目总结</a><time datetime="2024-08-27T12:58:34.417Z" title="发表于 2024-08-27 20:58:34">2024-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-nodejs/" title="node"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="node"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-nodejs/" title="node">node</a><time datetime="2024-08-23T08:14:35.116Z" title="发表于 2024-08-23 16:14:35">2024-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-JavaScript/" title="JS基本语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS基本语法"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-JavaScript/" title="JS基本语法">JS基本语法</a><time datetime="2024-08-23T08:06:33.574Z" title="发表于 2024-08-23 16:06:33">2024-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-TypeScript/" title="TypeScript"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-TypeScript/" title="TypeScript">TypeScript</a><time datetime="2024-08-23T08:06:10.608Z" title="发表于 2024-08-23 16:06:10">2024-08-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By IZDLOYL</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hope you have a nice day!🍭🍭🍭</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 IZDLOYLの前端笔记 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/项目/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 IZDLOYLの项目 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 IZDLOYLの算法笔记 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/面试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 IZDLOYLの面试总结 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://www.izdloyl.cn/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-JavaScript/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-JavaScript/" alt="">JS基本语法</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-JavaScript/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-TypeScript/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-TypeScript/" alt="">TypeScript</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-TypeScript/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/01/frontEnd-vue3/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" href="2024/08/01/frontEnd-vue3/" alt="">vue3</a><div class="blog-slider__text">vue3学习笔记</div><a class="blog-slider__button" href="2024/08/01/frontEnd-vue3/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-nodejs/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-nodejs/" alt="">node</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-nodejs/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/01/frontEnd-vue2/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper1.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" href="2024/08/01/frontEnd-vue2/" alt="">vue2</a><div class="blog-slider__text">vue2学习笔记</div><a class="blog-slider__button" href="2024/08/01/frontEnd-vue2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-数组/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-数组/" alt="">数组篇</a><div class="blog-slider__text">代码随想录 - 数组篇</div><a class="blog-slider__button" href="2024/08/02/algorithm-数组/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-hot100/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-hot100/" alt="">hot100</a><div class="blog-slider__text">LeetCode - hot100</div><a class="blog-slider__button" href="2024/08/02/algorithm-hot100/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-字符串/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-字符串/" alt="">字符串篇</a><div class="blog-slider__text">代码随想录 - 字符串篇</div><a class="blog-slider__button" href="2024/08/02/algorithm-字符串/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>
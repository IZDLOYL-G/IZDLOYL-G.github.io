<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>项目总结 | IZDLOYL's Blog</title><meta name="author" content="IZDLOYL"><meta name="copyright" content="IZDLOYL"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="12345678910你好，很高兴能有这次的面试机会，我叫朱晓霞，目前是杭州电子科技大学通信工程专业研三的学生，今天我应聘的岗位是前端开发工程师。在校期间，我系统学习了前端开发的相关知识，比较熟悉JS，且在Vue开发方面也积累了一定的实践经验。目前，主要参与过两个前端项目的开发。一个是人力资源后台管理系统，另一个是一个响应式设计的图片分享平台，通过这些项目实践，我掌握了组件化开发、状态管理以及前">
<meta property="og:type" content="article">
<meta property="og:title" content="项目总结">
<meta property="og:url" content="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="IZDLOYL&#39;s Blog">
<meta property="og:description" content="12345678910你好，很高兴能有这次的面试机会，我叫朱晓霞，目前是杭州电子科技大学通信工程专业研三的学生，今天我应聘的岗位是前端开发工程师。在校期间，我系统学习了前端开发的相关知识，比较熟悉JS，且在Vue开发方面也积累了一定的实践经验。目前，主要参与过两个前端项目的开发。一个是人力资源后台管理系统，另一个是一个响应式设计的图片分享平台，通过这些项目实践，我掌握了组件化开发、状态管理以及前">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.izdloyl.cn/gallery/wallpaper5.jpg">
<meta property="article:published_time" content="2024-08-27T12:58:34.417Z">
<meta property="article:modified_time" content="2024-11-01T08:49:04.605Z">
<meta property="article:author" content="IZDLOYL">
<meta property="article:tag" content="秋招">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.izdloyl.cn/gallery/wallpaper5.jpg"><link rel="shortcut icon" href="/gallery/favicon.jpg"><link rel="canonical" href="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '项目总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-01 16:49:04'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/gallery/wallpaper5.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="IZDLOYL's Blog"><span class="site-name">IZDLOYL's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">项目总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-27T12:58:34.417Z" title="发表于 2024-08-27 20:58:34">2024-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-01T08:49:04.605Z" title="更新于 2024-11-01 16:49:04">2024-11-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>102分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="项目总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">你好，很高兴能有这次的面试机会，我叫朱晓霞，目前是杭州电子科技大学</span><br><span class="line">通信工程专业研三的学生，今天我应聘的岗位是前端开发工程师。</span><br><span class="line">在校期间，我系统学习了前端开发的相关知识，</span><br><span class="line">比较熟悉JS，且在Vue开发方面也积累了一定的实践经验。</span><br><span class="line">目前，主要参与过两个前端项目的开发。</span><br><span class="line">一个是人力资源后台管理系统，另一个是一个响应式设计的图片分享平台，</span><br><span class="line">通过这些项目实践，我掌握了组件化开发、状态管理以及前后端接口联调等核心技能。</span><br><span class="line">同时呢，为了整理和分享自己的所学知识，我基于hexo 搭建了自己的个人博客网站，</span><br><span class="line">主要记录自己学习前端的心得体会和开发中的一些日常积累。</span><br><span class="line">以上是我的一些基本情况。</span><br></pre></td></tr></table></figure>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">项目介绍:</span><br><span class="line">1.背景，这是一个 xxx 项目(体检相关的)，主要有 xxx 功能，为 xxx 服务</span><br><span class="line">2.分 B℃两端，C 端分 App 小程序 公众号，三个使用角色(医生、患者、公司运维)</span><br><span class="line">3.举例(体检)说明功能流程</span><br><span class="line">4.作为项目前端负责人，统一负责这个系统的所有端的 FE 部分。参与最多的还是 B端，因为 B端足够复杂</span><br><span class="line">4.1 微前端，xx个子模块。一共有 xx 个页面、组件 -- 规模比较大</span><br><span class="line">4.2还有，一些 xx 功能也比较复杂</span><br><span class="line">结束 +引导</span><br><span class="line"></span><br><span class="line">项目遇到的难点，怎么解决的</span><br><span class="line">登录逻辑</span><br><span class="line">用户名密码登录 用户登陆成功后，怎么保存用户信息</span><br><span class="line">上拉加载怎么实现的</span><br><span class="line">怎么判断到底，需要加载下一页</span><br><span class="line">CSS两列布局</span><br><span class="line">垂直水平居中</span><br><span class="line">防抖</span><br></pre></td></tr></table></figure>
<h3 id="图享汇"><a href="#图享汇" class="headerlink" title="图享汇"></a>图享汇</h3><h4 id="介绍（难点、解决）"><a href="#介绍（难点、解决）" class="headerlink" title="介绍（难点、解决）"></a>介绍（难点、解决）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">图享汇是一个图片下载平台，用户可在该平台自由浏览、搜索、下载和分享网站上的图片。</span><br><span class="line">平台采用响应式设计，确保用户在<span class="variable constant_">PC</span>端和移动端都能获得流畅的使用体验。</span><br><span class="line">项目的主要技术栈是<span class="title class_">Vue3</span> + vite + <span class="title class_">Tailwind</span> <span class="variable constant_">CSS</span></span><br><span class="line"></span><br><span class="line">由于项目需要兼容<span class="variable constant_">PC</span>端和移动端，如何在不同设备上保持一致的用户体验，是一个主要挑战。</span><br><span class="line">当时知道了一个<span class="variable constant_">CSS</span>框架<span class="title class_">Tailwind</span> <span class="variable constant_">CSS</span>（遵循移动端md优先），（它提供了简便的响应式类）</span><br><span class="line">它只需在类名前加上响应式前缀（md），就可以支持在不同屏幕尺寸下使用不同的样式，非常简便。</span><br><span class="line">再通过flex + rem 移动端适配方案，设置屏幕基准值（屏宽/<span class="number">10</span>，最大基准值为<span class="number">40</span>），</span><br><span class="line">使布局文字大小可随屏幕大小进行缩放，适应不同的设备。</span><br><span class="line"></span><br><span class="line">然后，由于项目首页主要由大量图片构成，采取了瀑布流布局。封装了一个瀑布流的通用组件，</span><br><span class="line">并考虑了图片是否需要预加载的两种情况（服务端是否返回img高度）。</span><br><span class="line">但使用瀑布流布局时初次加载时间较长，容易导致页面卡顿和加载慢的问题。我使用了长列表优化，通过vueuse提供的useIntersectionObserver方法，监听列表是否滚动到底部，</span><br><span class="line">当滚动到列表底部时，再去加载数据。这样 减少了 <span class="variable constant_">DOM</span> 操作。</span><br><span class="line">并且，使用了图片懒加载技术，监听所有图片是否被可见，如果处于不可见状态，那么就不加载图片，如果图片处于可见状态，那么开始加载图片。提升了用户体验</span><br><span class="line"></span><br><span class="line">以上是我 项目的具体介绍。</span><br><span class="line">难点：瀑布流组件的封装</span><br></pre></td></tr></table></figure>
<h4 id="登录注册模块"><a href="#登录注册模块" class="headerlink" title="登录注册模块"></a>登录注册模块</h4><h5 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">在项目中，登录逻辑分为两部分：用户名密码登录 和 第三方登录（如 <span class="variable constant_">QQ</span> 和 <span class="title class_">WeChat</span>）</span><br><span class="line"><span class="number">1</span>、用户名密码登录</span><br><span class="line">用户输入：用户输入用户名和密码后，点击登录按钮。</span><br><span class="line">前端请求：通过 <span class="title class_">Axios</span> 发送 <span class="variable constant_">POST</span> 请求，将用户名和密码传递给服务器。</span><br><span class="line">后端验证：后端校验用户名和密码是否匹配，如果成功，则生成 <span class="variable constant_">JWT</span> <span class="title class_">Token</span> 或 <span class="title class_">Session</span> <span class="title class_">Token</span>。</span><br><span class="line">处理响应：登录成功时，前端会收到包含 <span class="title class_">Token</span> 的响应，将其保存在 <span class="variable language_">localStorage</span> 中，并将该 <span class="title class_">Token</span> 添加到后续请求的 <span class="title class_">Authorization</span> 头部：</span><br><span class="line">登录后的跳转：登录成功后，用户会被重定向到首页。如果 <span class="title class_">Token</span> 失效（如过期），会触发 退出登录逻辑，清空 <span class="title class_">Token</span>，并跳转到登录页。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、第三方登录（如 <span class="variable constant_">QQ</span>、<span class="title class_">WeChat</span> 登录）</span><br><span class="line">前端引导用户跳转第三方授权页面：用户点击 <span class="variable constant_">QQ</span>/<span class="title class_">WeChat</span> 登录按钮时，前端会跳转到相应的授权页面，传递应用的 <span class="title class_">Client</span> <span class="variable constant_">ID</span> 和 回调 <span class="variable constant_">URL</span>。</span><br><span class="line">第三方认证成功后回调：用户在第三方页面完成授权后，第三方会重定向回应用的回调 <span class="variable constant_">URL</span>，并携带 <span class="title class_">Authorization</span> <span class="title class_">Code</span>。</span><br><span class="line">获取用户 <span class="title class_">Token</span>：前端将获取到的 <span class="title class_">Authorization</span> <span class="title class_">Code</span> 发给后端，由后端请求第三方接口获取 <span class="title class_">Access</span> <span class="title class_">Token</span> 和用户信息。</span><br><span class="line">后端生成 <span class="title class_">Token</span>：后端将第三方用户信息与系统账户绑定，并生成本地的 <span class="variable constant_">JWT</span> <span class="title class_">Token</span>。</span><br><span class="line">处理登录状态：前端收到 <span class="title class_">Token</span> 后，存储在 <span class="variable language_">localStorage</span> 或 cookie 中，确保后续请求中携带 <span class="title class_">Token</span> 完成用户授权验证。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Token</span> 过期：使用 <span class="title class_">Axios</span> 拦截器检测 <span class="number">401</span> 状态码，触发退出登录逻辑：</span><br><span class="line">错误提示：如果用户名或密码错误，系统会给出提示（如“用户名或密码不正确”）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【用户名密码登录时 用户登陆成功后，怎么保存用户信息】</span><br><span class="line">登录成功后，服务器会返回一个 <span class="title class_">Token</span>，需要在前端保存这个 <span class="title class_">Token</span>，用于后续请求的身份验证。</span><br><span class="line">【存储方式：</span><br><span class="line"><span class="variable language_">localStorage</span>：数据持久存在，即使刷新页面或关闭浏览器后重新打开也会保留。</span><br><span class="line"><span class="variable language_">sessionStorage</span>：仅在当前标签页或窗口有效，关闭页面即失效。</span><br><span class="line">cookie（可选）：可以设置失效时间，支持与服务器端 <span class="title class_">Session</span> 管理结合，适合跨页面状态保持。</span><br><span class="line">存储用户基本信息</span><br><span class="line">除了 <span class="title class_">Token</span>，还会存储用户的基本信息（如用户名、角色、头像等），以便个性化展示。】</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>存储位置：使用 <span class="title class_">Vuex</span>/<span class="title class_">Pinia</span> 或 <span class="title class_">React</span> 的 <span class="title class_">Context</span> 存储在状态管理中，方便组件之间共享。</span><br><span class="line">也可以使用 <span class="variable language_">localStorage</span> 存储持久化信息。</span><br><span class="line"><span class="number">2.</span> 请求拦截器注入 <span class="title class_">Token</span></span><br><span class="line">为了在后续的 <span class="variable constant_">API</span> 请求中自动携带 <span class="title class_">Token</span>，使用 <span class="title class_">Axios</span> 请求拦截器将 <span class="title class_">Token</span> 注入请求头。</span><br><span class="line"><span class="number">3.</span> 登录状态的维护（页面刷新或重启时）：</span><br><span class="line">在应用初始化时（如 <span class="title class_">App</span>.<span class="property">vue</span> 的 created 生命周期内），从 <span class="variable language_">localStorage</span> 或 cookie 中读取 <span class="title class_">Token</span> 和用户信息，恢复登录状态。</span><br><span class="line"><span class="number">4.</span> <span class="title class_">Token</span> 过期处理：服务端返回 <span class="number">401</span> <span class="title class_">Unauthorized</span> 状态，触发退出逻辑。</span><br></pre></td></tr></table></figure>
<h5 id="滑动验证"><a href="#滑动验证" class="headerlink" title="滑动验证"></a>滑动验证</h5><p>原理：将用户拖动行为的时间、精度，滑动轨迹等信息到服务器，然后进行后台算法验证。</p>
<p>输入用户名密码 <code>-&gt;</code> 点击登录按钮 <code>-&gt;</code> 显示滑动验证码 <code>-&gt;</code> 用户拼图成功 <code>-&gt;</code> 登陆成功</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">区分人机行为</span><br><span class="line"></span><br><span class="line">采用gitee上开源的slideCaptcha第三方的包。首先在人类行为验证组件完成对应<span class="variable constant_">UI</span>样式，</span><br><span class="line">然后创建captcha实例，在组件挂载onMounted时初始化，指定滑动验证码的渲染位置，</span><br><span class="line">再处理成功、失败的回调函数，在用户成功完成拼图的回调中，通过调用 getCaptcha （异步）</span><br><span class="line">接口传递用户的行为数据给后端进行进一步的验证，进行人类行为判定。</span><br><span class="line">【<span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getCaptcha</span>(&#123; <span class="attr">behavior</span>: arr &#125;)】</span><br><span class="line">在用户拼图失败的回调中，显示“验证失败”提示信息。</span><br></pre></td></tr></table></figure>
<h5 id="第三方扫码登录"><a href="#第三方扫码登录" class="headerlink" title="第三方扫码登录"></a>第三方扫码登录</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">前提: app和网站都上线了--&gt; 追加扫码登录的功能，<span class="number">1.0</span> 没有扫码登录功能</span><br><span class="line">申请二维码: 网站已经做好 --&gt; 在<span class="variable constant_">QQ</span>、微信开放平台创建网站应用，需要和网站一一对应</span><br><span class="line">后台 会传输前端一个包含二维码的页面</span><br><span class="line">扫码：请求头信息，相关配置信息 --&gt; 传给后台校验</span><br><span class="line">校验之后：成功 --&gt; 后台会有一个成功地址</span><br><span class="line"></span><br><span class="line">微信：</span><br><span class="line"><span class="number">0.</span> 在微信开放平台创建应用：网站域名和回调地址，获得对应的appid与appkey。</span><br><span class="line"><span class="number">1.</span> 用户点击 微信登录 触发事件，通过 接口 获取微信登录前置数据（比如appid、appSecret）</span><br><span class="line"><span class="number">2.</span> 根据获取到的数据，拼接得到 open url 地址</span><br><span class="line"><span class="number">3.</span> 打开该地址<span class="variable language_">window</span>.<span class="property">open</span>，展示微信登录二维码，用户扫码确定登录</span><br><span class="line"><span class="number">4.</span> 从用户确认登录的回调窗口中解析 <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span> ，</span><br><span class="line">使用正则表达式得到用户的 code 数据</span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span> 返回当前 <span class="variable constant_">URL</span> 的查询字符串，<span class="variable constant_">URL</span> 中问号 ? 后面的部分，包括？</span><br><span class="line"><span class="number">5.</span> 根据 appId、appSecret、code 通过【接口】获取用户的 access_token、openid</span><br><span class="line"><span class="number">6.</span> 根据access_token、openid通过【接口】获取用户信息，并执行登录操作 <span class="title function_">oauthLogin</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">QQ</span>登录逻辑： 【扫码登录之后，进入的地址为 线上的回调地址 ，调试必须在线上进行】</span><br><span class="line"><span class="number">0.</span> 在qq开放平台创建应用：网站域名和回调地址，获得对应的appid与appkey。</span><br><span class="line"><span class="number">1.</span> 展示二维码：用户点击 <span class="variable constant_">QQ</span>登录 按钮触发事件，进入第三方登录页（<span class="variable language_">window</span>.<span class="property">open</span>）</span><br><span class="line">展示 <span class="variable constant_">QQ</span> 登录二维码</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 获取用户信息：</span><br><span class="line">在执行 <span class="variable constant_">QQ</span> 登录挂起操作<span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;<span class="variable constant_">QC</span>.<span class="title class_">Login</span>()&#125;)时,登录成功的回调中(data,opts)中</span><br><span class="line">由于 <span class="variable constant_">QQ</span> 登录存在缓存【登录成功一次之后，下次进入会自动重新登录】，</span><br><span class="line">为防止下次进入时自动重新登录，在离开登录页面时，注销登录<span class="variable constant_">QC</span>.<span class="property">Login</span>.<span class="title function_">signOut</span>()；</span><br><span class="line">在用户扫码登录成功的回调地址<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>中，使用正则表达式获取当前用户</span><br><span class="line">唯一标识access_token，以此作为判断用户是否已注册过的依据；</span><br><span class="line">将获得的用户信息（nickname、头像、access_token）进行跨页面传输。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 完成【跨页面数据传输】：<span class="title class_">BroadcastChannel</span> + <span class="variable language_">localStorage</span>  <span class="variable constant_">QQ</span>登录小窗口 -&gt; 主窗口</span><br><span class="line"><span class="title class_">BroadcastChannel</span> 允许不同浏览器多个标签页或窗口之间进行通信。如果 <span class="title class_">BroadcastChannel</span> 不可用，代码则回退使用 <span class="variable language_">localStorage</span> 作为替代方案，通过监听 storage 事件来实现类似效果</span><br><span class="line">broadcast.<span class="title function_">send</span>(oauthObj) -&gt; 关闭第三方窗口<span class="variable language_">window</span>.<span class="title function_">close</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 认证是否已注册</span><br><span class="line">- 用户通过第三方登录，调用 <span class="title class_">Vuex</span> 的 login 动作，向后台发送登录请求，并获取响应状态码。</span><br><span class="line">- 如果用户尚未注册（即返回特定状态码 <span class="variable constant_">LOGIN_TYPE_OAUTH_NO_REGISTER_CODE</span>），</span><br><span class="line">系统提示用户创建账号，并跳转到注册页面router.<span class="title function_">push</span>()。</span><br><span class="line">- 如果用户已注册，直接跳转到系统首页router.<span class="title function_">push</span>(<span class="string">&#x27;/&#x27;</span>)。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 完成 <span class="variable constant_">QQ</span> 对接：移动端 -&gt; 问题：用户授权登录成功后，没有直接进入首页或注册页</span><br><span class="line">在执行登录挂起操作里，进行挂页面传输之后，继续执行登录操作 <span class="title function_">oauthLogin</span>(<span class="variable constant_">LOGIN_TYPE_QQ</span>, oauthObj)</span><br></pre></td></tr></table></figure>
<p><code>OAuth</code> 的思路：<code>OAuth</code>是一个关于授权（<code>authorization</code>）的开放网络标准。应用通过引导用户在第三方平台的授权层进行登录授权，获得一个限制权限和有效时间的令牌（token），在令牌有效期内即可从第三方平台换取用户授权使用的信息。</p>
<p>客户端授权模式：授权码模式、简化模式、密码模式、客户端模式。</p>
<p><strong><em>授权码模式</em></strong> ：最完整、流程最严密。基于授权码模式的第三方登录流程如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 点击第三方登录按钮：执行 <span class="variable language_">window</span>.<span class="property">open</span> 方法，打开一个第三方指定的 <span class="variable constant_">URL</span> 窗口，该地址会指向第三方登录的 <span class="variable constant_">URL</span> ，并且由第三方提供一个对应的二维码</span><br><span class="line"><span class="number">2.</span> 弹出一个小窗口，展示对应二维码：此处展示的二维码，为上一步中第三方提供的二维码</span><br><span class="line"><span class="number">3.</span> 手机打开对应的 <span class="variable constant_">APP</span> 进行扫码之后，会跳转到【同意页面】，同时浏览器端也会显示扫码成功：在第三方中会一直对该页面进行【轮询】，配合第三方 <span class="variable constant_">APP</span> 来判断是否扫码成功</span><br><span class="line"><span class="number">4.</span> 手机端操作同意登录之后，会出现两种情况：在 <span class="variable constant_">APP</span> 中同意之后，第三方会进行对应的跳转，跳转地址为你指定的地址，在该地址中可以获取到【第三方的用户信息】，该信息即为第三方登录时要获取到的关键数据。</span><br><span class="line"><span class="number">5.</span> 至此，第三方操作完成。接下来需要进行本平台的登录判定。</span><br><span class="line">   <span class="number">1.</span> 该注册指的是【第三方用户】是否在本平台中进行了注册。</span><br><span class="line">   <span class="number">2.</span> 因为在之前的所有操作中，拿到的是【第三方的用户信息】</span><br><span class="line">   <span class="number">3.</span> 该信息可以帮助直接显示对用的用户名（nickname）和头像，但是因为不包含关键信息（手机号、用户名（username）、密码）所以无法使用该信息帮助用户直接登录</span><br><span class="line">   <span class="number">4.</span> 所以需要判断当前用户是否在咱们自己的平台中完成了注册</span><br><span class="line">      - <span class="number">1.</span>当前用户已注册：直接登录</span><br><span class="line">      - <span class="number">2.</span>当前用户未注册：执行注册功能</span><br></pre></td></tr></table></figure>
<h4 id="axios二次封装"><a href="#axios二次封装" class="headerlink" title="axios二次封装"></a><code>axios</code>二次封装</h4><blockquote>
<p>在请求拦截器中设置接口基础地址、超时时间、登录成功后请求头携带<code>token</code>，响应拦截器做异常处理。</p>
</blockquote>
<p><strong><em>axios 的使用</em></strong> ：请求方式：<code>axios.get()</code>、<code>axios.post()</code>、<code>axios(&#123;&#125;)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get 请求：</span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;url?参数1=值&amp;参数2=值&quot;</span>);<span class="comment">// 给后端传递的参数 ==&gt; 参数1=值&amp;参数2=值</span></span><br><span class="line"></span><br><span class="line">post 请求：</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;url&quot;</span>, &#123; 参数<span class="number">1</span>: 值, 参数<span class="number">2</span>: 值 &#125;);</span><br></pre></td></tr></table></figure>
<p><strong><em>axios 二次封装</em></strong> ：</p>
<blockquote>
<ol>
<li>提高代码复用性，减少代码量，减低维护难度。</li>
<li>统一处理一些常规的问题一劳永逸，如 http 错误。</li>
<li>拦截请求和响应，提前对数据进行处理，如获取 token，修改配置项。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、创建axios实例axios.<span class="title function_">create</span>(&#123;&#125;)，设置请求的基础地址baseURL和超出时间timeout</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、配置请求拦截器：在每个请求发送之前执行的逻辑，允许在请求头中添加额外的配置或信息</span><br><span class="line">如果用户已经登录且有 token（vuex store），就把这个 token 加入到请求头的 <span class="title class_">Authorization</span> 字段里，用于身份认证。</span><br><span class="line">成功则返回配置，继续发送请求。如果遇到错误，就通过 <span class="title class_">Promise</span>.<span class="property">reject</span> 返回错误。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、配置响应拦截器：在每次接收到服务器的响应后进行处理</span><br><span class="line">成功处理：如果 response.<span class="property">data</span> 中的 success 为真，返回数据 data。否则，通过 <span class="title class_">Promise</span>.<span class="property">reject</span> 抛出错误，并将错误信息封装进 <span class="title class_">Error</span> 对象。</span><br><span class="line">错误处理：</span><br><span class="line">如果响应中的错误码为 <span class="number">401</span>（表示 <span class="title class_">Token</span> 过期），则触发用户退出逻辑（store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/logout&#x27;</span>)）</span><br><span class="line">弹出错误提示信息（$message 显示服务器返回的错误信息）。</span><br><span class="line">返回错误信息给调用方，确保错误能够被捕获。</span><br></pre></td></tr></table></figure>
<h4 id="瀑布流和长列表"><a href="#瀑布流和长列表" class="headerlink" title="瀑布流和长列表"></a>瀑布流和长列表</h4><h5 id="瀑布流组件"><a href="#瀑布流组件" class="headerlink" title="瀑布流组件"></a>瀑布流组件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 核心：通过<span class="string">`relative`</span> 和<span class="string">`absolute`</span>定位的方式，来控制每个 <span class="string">`item`</span> 的位置</span><br><span class="line"><span class="number">2.</span> 需要分别处理服务端是否会返回 关键<span class="string">`img`</span>的高度 ：</span><br><span class="line">   - 当服务端【不返回】高度时：需要等待 <span class="string">`img`</span> 加载完成之后(预加载)，再来计算高度，然后通过得到的高度计算定位。否则会出现高度计算不准确导致定位计算不准确的问题。</span><br><span class="line">   - 当服务端【返回】高度时：开发者则必须利用此高度为 <span class="string">`item`</span> 进行高度设定。一旦 <span class="string">`item`</span>具备指定高度，那么就不需要等待 <span class="string">`img`</span>加载的过程，这样效率更高，并且可以业务的逻辑会变得更加简单。</span><br><span class="line"><span class="number">3.</span> 当进行响应式切换时，同样需要区分对应场景：</span><br><span class="line">   - 当服务端【不返回】高度时：需要 重新执行整个渲染流程 ，虽然会耗费一些性能，但可以最大可能的避免出现逻辑错误。让组件拥有更强的普适性。</span><br><span class="line">   - 当服务端【返回】高度时：同样需要重新计算 列宽 和 定位 ，但因为 <span class="string">`item`</span>具备明确的高度，所以可以直接拿到具体的高度，而无需重复整个渲染流程，从而可以实现更多的交互逻辑。比如：位移动画、将来的图片懒加载占位...</span><br><span class="line"></span><br><span class="line">瀑布流布局的核心实现思想：</span><br><span class="line"><span class="number">1.</span> 控制容器内每一列卡片的宽度相同（不同图片尺寸等比例缩放）</span><br><span class="line"><span class="number">2.</span> 第一行卡片紧挨着排列， 第二行开始采取贪心思想，每张卡片摆放到当前所有列中高度最小的一列下面 </span><br><span class="line">每个卡片<span class="string">`item`</span>必须使用<span class="string">`absolute`</span>绝对布局，并通过<span class="string">`top`</span>和<span class="string">`left`</span>来手动控制位置</span><br><span class="line">通过<span class="string">`props`</span>传递关键数据：数据源、唯一标识<span class="string">`key`</span>、列数、列间距、行间距、是否需要预加载</span><br><span class="line">计算容器宽度【<span class="string">`offsetWidth -`</span>左右边距】和列宽【（容器的宽度 - 所有的列间距宽度）/ 列数】</span><br><span class="line">想要计算每列的<span class="string">`left`</span>、<span class="string">`top`</span>，必须要拿到每个<span class="string">`item`</span>的高度，才可以判断下一列的第一个<span class="string">`item`</span>的位置。根据<span class="string">`pitturePreReading`</span>可以分为两种情况：① 需要图片预加载时：图片高度未知 ② 不需要图片预加载时：图片高度已知</span><br><span class="line">计算下一个<span class="string">`item`</span>位置：<span class="string">`left =`</span>最小高度所在的列 \* (列宽 + 间距) <span class="string">`top =`</span>最小高度所在列高+列间距</span><br><span class="line">适配移动端：自定义列数变化<span class="string">`:column = &quot;isMobileTerminal ? 2 : 5&quot;`</span>，在**列宽发生变化**时，重新执行计算列宽</span><br><span class="line"></span><br><span class="line">难点：当设置<span class="string">`:picturePreReading=&quot;false&quot;`</span>，不进行图片预加载时，在切换 <span class="variable constant_">PC</span> 端和移动端时会出现图片重叠现象（图片高度计算出现错误）。出现原因：不进行图片预加载时，会直接获取当前<span class="string">`item`</span>的高度，因为没有等待图片加载完成，此时的高度是不包含图片的高度，从而使整个<span class="string">`item`</span>高度计算错误。</span><br><span class="line"></span><br><span class="line">根据服务端返回的图片接口数据使用作用域插槽返回图片宽度，进而计算等比例缩放后的图片高度【计算后的图片高度 = （计算得到宽度/图片真实宽度）\* 图片真实高度】。重新监听列数变换，增加图片不进行预加载的情况</span><br></pre></td></tr></table></figure>
<h5 id="长列表"><a href="#长列表" class="headerlink" title="长列表"></a>长列表</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">分页展示数据的功能   核心需求：监听列表滚动到底部</span><br><span class="line"></span><br><span class="line">监听到列表滚动到底部，可利用 <span class="title class_">IntersectionObserver</span> ，该接口可以判断： 目标元素与其祖先元素或顶级文档视窗( viewport )的交叉状态（是否可见）。</span><br><span class="line"></span><br><span class="line">因为需要监测到列表是否滚动到底部，再去加载数据，可以把一个元素（包裹加载更多的图标和<span class="string">&quot;没有数据了&quot;</span>的div）置于列表底部，利用 vueuse 提供的 useIntersectionObserver方法，监听元素可见行为，用于判断列表滚动到底部。对于组件传入参数，设置了两个参数：一个用于控制是否处于加载状态modelValue，一个标记是否所有数据已经加载完毕isFinished。当被监听的元素进入了视口、当前也不在加载状态，且数据也为加载完毕的时候，触发加载逻辑【显示 加载更多 的图标（loading.<span class="property">value</span> = <span class="literal">true</span>），并通知父组件加载更多数据（触发 onLoad 事件：<span class="title function_">emits</span>(<span class="string">&#x27;onLoad&#x27;</span>) ）。】</span><br><span class="line"><span class="title function_">useIntersectionObserver</span>(laodingTarget, <span class="function">(<span class="params">[&#123; isIntersecting &#125;]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当加载更多的视图可见时， loading 为 false， 数据尚未全部加载完</span></span><br><span class="line">  <span class="keyword">if</span>(isIntersecting &amp;&amp; !loading.<span class="property">value</span> &amp;&amp; !props.<span class="property">isFinished</span>)&#123;</span><br><span class="line">     loading.<span class="property">value</span> = <span class="literal">true</span> <span class="comment">// 修改加载数据标记</span></span><br><span class="line">     <span class="title function_">emits</span>(<span class="string">&#x27;onLoad&#x27;</span>) <span class="comment">// 触发加载更多行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">【当更改数据请求 size，首次数据请求加载无法铺满全屏时，且鼠标滚动也无法触发下一页请求】</span><br><span class="line">当首次加载数据无法铺满全屏的时候，虽然检测是否可见的变量可见的 ，但它只会被触发一次，也就是 useIntersectionObserver 里的回调只会触发一次，不会再一次触发对应的 loading ，从而出现上述问题。</span><br><span class="line">判断 isIntersecting 方法在 loading 发生变化后重新进行一次判断，通过 watch 监听loading：<span class="title function_">watch</span>(loading, <span class="title function_">emitLoad</span>()&#125;)。确保页面首屏或新加载的数据能再次触发滚动检测，避免未铺满页面的情况。还可以使用 <span class="built_in">setTimeout</span> 做短暂延迟防抖处理，避免重复触发。</span><br><span class="line"></span><br><span class="line">优点：该组件实现了自动加载更多数据的功能，避免一次性渲染大量数据造成的性能问题</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span> /&gt;</span><span class="comment">&lt;!-- 内容 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;laodingTarget&quot;</span> <span class="attr">class</span>=<span class="string">&quot;h-6 py-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- 加载更多 --&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">m-svg-icon</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">v-show</span>=<span class="string">&quot;loading&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">class</span>=<span class="string">&quot;w-4 h-4 mx-auto animate-spin&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">name</span>=<span class="string">&quot;infinite-load&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span><span class="tag">&lt;/<span class="name">m-svg-icon</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- 没有更多数据了 --&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;isFinished&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-center text-base text-zinc-400&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        已经没有更多数据了!</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useVModel, useIntersectionObserver &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;...&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&#x27;onLoad&#x27;</span>, <span class="string">&#x27;update:modelValue&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> loading = <span class="title function_">useVModel</span>(props) <span class="comment">// 处理 loading 状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> laodingTarget = <span class="title function_">ref</span>(<span class="literal">null</span>) <span class="comment">// 滚动的元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> targetIsIntersecting = <span class="title function_">ref</span>(<span class="literal">false</span>) <span class="comment">// 记录当前是否在底部（是否交叉）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">useIntersectionObserver</span>(laodingTarget, <span class="function">(<span class="params">[&#123; isIntersecting &#125;]</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    targetIsIntersecting.<span class="property">value</span> = isIntersecting <span class="comment">// 获取当前交叉状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">emitLoad</span>() <span class="comment">// 触发 load</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 触发 load</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> <span class="title function_">emitLoad</span> = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 当加载更多的视图可见时，加载更多数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">if</span> (targetIsIntersecting.<span class="property">value</span> &amp;&amp; !loading.<span class="property">value</span> &amp;&amp; !props.<span class="property">isFinished</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    loading.<span class="property">value</span> = <span class="literal">true</span> <span class="comment">// 修改加载数据标记</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">emits</span>(<span class="string">&#x27;onLoad&#x27;</span>) <span class="comment">// 触发加载更多行为</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 监听 loading 的变化，解决数据加载完成后，首屏未铺满的问题</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">watch</span>(loading, <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">emitLoad</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;, <span class="number">100</span>)<span class="comment">// 触发 load，延迟处理，等待 渲染和 useIntersectionObserver 的再次触发</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="懒加裁"><a href="#懒加裁" class="headerlink" title="懒加裁"></a>懒加裁</h4><blockquote>
<p>分别实现图片和组件的懒加裁，确保首屏加载速度。</p>
</blockquote>
<h5 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">监听图片是否可见，在图片可见时，再去加载图片。</span><br><span class="line"></span><br><span class="line">vueuse提供的useIntersectionObserver方法：监听<span class="variable constant_">DOM</span>元素是否进入视口</span><br><span class="line"><span class="keyword">const</span> &#123;stop&#125; = <span class="title function_">useIntersectionObserver</span>(target, fn, options)</span><br><span class="line"><span class="number">0.</span> stop 是useIntersectionObserver方法</span><br><span class="line"><span class="number">1.</span> 参数 <span class="number">1</span> target表示被监听的<span class="variable constant_">DOM</span>元素</span><br><span class="line"><span class="number">2.</span> 参数 <span class="number">2</span> fn是回调函数，用于通知监听的动作（回调函数的第一个形参isIntersecting表示被监听的元素已经进入了可视区）</span><br><span class="line"><span class="number">3.</span> 参数 <span class="number">3</span> options表示配置选项</span><br><span class="line"></span><br><span class="line">具体步骤：</span><br><span class="line"><span class="number">1</span>、在元素挂载到页面中的钩子函数中 <span class="title function_">mounted</span>(<span class="params">el</span>)&#123;&#125;，保存img的src：<span class="keyword">const</span> imgSrc = el.<span class="property">src</span>，</span><br><span class="line"><span class="number">2</span>、将img的src属性置为 空 或者置位默认图片（el.<span class="property">src</span> = <span class="string">&quot;&quot;</span>）</span><br><span class="line"><span class="number">3</span>、使用vueuse提供的useIntersectionObserver方法监听图片是否在可视范围内，如果在，</span><br><span class="line">则将img的src属性设置为原始图片的<span class="variable constant_">URL</span>（el.<span class="property">src</span> = imgSrc），并停止监听<span class="title function_">stop</span>()</span><br></pre></td></tr></table></figure>
<h5 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">defineAsyncComponent 方法：创建一个按需加载的异步组件</span><br><span class="line">接收一个返回<span class="title class_">Promise</span>的加载函数。这个<span class="title class_">Promise</span>的 resolve 回调方法应该在从服务器获得组件定义时调用。也可以调用 <span class="title function_">reject</span>(reason) 表明加载失败。</span><br><span class="line"></span><br><span class="line">【通用组件 -&gt; 自动化注册】：</span><br><span class="line">通过<span class="title function_">install</span>()将组件注册到<span class="title class_">Vue</span>应用上，使得可以用app.<span class="title function_">use</span>()在全局范围内注册组件</span><br><span class="line"></span><br><span class="line">在方法内获取所有文件夹中以index.<span class="property">vue</span>结尾的文件<span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(vite提供的特性)</span><br><span class="line"><span class="keyword">const</span> components = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&quot;./*/index.vue&quot;</span>)</span><br><span class="line"></span><br><span class="line">遍历获取到的组件模块：<span class="keyword">for</span> (<span class="keyword">const</span> [path, fn] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(components)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">利用path生成组件名称：</span><br><span class="line"><span class="keyword">const</span> componentName = <span class="string">&quot;m-&quot;</span> + path.<span class="title function_">replace</span>(<span class="string">&quot;./&quot;</span>, <span class="string">&quot;&quot;</span>).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">利用 app.<span class="title function_">component</span>() 将生成的组件名称和对应的异步组件注册到 <span class="title class_">Vue</span> 应用上。使用 <span class="title function_">defineAsyncComponent</span>() 包装每个组件，使组件在第一次被使用时才加载，实现组件的懒加载</span><br><span class="line">app.<span class="title function_">component</span>(componentName, <span class="title function_">defineAsyncComponent</span>(fn))</span><br></pre></td></tr></table></figure>
<h4 id="防抖搜索优化"><a href="#防抖搜索优化" class="headerlink" title="防抖搜索优化"></a>防抖搜索优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">首页输入框搜索 防抖  -  合并多次快速触发的事件，减少不必要的网络请求。</span><br><span class="line"></span><br><span class="line">核心思想：当触发一个事件时，不去立刻执行，而是延迟一段时间，使该事件变为等待执行事件。如果在这段时间之内，该事件被再次触发，则上次等待执行的事件取消，本次触发的事件变为等待执行事件。循环往复，直到某一个等待事件被执行为止</span><br><span class="line"></span><br><span class="line">搜索提示 是通过 watch 监听输入内容的变化，所以当输入内容发生变化时，就会立刻触发 获取搜索提示数据 事件（getHintData）。此时需要做防抖处理，</span><br><span class="line">文本搜索防抖：</span><br><span class="line">使用 vueuse 中提供的 watchDebounced方法 ，监听输入内容props.<span class="property">searchText</span>的变化，</span><br><span class="line">当输入内容发生变化时，立刻触发 获取搜索提示数据 事件（getHintData）</span><br><span class="line"></span><br><span class="line">设置immediate：<span class="literal">true</span>表示立即执行回调</span><br><span class="line"><span class="attr">debounce</span>: <span class="number">500</span> 启用防抖机制，表示在 输入 改变后延迟 <span class="number">500</span> 毫秒才执行回调</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听搜索文本的变化，并获取对应提示数据</span></span><br><span class="line"><span class="title function_">watchDebounced</span>(<span class="function">() =&gt;</span> props.<span class="property">searchText</span>, getHintData, &#123;</span><br><span class="line">  <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">debounce</span>: <span class="number">500</span> <span class="comment">// 每次事件触发时，延迟的时间</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="移动端适配-响应式布局"><a href="#移动端适配-响应式布局" class="headerlink" title="移动端适配 - 响应式布局"></a>移动端适配 - 响应式布局</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>百分比布局：通过百分比单位使浏览器中的组件的宽和高随着浏览器的变化而变化</span><br><span class="line">   - height、width属性的百分比依托于父标签的宽高。但是padding、border、margin等属性的情况又不一样</span><br><span class="line">   - <span class="number">1</span>、子元素的 top 和 bottom 如果设置百分比，则相对于直接非 <span class="keyword">static</span> 定位（默认定位）的父元素的高度，同样，子元素的 left 和 right 如果设置百分比，则相对于直接非 <span class="keyword">static</span> 定位（默认定位的）父元素的宽度。</span><br><span class="line">     <span class="number">2</span>、子元素的 padding 和 margin 如果设置百分比，不论是垂直方向或者是水平方向都相对于直接父亲元素的 width ，而与父元素的 height 无关。</span><br><span class="line">   - border-radius 为百分比，则是相对于自身的宽度</span><br><span class="line">   - 缺点：计算困难，如果要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 媒体查询布局：通过 @media 媒体查询，给不同屏幕的大小编写不同的样式来实现。</span><br><span class="line">   - 缺点：如果浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> rem 布局： rem 是 <span class="title class_">CSS3</span> 新增的一个相对单位，1rem = 16px</span><br><span class="line">   - rem 是相对于 html 根元素的字体大小的单位。</span><br><span class="line">   - 通过修改html中 font-size 的字体大小来控制 rem 的大小。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> vw、vh 响应式布局：vw 和 vh 分别相对的是视图窗口的宽度和高度。</span><br><span class="line">   - 100vw = <span class="number">100</span>% 视图窗口宽度 ，100vh = <span class="number">100</span>% 视图窗口高度</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> flex 弹性布局：只需要依赖于 <span class="variable constant_">CSS</span> 样式的实现响应式布局的方式</span><br><span class="line">   <span class="number">1.</span> 父元素：常用的弹性布局的属性</span><br><span class="line">      - flex-direction ：水平方向对齐方式（wrap\wrap-reverse\colume\colume）</span><br><span class="line">      - flex-wrap ：是否换行</span><br><span class="line">      - justify-content ： 水平方向对齐方式</span><br><span class="line">      - align-items ：控制子元素在垂直方向上的对齐方式</span><br><span class="line">      - align-content ：垂直方向的对齐方式</span><br><span class="line">   <span class="number">2.</span> 子元素：常用的弹性布局的属性</span><br><span class="line">      - order ：排序，给元素指定不同数值，数值越大越靠后</span><br><span class="line">      - flex-grow ： 对容器剩余空间，按指定比例放大元素填充容器</span><br><span class="line">      - flex-shrink ：对超出容器空间按数值比例收缩填充</span><br><span class="line">      - flex-basis ：指定元素在主轴（水平）方向上的初始大小</span><br><span class="line">      - align-self ：控制单个元素在交叉轴（垂直）上的对齐</span><br></pre></td></tr></table></figure>
<p>项目中使用的是<strong><code>flex + rem</code></strong>响应式布局的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次加载成功时设置html跟标签的fontSize属性值；最大基准值为40px</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useREM</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">MAX_FONT_SIZE</span> = <span class="number">40</span>; <span class="comment">// 最大基准值</span></span><br><span class="line">  <span class="comment">// 当文档被解析成功时调用</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;html&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置屏幕基准值的标准为 屏幕的宽度 / 10</span></span><br><span class="line">    <span class="keyword">const</span> fontSize = <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="number">10</span>;</span><br><span class="line">    html.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="title class_">Math</span>.<span class="title function_">min</span>(fontSize, <span class="variable constant_">MAX_FONT_SIZE</span>) + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="人力资源后台项目"><a href="#人力资源后台项目" class="headerlink" title="人力资源后台项目"></a>人力资源后台项目</h3><h4 id="介绍（难点解决）"><a href="#介绍（难点解决）" class="headerlink" title="介绍（难点解决）"></a>介绍（难点解决）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是一个企业人力资源管理后台系统，涵盖组织管理、角色管理、员工管理和权限管理等核心模块，旨在帮助企业实现高效的员工管理和角色权限分配。</span><br><span class="line">核心技术：<span class="title class_">Vue</span>、<span class="title class_">Axios</span>、<span class="title class_">ElementUI</span>、<span class="title class_">Vue</span>-<span class="title class_">Router</span>、<span class="title class_">Vuex</span>、<span class="title class_">ECharts</span></span><br><span class="line"><span class="number">1</span>、在系统中，不同用户角色（如管理员、<span class="variable constant_">HR</span>、普通员工）需要访问不同的页面和功能。使用 <span class="variable constant_">RBAC</span> 进行权限管理时，需要根据用户登录后的角色动态加载对应的路由。</span><br><span class="line">使用 vue-router 动态添加路由，在用户登录后根据角色权限生成菜单。</span><br><span class="line">登录时，后端返回用户的角色和权限数据，并根据这些权限调用 <span class="title class_">Vue</span>-<span class="title class_">Router</span> 的 <span class="title function_">addRoute</span>() 方法动态加载路由。</span><br><span class="line"><span class="number">2</span>、后端返回的组织架构数据是列表形式的，需要转换为树形结构，以便在前端的树形组件中展示。</span><br><span class="line">使用 递归算法 将列表数据转换为树形结构，并在 <span class="title class_">ElementUI</span> 的 el-tree 组件中进行展示。</span><br><span class="line"><span class="number">3</span>、在处理大量员工数据时，需要实现 <span class="title class_">Excel</span> 文件的导入导出，并确保数据格式正确、性能高效。</span><br><span class="line">使用 <span class="title class_">FileSaver</span>.<span class="property">js</span> 进行文件导出，将员工数据导出为 <span class="title class_">Excel</span> 文件。</span><br><span class="line">同时使用 xlsx 库解析 <span class="title class_">Excel</span> 文件，实现数据的导入和验证。</span><br></pre></td></tr></table></figure>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><blockquote>
<p>使用<code>vue-router</code>配置路由切换视图，在权限模块中基于<code>RBAC</code>权限模型实现动态添加路由规则，完成不同角色的权限分配。（员工 - 角色 - 权限）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RBAC权限控制和Token认证的使用，流程大致如下:</span><br><span class="line">1.用户登录时，客户端向服务端发送登录请求，服务端验证用户名密码是否正确，如果正确则返回一个Token值给客户端。</span><br><span class="line">2.客户端在后续的请求中，在Header中携带这个Token值，服务端根据Token值来识别用户身份。</span><br><span class="line">3.服务端根据用户的身份和角色信息，对请求的API接口或页面元素进行权限判断，如果有权限则返回数据，否则返回403或401等错误码。</span><br></pre></td></tr></table></figure>
<p>权限管理就是让不同的用户只能访问自己权限内的资源，有以下几种</p>
<ul>
<li>路由权限，用户登录后只能看到自己权限内的导航菜单，且只能访问自己权限内的路由地址</li>
<li>视图权限，用户只能看到自己权限内的内容和按钮</li>
<li>请求权限，越权请求将其拦截</li>
</ul>
<p><strong>权限管理</strong>：接口权限、按钮权限、菜单权限、路由权限</p>
<ul>
<li><strong>接口权限</strong></li>
</ul>
<p>用户登录成功拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，请求头要携带<code>token</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.<span class="property">headers</span>[<span class="string">&#x27;token&#x27;</span>] = cookie.<span class="title function_">get</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;,&#123;response&#125;=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">203</span>) &#123; <span class="comment">//token过期或者错误</span></span><br><span class="line">    router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>路由权限</strong></li>
</ul>
<p><strong>方法 1</strong>：在路由初始化的时候挂载全部路由，在路由上标记相应的权限信息，当路由跳转的时候做校验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/home&quot;</span>),</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;homePage&quot;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;主页&quot;</span>,</span><br><span class="line">      <span class="attr">roles</span>: [<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;editor&quot;</span>], <span class="comment">//权限</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>会加载所有的路由，当路由很多的时候，对性能会有影响；</li>
<li>每次路由跳转都要做权限判断；</li>
<li>菜单信息写在前端，需要修改标题的时候，需要重新编译；</li>
<li>菜单跟路由耦合在一起，路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<p><strong>方法 2：项目</strong>：初始化的时候先挂载静态（不需要权限控制的）路由，比如登录页，404 页。如果用户通过 URL 进行强制访问，会直接进入 404。登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用<code>addRoutes</code>添加路由（⭐）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022028328.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拆分静态路由和动态路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态路由：没有权限的页面，所有角色都可以进入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> constantRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>, <span class="comment">// 登录页</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/login/index&quot;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/404&quot;</span>, <span class="comment">// 404页</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/404&quot;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="comment">// 首页</span></span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&quot;/dashboard&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;dashboard&quot;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Dashboard&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/dashboard/index&quot;</span>),</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;首页&quot;</span>, <span class="attr">icon</span>: <span class="string">&quot;dashboard&quot;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// &#123; path: &#x27;*&#x27;, redirect: &#x27;/404&#x27;, hidden: true &#125;// 404 页必须放在末尾 !!!</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// 动态路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> asyncRoutes = [</span><br><span class="line">  departmentRouter,</span><br><span class="line">  roleRouter,</span><br><span class="line">  employeeRouter,</span><br><span class="line">  permissionRouter,</span><br><span class="line">  attendanceRouter,</span><br><span class="line">  approvalRouter,</span><br><span class="line">  salaryRouter,</span><br><span class="line">  socialRouter,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createRouter</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">    <span class="comment">// mode: &#x27;history&#x27;, // 需要服务支持</span></span><br><span class="line">    <span class="attr">scrollBehavior</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</span><br><span class="line">    <span class="attr">routes</span>: constantRoutes, <span class="comment">// 默认引入静态路由</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resetRouter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newRouter = <span class="title function_">createRouter</span>();</span><br><span class="line">  router.<span class="property">matcher</span> = newRouter.<span class="property">matcher</span>; <span class="comment">// 重置路由</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>
<p>使用<code>addRoutes</code>动态挂载路由：应用初始化的时候先挂载不需要权限控制的路由，比如登录页，404 页。登录成功后，获取用户资料的权限信息（vuex），然后筛选有权限访问的路由(asyncRoutes.filter)，再在全局路由守卫里调用 addRoutes 添加路由。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022028370.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;@/router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> nprogress <span class="keyword">from</span> <span class="string">&quot;nprogress&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;nprogress/nprogress.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;@/store&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; asyncRoutes &#125; <span class="keyword">from</span> <span class="string">&quot;@/router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置守卫</span></span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/404&quot;</span>]; <span class="comment">// 白名单：不需要token也能访问</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  nprogress.<span class="title function_">start</span>(); <span class="comment">// 开启进度条nprogress</span></span><br><span class="line">  <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">token</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在token</span></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&quot;/login&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 跳转到主页</span></span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">// 主页</span></span><br><span class="line">      nprogress.<span class="title function_">done</span>(); <span class="comment">//next（地址）并没有执行后置守卫，需手动关闭进度条</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//////// 重点代码 ////////////////////////////////////////////////////</span></span><br><span class="line">      <span class="keyword">if</span> (!store.<span class="property">getters</span>.<span class="property">userId</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否获取过用户资料</span></span><br><span class="line">        <span class="keyword">const</span> &#123; roles &#125; = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&quot;user/getUserInfo&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> filterRoutes = asyncRoutes.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> roles.<span class="property">menus</span>.<span class="title function_">includes</span>(item.<span class="property">name</span>);</span><br><span class="line">        &#125;); <span class="comment">// 筛选后的路由，filter返回一个布尔值</span></span><br><span class="line">        store.<span class="title function_">commit</span>(<span class="string">&quot;user/setRoutes&quot;</span>, filterRoutes); <span class="comment">//将筛选后的路由添加到vuex</span></span><br><span class="line">        router.<span class="title function_">addRoutes</span>([</span><br><span class="line">          ...filterRoutes,</span><br><span class="line">          &#123; <span class="attr">path</span>: <span class="string">&quot;*&quot;</span>, <span class="attr">redirect</span>: <span class="string">&quot;/404&quot;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        ]); <span class="comment">// 添加动态路由信息到路由表</span></span><br><span class="line">        <span class="title function_">next</span>(to.<span class="property">path</span>); <span class="comment">// router添加动态路由之后,需要转发一下,目的是让路由拥有信息(router的已知缺陷)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">next</span>(); <span class="comment">// 放过</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/////// 重点代码 ///////////////////////////////////////////////////////</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有token</span></span><br><span class="line">    <span class="keyword">if</span> (whiteList.<span class="title function_">includes</span>(to.<span class="property">path</span>)) &#123;</span><br><span class="line">      <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&quot;/login&quot;</span>); <span class="comment">// 中转到登录页</span></span><br><span class="line">      nprogress.<span class="title function_">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置守卫</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  nprogress.<span class="title function_">done</span>(); <span class="comment">// 关闭进度条</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p>
<p><em>缺点</em> ：① 全局路由守卫里，每次路由跳转都要做判断 ② 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译 ③ 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</p>
<ul>
<li><strong>菜单权限</strong></li>
</ul>
<p>用户登录之后服务端返回一个数据，这个数据有菜单列表和<code>token</code>，我们把这个数据放入到<code>vuex</code>中，然后主页根据<code>vuex</code>中的数据进行菜单列表的渲染（⭐）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">在vuex用户模块添加路由信息state，筛选路由后提交mutation更新state，渲染左侧菜单</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; constantRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">token</span>: <span class="title function_">getToken</span>(), <span class="comment">// 从缓存中读取初始值</span></span><br><span class="line">  <span class="attr">userInfo</span>: &#123;&#125;, <span class="comment">// 存储用户基本资料状态</span></span><br><span class="line">  <span class="attr">routes</span>: constantRoutes <span class="comment">// 静态路由的数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="title function_">setRoutes</span>(<span class="params">state, newRoutes</span>) &#123;</span><br><span class="line">    state.<span class="property">routes</span> = [...constantRoutes, ...newRoutes] <span class="comment">// 静态路由 + 动态路由</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;user/setRoutes&#x27;</span>, filterRoutes)<span class="comment">//将筛选后的路由添加到vuex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染左侧菜单</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  .......</span><br><span class="line">  <span class="attr">routes</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">user</span>.<span class="property">routes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getters</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">SidebarItem</span>, <span class="title class_">Logo</span> &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapGetters</span>([</span><br><span class="line">      <span class="string">&#x27;sidebar&#x27;</span>, <span class="string">&#x27;routes&#x27;</span></span><br><span class="line">    ]),</span><br><span class="line">    <span class="comment">// 路由信息的计算属性</span></span><br><span class="line">    <span class="comment">// routes() &#123;</span></span><br><span class="line">    <span class="comment">//   // 返回所有的路由信息</span></span><br><span class="line">    <span class="comment">//   return this.$router.options.routes</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案 1：菜单与路由分离，菜单由后端返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">name字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;login&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/pages/Login.vue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是对应的，后端返回的菜单就已经是经过权限过滤的。若根据路由name找不到对应的菜单，就表示用户有没权限访问。</span><br><span class="line"></span><br><span class="line">如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载（路由权限方法<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line">这种方式的缺点：</span><br><span class="line">菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</span><br><span class="line">全局路由守卫里，每次路由跳转都要做判断</span><br></pre></td></tr></table></figure>
<p>方案 2：菜单和路由都由后端返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端统一定义路由组件：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../pages/Home.vue&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserInfo</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../pages/UserInfo.vue&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">home</span>: <span class="title class_">Home</span>,</span><br><span class="line">    <span class="attr">userInfo</span>: <span class="title class_">UserInfo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后端路由组件返回以下格式：</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">&quot;home&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/userinfo&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">&quot;userInfo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件</span><br><span class="line">如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理</span><br><span class="line"></span><br><span class="line">这种方法也会存在缺点：全局路由守卫里，每次路由跳转都要做判断；前后端的配合要求更高</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>按钮权限</strong></li>
</ul>
<p>方案 1：用<code>v-if</code>判断。但如果页面过多，每个页面页面都要获取用户权限<code>role</code>和路由表里的<code>meta.btnPermissions</code>，然后再做判断。</p>
<p>方案 2：通过自定义指令进行按钮权限的判断（⭐）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装自定义指令 用来控制操作权</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;permission&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 会在指令作用的元素插入到页面完成以后触发</span></span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(el) <span class="comment">// el 指令作用的元素的dom对象</span></span><br><span class="line">    <span class="keyword">const</span> points = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>?.<span class="property">roles</span>?.<span class="property">points</span> || [] <span class="comment">// 当前用户信息的操作权</span></span><br><span class="line">    <span class="keyword">if</span> (!points.<span class="title function_">includes</span>(binding.<span class="property">value</span>))&#123; <span class="comment">// 不存在就要删除或者禁用</span></span><br><span class="line">      el.<span class="title function_">remove</span>() <span class="comment">// 删除元素</span></span><br><span class="line">      <span class="comment">// el.disabled = true</span></span><br><span class="line">      <span class="comment">// 线上的权限数据和线下的代码进行对应</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用自定义指令</span></span><br><span class="line">&lt;el-button v-permission=<span class="string">&quot;&#x27;add-employee&#x27;&quot;</span> size=<span class="string">&quot;mini&quot;</span> type=<span class="string">&quot;primary&quot;</span> @click=<span class="string">&quot;$router.push(&#x27;/employee/detail&#x27;)&quot;</span>&gt;</span><br><span class="line">  添加员工</span><br><span class="line">&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>
<h4 id="vuex管理"><a href="#vuex管理" class="headerlink" title="vuex管理"></a><code>vuex</code>管理</h4><blockquote>
<p>在<code>vuex</code>中对<code>token</code>进行管理，将用户的<code>token</code>状态共享，实现后续高效目方便的读取。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">项目登录流程：表单校验通过 --&gt; 调用<span class="title class_">Vuex</span>提供的登录的action --&gt; 登录的<span class="title class_">Action</span>中会调用接口 --&gt; 登录接口如果成功执行，会返回token --&gt; 利用<span class="title class_">Vuex</span>特性，将token共享的到<span class="title class_">Vuex</span>中，这样直接通过 <span class="title class_">Vuex</span> 就可以登录接口会调用单独封装的请求模块(api) --&gt; 请求模块中又会使用用到 axios 封装的请求工具 --&gt; 而请求工具又要考虑区分 开发环境和生产环境的问题 --&gt; 请求时还要考虑前后分离项目产生的跨域问题，要使用代理解决跨域</span><br><span class="line"><span class="title class_">Vuex</span>中声明用户信息状态，修改用户信息的mutations， 和获取用户信息的action</span><br><span class="line">实现token的<span class="title class_">Vue</span>数据持久化</span><br><span class="line"><span class="keyword">import</span> &#123; getToken, setToken, removeToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; login, getUserInfo &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; constantRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; resetRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">token</span>: <span class="title function_">getToken</span>(), <span class="comment">// 从缓存中读取初始值</span></span><br><span class="line">  <span class="attr">userInfo</span>: &#123;&#125;, <span class="comment">// 存储用户基本资料状态</span></span><br><span class="line">  <span class="attr">routes</span>: constantRoutes <span class="comment">// 静态路由的数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="title function_">setToken</span>(<span class="params">state, token</span>) &#123;</span><br><span class="line">    state.<span class="property">token</span> = token</span><br><span class="line">    <span class="title function_">setToken</span>(token) <span class="comment">// 同步到缓存</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">removeToken</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">token</span> = <span class="literal">null</span> <span class="comment">// 删除Vuex的token</span></span><br><span class="line">    <span class="title function_">removeToken</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setUserInfo</span>(<span class="params">state, userInfo</span>) &#123;</span><br><span class="line">    state.<span class="property">userInfo</span> = userInfo</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setRoutes</span>(<span class="params">state, newRoutes</span>) &#123;</span><br><span class="line">    state.<span class="property">routes</span> = [...constantRoutes, ...newRoutes] <span class="comment">// 静态路由 + 动态路由</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">login</span>(<span class="params">context, data</span>) &#123;<span class="comment">// context上下文，传入参数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    <span class="comment">// todo: 调用登录接口</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="keyword">await</span> <span class="title function_">login</span>(data)</span><br><span class="line">    <span class="comment">// 返回一个token 123456</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;setToken&#x27;</span>, token)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getUserInfo</span>(<span class="params">context</span>) &#123;<span class="comment">// 获取用户的基本资料</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getUserInfo</span>()</span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;setUserInfo&#x27;</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result <span class="comment">// 返回数据</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// token失效响应拦截器异常，会调用退出登录action</span></span><br><span class="line">  <span class="title function_">logout</span>(<span class="params">context</span>) &#123; <span class="comment">// 退出登录的action</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;removeToken&#x27;</span>) <span class="comment">// 删除token</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;setUserInfo&#x27;</span>, &#123;&#125;) <span class="comment">// 设置用户信息为空对象</span></span><br><span class="line">    <span class="title function_">resetRouter</span>()<span class="comment">// 重置路由</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用户信息不同于token，token是当前用户的唯一标识，在几个小时内都是有效的，但是用户信息可能会进行修改或者发生变化，所以用户信息在一般的项目或者业务中不进行缓存。</span><br></pre></td></tr></table></figure>
<h4 id="excel导入导出"><a href="#excel导入导出" class="headerlink" title="excel导入导出"></a><code>excel</code>导入导出</h4><blockquote>
<p>使用 FileSaver.js 第三方库实现员工信息 excel 文件的导入导出。</p>
</blockquote>
<ul>
<li>员工管理 - excel 导出</li>
</ul>
<p>导出员工接口返回的是二进制流，axios 配置 responseType 为 blob 接收二进制流文件为 Blob 格式。安装 file-saver 包，实现下载 Blob 文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>封装导出员工excel的<span class="variable constant_">API</span></span><br><span class="line"><span class="comment">// 导出员工的excel</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">exportEmployee</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/sys/user/export&#x27;</span>,</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span> <span class="comment">// 改变接收数据的类型：使用blob接收二进制文件流</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>拦截器判断是不是blob类型，如果是直接返回数据，不再进行解构</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// axios默认包裹了data，判断是不是Blob</span></span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">data</span> <span class="keyword">instanceof</span> <span class="title class_">Blob</span>) <span class="keyword">return</span> response.<span class="property">data</span> <span class="comment">// 返回了Blob对象</span></span><br><span class="line">  <span class="keyword">const</span> &#123; data, message, success &#125; = response.<span class="property">data</span> <span class="comment">// 默认json格式</span></span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title class_">Message</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>, message &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(message))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>点击按钮调用接口，使用file-saver将blob转化成文件下载</span><br><span class="line">&lt;el-button size=<span class="string">&quot;mini&quot;</span> @click=<span class="string">&quot;exportEmployee&quot;</span>&gt;excel导出&lt;/el-button&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FileSaver</span> <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportEmployee &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/employee&#x27;</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">exportEmployee</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">exportEmployee</span>() <span class="comment">// 导出所有的员工接口</span></span><br><span class="line">  <span class="comment">// FileSaver.saveAs(blob对象, 文件名称)</span></span><br><span class="line">  <span class="title class_">FileSaver</span>.<span class="title function_">saveAs</span>(result, <span class="string">&#x27;员工信息表.xlsx&#x27;</span>) <span class="comment">// 下载文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>员工管理 - excel 导入</li>
</ul>
<p><code>创建组件 --&gt; 点击按钮弹出组件 --&gt; 下载模板、上传excel、拖拽上传 --&gt; 导入成功、取消 --&gt; 关闭并重新加载、关闭</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>下载导入模板：调用下载模板接口 --&gt; 接收二进制blob --&gt; 下载文件</span><br><span class="line"><span class="comment">// 下载员工导入模版api</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getExportTemplate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/sys/user/import/template&#x27;</span>,</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span> <span class="comment">// 二进制文件流</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点击按钮进行下载模板</span></span><br><span class="line">&lt;el-button type=<span class="string">&quot;text&quot;</span> @click=<span class="string">&quot;getTemplate&quot;</span>&gt;下载导入模板&lt;/el-button&gt;</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getTemplate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">getExportTemplate</span>()</span><br><span class="line">  <span class="title class_">FileSaver</span>.<span class="title function_">saveAs</span>(data, <span class="string">&#x27;员工导入模版.xlsx&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>上传excel：弹出文件选择框 --&gt; 文件选择 --&gt; 调用上传接口 --&gt; 成功 --&gt; 重新加载数据-关闭弹窗 --&gt; 清空文件选择器</span><br><span class="line"><span class="comment">// 1、封装上传excel的API：上传用户的excel</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">uploadExcel</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/sys/user/import&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data <span class="comment">// form-data类型 因为要上传文件类型</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、点击上传-弹出文件选择框</span></span><br><span class="line">&lt;el-button type=<span class="string">&quot;text&quot;</span> @click=<span class="string">&quot;handleUpload&quot;</span>&gt;点击上传&lt;/el-button&gt;</span><br><span class="line"><span class="title function_">handleUpload</span>(<span class="params"></span>) &#123; <span class="comment">// 触发文件选择框的input的输入框，绑定ref值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>[<span class="string">&#x27;excel-upload-input&#x27;</span>].<span class="title function_">click</span>() <span class="comment">// this.$refs.属性名 和 this.$refs[属性名] 等价</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 3、监听文件改变-上传excel-关闭弹层</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">ref</span>=<span class="string">&quot;excel-upload-input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">class</span>=<span class="string">&quot;excel-upload-input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">accept</span>=<span class="string">&quot;.xlsx, .xls&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  @<span class="attr">change</span>=<span class="string">&quot;uploadChange&quot;</span> // ⭐</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">async uploadChange(event) &#123; // event.target.files[0]内为excel文件</span></span><br><span class="line"><span class="language-xml">  // 调用上传接口：uploadExcel() 中参数form-data 需要文件file</span></span><br><span class="line"><span class="language-xml">  const files = event.target.files // 文件选择框的input的文件列表</span></span><br><span class="line"><span class="language-xml">  if (files.length &gt; 0) &#123;// 大于0 说明有文件要上传</span></span><br><span class="line"><span class="language-xml">    const data = new FormData()</span></span><br><span class="line"><span class="language-xml">    data.append(&#x27;file&#x27;, files[0]) // file: file类型，将文件参数加入到formData中</span></span><br><span class="line"><span class="language-xml">    try &#123;</span></span><br><span class="line"><span class="language-xml">      await uploadExcel(data)</span></span><br><span class="line"><span class="language-xml">      this.$emit(&#x27;uploadSuccess&#x27;) // 通知父组件上传成功 -&gt; 重新加载数据</span></span><br><span class="line"><span class="language-xml">      this.$emit(&#x27;update:showExcelDialog&#x27;, false) // 关闭弹层</span></span><br><span class="line"><span class="language-xml">      // this.$refs[&#x27;excel-upload-input&#x27;].value = &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">    &#125; catch (error) &#123;// 捕获失败</span></span><br><span class="line"><span class="language-xml">      // this.$refs[&#x27;excel-upload-input&#x27;].value = &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">    &#125; finally &#123;</span></span><br><span class="line"><span class="language-xml">      // 不论成功或者失败都会执行finally，所以在这里执行清空文件选择器操作</span></span><br><span class="line"><span class="language-xml">      this.$refs[&#x27;excel-upload-input&#x27;].value = &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">// 4、父组件需要监听上传成功的事件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">import-excel</span> <span class="attr">:show-excel-dialog.sync</span>=<span class="string">&quot;showExcelDialog&quot;</span> @<span class="attr">uploadSuccess</span>=<span class="string">&quot;getEmployeeList&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="递归列表转树"><a href="#递归列表转树" class="headerlink" title="递归列表转树"></a>递归列表转树</h4><blockquote>
<p>使用递归算法将组织架构的树形组件中的列表型结构转换为树形结构。</p>
</blockquote>
<p>树形组件-用层级结构展示信息，可展开或折叠，<code>element-ui</code>提供了树组件<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN/component/tree">el-tree</a>的应用</p>
<p>default-expand-all (默认展开所有节点)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022013813.png" alt=""></p>
<ol>
<li>首先分析数据的关联关系（部门 id 是子部门的 pid）</li>
<li>封装递归函数根据关联关系转化层级结构</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022013695.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、获取组织架构数据：① 封装获取组织的<span class="variable constant_">API</span>   ② 在组织架构初始化时调用方法</span><br><span class="line"><span class="comment">// 封装获取组织的API</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"><span class="comment">// 获取组织架构数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getDepartment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/company/department&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在组织架构初始化时调用方法</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; getDepartment &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/department&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>  &#123;</span><br><span class="line">      <span class="attr">depts</span>: [],</span><br><span class="line">      <span class="attr">defaultProps</span>: &#123;</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;children&#x27;</span>, <span class="comment">// 设置子节点的字段名</span></span><br><span class="line">        <span class="attr">label</span>: <span class="string">&#x27;name&#x27;</span> <span class="comment">// 设置显示内容的字段名</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getDepartment</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">   <span class="keyword">async</span> <span class="title function_">getDepartment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getDepartment</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depts</span> = result</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、递归转化树形结构</span><br><span class="line"><span class="comment">// 封装方法：列表型数据转化树形</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">transListToTreeData</span>(<span class="params">list, rootValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  list.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">pid</span> === rootValue) &#123;<span class="comment">// 找到了匹配的节点</span></span><br><span class="line">      <span class="comment">// 当前节点的id 和 当前节点的子节点的pid是想等的</span></span><br><span class="line">      <span class="keyword">const</span> children = <span class="title function_">transListToTreeData</span>(list, item.<span class="property">id</span>) <span class="comment">// 找到的节点的子节点⭐</span></span><br><span class="line">      item.<span class="property">children</span> = children  <span class="comment">// 将子节点赋值给当前节点</span></span><br><span class="line">      arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取完的组织数据使用转化方法转化成树形</span></span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getDepartment</span>() <span class="comment">// 调用获取数据的接口</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getDepartment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getDepartment</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depts</span> = <span class="title function_">transListToTreeData</span>(result, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归特点：① 一般用来处理未知层级的数据 ② 递归要有跳出条件 ③ 自身调用自身时参数不能重复</p>
<h2 id="主观题"><a href="#主观题" class="headerlink" title="主观题"></a>主观题</h2><p>为什么选择做前端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>你是如何学习前端的，平时都关注哪些新技术</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>你未来的职业规划是什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span> 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载<span class="title class_">Dom</span>→渲染、更新→渲染、销毁等一系列过程，称之为 <span class="title class_">Vue</span> 的生命周期。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、【beforeCreate/onBeforeCreate】 </span><br><span class="line">在实例初始化之后触发，当前阶段data、methods都不可用。</span><br><span class="line"><span class="number">2</span>、【created】 实例创建完成后发生，当前阶段完成了数据观测，data、methods已经可用。</span><br><span class="line">但模板还没有编译，<span class="variable constant_">DOM</span> 还未挂载，如果非要想，可以通过vm.<span class="property">$nextTick</span>来访问<span class="title class_">Dom</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、【beforeMount/onBeforeMount】 </span><br><span class="line">发生在挂载之前，在这之前template模板已导入渲染render函数编译。</span><br><span class="line">当前阶段虚拟<span class="title class_">Dom</span>已经创建完成，但尚未挂载到真实的 <span class="variable constant_">DOM</span>。此时对数据进行更改不会触发updated。</span><br><span class="line"><span class="number">4</span>、【mounted/onMounted】 </span><br><span class="line">实例已被挂载，<span class="variable constant_">DOM</span>渲染完成，数据完成双向绑定，可以访问到<span class="title class_">Dom</span>节点，使用$refs属性对<span class="title class_">Dom</span>进行操作。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、【beforeUpdate/onBeforeUpdate】</span><br><span class="line">发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</span><br><span class="line"><span class="number">6</span>、【updated/onCreated】</span><br><span class="line">发生在更新完成之后，当前阶段组件<span class="title class_">Dom</span>已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、【beforeDestroy/onBeforeUnmounted】</span><br><span class="line">发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</span><br><span class="line"><span class="number">8</span>、【destroyed/onUnmounted】</span><br><span class="line">发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</span><br><span class="line"></span><br><span class="line">① 第一次页面加载会触发哪几个钩子？ beforeCreate、created、beforeMount、mounted </span><br><span class="line">② 你的接口请求一般放在哪个生命周期中？ </span><br><span class="line">  一般放在mounted中，但需要注意的是服务端渲染时不支持mounted，需要放到created中</span><br><span class="line">③ <span class="variable constant_">DOM</span> 渲染在哪个周期中就已经完成？ 在mounted中，</span><br><span class="line">  - 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果需要等整个视图都渲染完毕，可以用 vm.<span class="property">$nextTick</span> 替换掉 mounted</span><br></pre></td></tr></table></figure>
<h3 id="vue2-3响应式原理"><a href="#vue2-3响应式原理" class="headerlink" title="vue2/3响应式原理"></a>vue2/3响应式原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【vue2】</span><br><span class="line">Object.defineProperty() 实现对数据的劫持，将数据对象属性转换成 getter 和 setter</span><br><span class="line">getter：访问数据时触发，Vue 会对依赖进行收集，也就是把依赖这个数据的组件记录下来</span><br><span class="line">setter：数据发生变化时触发，Vue 会通知所有依赖这个数据的地方进行更新，重新渲染。</span><br><span class="line">● 组件data数据一旦变化，立刻触发视图的更新</span><br><span class="line">● 核心API：Object.defineProperty()</span><br><span class="line">  ○ 缺点</span><br><span class="line">    ■ 深度监听，需要递归到底，一次计算量大</span><br><span class="line">    ■ 无法监听新增属性、删除属性（使用Vue.set、Vue.delete可以）</span><br><span class="line">    ■ 无法监听原生数组，需要重写数组原型</span><br><span class="line">    </span><br><span class="line">【vue3】</span><br><span class="line">使用 Proxy 来代替 Object.defineProperty()</span><br><span class="line">Proxy 劫持：Vue3 使用 Proxy 来劫持整个对象，而不仅仅是对象的属性。通过 Proxy，Vue 可以直接监听到数组的变化、对象属性的新增或删除等情况，解决了 Vue 2 的一些局限性。</span><br><span class="line">依赖收集与触发更新：在 Proxy 的 get 方法中，会进行依赖收集，把依赖这个属性的地方记录下来；而在 set 方法中，会触发依赖更新，让相应的视图重新渲染。</span><br></pre></td></tr></table></figure>
<h3 id="vue3和vue2的区别"><a href="#vue3和vue2的区别" class="headerlink" title="vue3和vue2的区别"></a>vue3和vue2的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 源码组织方式变化：使用 TS 重写</span><br><span class="line">- 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</span><br><span class="line">- 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</span><br><span class="line">- 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</span><br><span class="line">- 打包体积优化：移除了一些不常用的api（inline-template、filter）</span><br><span class="line">- 生命周期的变化：使用setup代替了之前的beforeCreate和created</span><br><span class="line">- Vue3 的 template 模板支持多个根标签</span><br><span class="line">- Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore</span><br><span class="line">- Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例</span><br><span class="line">- Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</span><br><span class="line">- 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</span><br></pre></td></tr></table></figure>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVVM是`Model-View-ViewModel`缩写，也就是把`MVC`中的`Controller`演变成`ViewModel`。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</span><br></pre></td></tr></table></figure>
<h3 id="v-model-双向绑定原理"><a href="#v-model-双向绑定原理" class="headerlink" title="v-model 双向绑定原理"></a>v-model 双向绑定原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;message&quot;</span> /&gt; <span class="comment">//等价于：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;message = $event.target.value&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="title class_">Vue2</span> 中，v-model 主要用于表单元素的双向数据绑定，本质上是对 value 和 @input 的语法糖</span><br><span class="line">把输入框的值绑定到你的数据变量上。当用户输入时，自动更新这个数据变量。</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">CustomInput</span> v-model=<span class="string">&quot;message&quot;</span> /&gt; <span class="comment">// 自定义组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">modelValue</span>: <span class="title class_">String</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="title class_">Vue3</span> 中，v-model 默认绑定的是 modelValue，同时监听的事件是 <span class="attr">update</span>:modelValue。</span><br><span class="line">意思是，在自定义组件里要处理的数据属性叫 modelValue，事件名叫 <span class="attr">update</span>:modelValue。</span><br></pre></td></tr></table></figure>
<h3 id="vue组件通信方式"><a href="#vue组件通信方式" class="headerlink" title="vue组件通信方式"></a>vue组件通信方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">父子、隔代、兄弟组件通信</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、props / $emit - 父子</span><br><span class="line">  【传递数据】：父 -&gt; 子 props ，子 -&gt; 父 通过 $emit 触发事件</span><br><span class="line">  </span><br><span class="line"><span class="number">2</span>、$refs  父子组件通信</span><br><span class="line">  ref：在普通的 <span class="variable constant_">DOM</span> 元素上使用，引用指向的就是 <span class="variable constant_">DOM</span> 元素；在子组件上，指向组件实例</span><br><span class="line">  &lt;<span class="title class_">ChildComponent</span> ref=<span class="string">&quot;child&quot;</span> /&gt; <span class="comment">// 父组件中通过 ref 访问子组件</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>.<span class="title function_">someMethod</span>(); <span class="comment">// 访问子组件实例</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、事件总线<span class="title class_">EventBus</span> （$emit / $on） 适用于 父子、隔代、兄弟组件通信，多用于vue2兄弟</span><br><span class="line">  该方法通过一个空的 <span class="title class_">Vue</span> 实例作为中央事件总线（事件中心），用它来触发事件和监听事件</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、provide / inject 适用于 隔代组件通信</span><br><span class="line">  祖先组件中通过 provide 来提供数据，然后在子孙组件中通过 inject 来获取数据。 </span><br><span class="line">  使用场景：主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、<span class="title class_">Vuex</span> - 父子、隔代、兄弟组件通信</span><br><span class="line">  - 组件通过 store.<span class="property">dispatch</span> 来触发全局状态的更新；其他组件通过 store.<span class="property">state</span> 来访问</span><br><span class="line">  - 是响应式的。当组件从 store 中读取状态时，若状态发生变化，那么相应组件也会更新</span><br><span class="line">  - 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。</span><br><span class="line"></span><br><span class="line">● 父子组件：props/$emit/ref</span><br><span class="line">● 兄弟组件：$parent/eventbus/vuex</span><br><span class="line">● 跨层级关系：eventbus/vuex/provide+inject</span><br></pre></td></tr></table></figure>
<h3 id="组合式-选项式API"><a href="#组合式-选项式API" class="headerlink" title="组合式/选项式API"></a>组合式/选项式API</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">composition <span class="variable constant_">API</span>对比<span class="title class_">Option</span> <span class="variable constant_">API</span></span><br><span class="line"> <span class="number">1</span>、<span class="title class_">Composition</span> <span class="variable constant_">API</span>：更好的代码组织，更好的逻辑复用，更好的类型推导</span><br><span class="line"> <span class="number">2</span>、<span class="title class_">Composition</span> <span class="variable constant_">API</span>和<span class="title class_">Options</span> <span class="variable constant_">API</span>如何选择</span><br><span class="line">  ○ 不建议共用，会引起混乱</span><br><span class="line">  ○ 小型项目、业务逻辑简单，用<span class="title class_">Option</span> <span class="variable constant_">API</span>成本更小一些</span><br><span class="line">  ○ 中大型项目、逻辑复杂，用<span class="title class_">Composition</span> <span class="variable constant_">API</span></span><br><span class="line"></span><br><span class="line">setup中如何获取组件实例</span><br><span class="line">● 在setup和其他composition <span class="variable constant_">API</span>中没有<span class="variable language_">this</span></span><br><span class="line">● 通过getCurrentInstance获取当前实例</span><br><span class="line">● 若使用options <span class="variable constant_">API</span>可以照常使用<span class="variable language_">this</span></span><br></pre></td></tr></table></figure>
<h3 id="hash和history路由"><a href="#hash和history路由" class="headerlink" title="hash和history路由"></a>hash和history路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【hash】 路由基于 <span class="variable constant_">URL</span> 的哈希部分（即 # 后面的部分）来管理页面切换。浏览器中的哈希变化</span><br><span class="line">不会触发页面刷新，因此可用来在不重新加载页面的情况下切换视图。【兼容性好、<span class="variable constant_">SEO</span>不友好】</span><br><span class="line"></span><br><span class="line">【history】 路由使用 <span class="title class_">HTML5</span> 的 history.<span class="property">pushState</span> 和 history.<span class="property">replaceState</span> <span class="variable constant_">API</span> 来管</span><br><span class="line">理浏览器历史记录，直接操作 <span class="variable constant_">URL</span> 的路径部分来实现路由导航，而不需要 #。</span><br><span class="line"> - 用户体验更好、<span class="variable constant_">SEO</span>友好、需要服务器配置</span><br></pre></td></tr></table></figure>
<h3 id="v-if-与-v-show-区别"><a href="#v-if-与-v-show-区别" class="headerlink" title="v-if 与 v-show 区别"></a>v-if 与 v-show 区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v-if ：根据条件动态地添加或移除 DOM 元素。</span><br><span class="line">v-show ：始终渲染元素，但通过设置 display: none 来控制其显示和隐藏。</span><br></pre></td></tr></table></figure>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextTick 的作用是让你在数据更新后，等到浏览器更新了 <span class="variable constant_">DOM</span> 之后再执行某段代码。</span><br></pre></td></tr></table></figure>
<h3 id="Vue-与-React-区别"><a href="#Vue-与-React-区别" class="headerlink" title="Vue 与  React 区别"></a>Vue 与  React 区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 设计理念</span><br><span class="line"> <span class="title class_">Vue</span>：更注重易用性和灵活性，适合快速上手。</span><br><span class="line"> <span class="title class_">React</span>：强调组件化和可复用性，更适合构建复杂的用户界面。</span><br><span class="line"><span class="number">2.</span> 数据绑定</span><br><span class="line"> <span class="title class_">Vue</span>：使用双向数据绑定，数据变化会自动更新视图，适合快速开发。</span><br><span class="line"> <span class="title class_">React</span>：采用单向数据流，数据从父组件传递到子组件，变化需要手动更新。</span><br><span class="line"><span class="number">3.</span> 模板 vs <span class="variable constant_">JSX</span></span><br><span class="line"> <span class="title class_">Vue</span>：使用 <span class="variable constant_">HTML</span> 模板，直观易懂，可以使用指令（如 v-<span class="keyword">if</span>、v-<span class="keyword">for</span>）。</span><br><span class="line"> <span class="title class_">React</span>：使用 <span class="variable constant_">JSX</span>，将 <span class="variable constant_">HTML</span> 和 <span class="title class_">JavaScript</span> 结合在一起，灵活但需要学习成本。</span><br><span class="line"><span class="number">4.</span> 生态系统</span><br><span class="line"> <span class="title class_">Vue</span>：生态较小，官方提供了更多的工具（如 <span class="title class_">Vue</span> <span class="title class_">Router</span>、<span class="title class_">Vuex</span>）以便整合。</span><br><span class="line"> <span class="title class_">React</span>：生态较大，有丰富的社区支持和第三方库，但整合需要更多配置。</span><br></pre></td></tr></table></figure>
<h3 id="vue-项目的性能优化"><a href="#vue-项目的性能优化" class="headerlink" title="vue 项目的性能优化"></a>vue 项目的性能优化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">【编码阶段】</span><br><span class="line">- 尽量减少 data 中的数据，会增加 getter 和 setter，会收集对应的 watcher</span><br><span class="line">- v-<span class="keyword">if</span> 和 v-<span class="keyword">for</span> 不能连用</span><br><span class="line">- 如果需要使用 v-<span class="keyword">for</span> 给每项元素绑定事件时使用事件代理</span><br><span class="line">- <span class="variable constant_">SPA</span> 页面采用 keep-alive 缓存组件</span><br><span class="line">- 在更多的情况下，使用 v-<span class="keyword">if</span> 替代 v-show</span><br><span class="line">- key 保证唯一</span><br><span class="line">- 使用路由懒加载、异步组件</span><br><span class="line">- 防抖、节流</span><br><span class="line">- 第三方模块按需导入</span><br><span class="line">- 长列表滚动到可视区域动态加载</span><br><span class="line">- 图片懒加载</span><br><span class="line"></span><br><span class="line">【<span class="variable constant_">SEO</span> 优化】</span><br><span class="line">- 预渲染</span><br><span class="line">- 服务端渲染 <span class="variable constant_">SSR</span></span><br><span class="line"></span><br><span class="line">【打包优化】</span><br><span class="line">- 压缩代码</span><br><span class="line">- <span class="title class_">Tree</span> <span class="title class_">Shaking</span>/<span class="title class_">Scope</span> <span class="title class_">Hoisting</span></span><br><span class="line">- 使用 cdn 加载第三方模块</span><br><span class="line">- 多线程打包 happypack</span><br><span class="line">- splitChunks 抽离公共文件</span><br><span class="line">- sourceMap 优化</span><br><span class="line"></span><br><span class="line">【用户体验】</span><br><span class="line">- 骨架屏</span><br><span class="line">- <span class="variable constant_">PWA</span></span><br><span class="line">还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 gzip 压缩等。</span><br></pre></td></tr></table></figure>
<h3 id="状态管理vuex-pinia"><a href="#状态管理vuex-pinia" class="headerlink" title="状态管理vuex/pinia"></a>状态管理vuex/pinia</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">适合 存储 不同组件之间共享和管理的数据</span><br><span class="line">例如：</span><br><span class="line"><span class="number">1.</span> 用户登录状态：需要在应用程序多个组件之间共享和管理，以便验证权限</span><br><span class="line"><span class="number">2.</span> 全局配置信息：主题、语言、权限</span><br><span class="line"><span class="number">3.</span> 购物车数据：不同页面保持购物车一致</span><br><span class="line"><span class="number">4.</span> 缓存数据：个人信息、常用数据</span><br></pre></td></tr></table></figure>
<h3 id="ref-toRef-toRefs"><a href="#ref-toRef-toRefs" class="headerlink" title="ref /toRef/toRefs"></a>ref /toRef/toRefs</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ref 生成值类型的响应式数据,可用于模板和reactive,通过.<span class="property">value</span>修改值</span><br><span class="line">toRef：</span><br><span class="line">  针对一个响应式对象（reactive封装的）的一个属性，创建一个ref，具有响应式</span><br><span class="line">  两者保持引用关系</span><br><span class="line">toRefs：将响应式对象（reactive封装的）转化为普通对象</span><br><span class="line">  对象的每个属性都是对象的ref</span><br><span class="line">  两者保持引用关系  例：<span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)  <span class="keyword">return</span> <span class="title function_">toRefs</span>(state)</span><br><span class="line">  </span><br><span class="line">最佳使用方式：</span><br><span class="line"> <span class="number">1</span>、用reactive做对象的响应式，用ref做值类型响应式（基本类型）</span><br><span class="line"> <span class="number">2</span>、setup中返回<span class="title function_">toRefs</span>(state)，或者<span class="title function_">toRef</span>(state, <span class="string">&#x27;prop&#x27;</span>)</span><br><span class="line"> <span class="number">3</span>、ref的变量命名都用xxRef</span><br><span class="line"> <span class="number">4</span>、合成函数返回响应式对象时，使用toRefs，有助于使用方对数据进行解构时，不丢失响应式</span><br><span class="line"></span><br><span class="line">为什么需要用 ref：</span><br><span class="line"> <span class="number">1</span>、返回值类型，会丢失响应式</span><br><span class="line"> <span class="number">2</span>、如在setup、computed、合成函数，都有可能返回值类型</span><br><span class="line"> <span class="number">3</span>、<span class="title class_">Vue</span>如不定义ref，用户将制造ref，反而更混乱</span><br><span class="line"></span><br><span class="line">为何ref需要.<span class="property">value</span>属性：</span><br><span class="line"> <span class="number">1</span>、ref是一个对象（不丢失响应式），value存储值</span><br><span class="line"> <span class="number">2</span>、通过.<span class="property">value</span>属性的get和set实现响应式</span><br><span class="line"> <span class="number">3</span>、用于模板、reactive时，不需要.<span class="property">value</span>，其他情况都要</span><br><span class="line"></span><br><span class="line">为什么需要toRef和toRefs：</span><br><span class="line"> <span class="number">1</span>、初衷：不丢失响应式的情况下，把对象数据 分解/扩散</span><br><span class="line"> <span class="number">2</span>、前端：针对的是响应式对象（reactive封装的）非普通对象</span><br><span class="line"> <span class="number">3</span>、注意：不创造响应式，而是延续响应式</span><br></pre></td></tr></table></figure>
<h3 id="如何封装组件"><a href="#如何封装组件" class="headerlink" title="如何封装组件"></a>如何封装组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先进行需求分析，确定组件功能和实现方式。再定义组件 <span class="variable constant_">API</span>，包括传入的 props 和事件。</span><br><span class="line">最后编写组件测试用例，确保组件功能正确。</span><br><span class="line"></span><br><span class="line">封装组件时要注意组件的可复用性、易维护性和可测试性。在编写组件时，应该遵循单一职责原则，</span><br><span class="line">尽量避免组件之间的耦合，提供清晰简洁的 <span class="variable constant_">API</span>，确保组件功能正确，并编写充分的测试用例，</span><br><span class="line">以便于其他开发者和用户使用和维护组件。</span><br><span class="line"></span><br><span class="line">【<span class="title class_">Vue</span> 组件的渲染过程】：组件初始化 -&gt; 模板编译为虚拟 <span class="variable constant_">DOM</span> -&gt; 虚拟 <span class="variable constant_">DOM</span> 渲染为真实 <span class="variable constant_">DOM</span> </span><br><span class="line">  -&gt; 数据更新时 diff 虚拟 <span class="variable constant_">DOM</span> -&gt; 更新真实 <span class="variable constant_">DOM</span>。</span><br></pre></td></tr></table></figure>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="css-权重"><a href="#css-权重" class="headerlink" title="css 权重"></a>css 权重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">属性后面加 !important 会覆盖页面内任何位置定义的元素样式</span><br><span class="line"><span class="number">1.</span> <span class="number">1000</span> 内联样式：&lt;div style=<span class="string">&quot;color: red;&quot;</span>&gt;<span class="title class_">Hello</span>&lt;/div&gt;</span><br><span class="line"><span class="number">2.</span> <span class="number">100</span> id选择器：#header &#123; <span class="attr">color</span>: blue; &#125;</span><br><span class="line"><span class="number">3.</span> <span class="number">10</span> 类选择器【.<span class="property">button</span> &#123;&#125;】、属性选择器【[type=<span class="string">&quot;text&quot;</span>] &#123; &#125;】、伪类选择器【<span class="attr">a</span>:hover &#123; &#125;】</span><br><span class="line"><span class="number">4.</span> <span class="number">1</span> 元素选择器【div &#123; <span class="attr">color</span>: black; &#125;】、伪元素选择器【::before &#123; &#125;】</span><br><span class="line"></span><br><span class="line">【css初始化的作用】：解决不同浏览器之间的默认样式差异，确保网页在不同浏览器中显示一致</span><br></pre></td></tr></table></figure>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">从内到外由四个部分构成：content + padding + border + margin</span><br><span class="line">内容区（content）、内边距（padding，颜色与内容区相同，不能设置透明）、边框（border，会影响盒子占据的总空间）、外边距（margin）</span><br><span class="line"></span><br><span class="line">标准和模型<span class="title class_">Content</span>-box：</span><br><span class="line">	width/height = content，不包含border边框和padding内边距。</span><br><span class="line">	offsetWidth = (width + padding + border),不算margin</span><br><span class="line"><span class="variable constant_">IE</span>盒模型border-box：怪异盒模型 (<span class="title class_">IE8</span>及其以下版本浏览器，未声明 <span class="variable constant_">DOCTYPE</span>)</span><br><span class="line">	width/height = content + padding + border</span><br><span class="line">css中通过box-sizing改变元素盒模型：①content-box - 标准盒模型、②border-box - <span class="variable constant_">IE</span>盒模型、③<span class="title function_">inherit</span>(继承父元素box-sizing属性值)</span><br></pre></td></tr></table></figure>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">块级格式化上下文，是一个独立的渲染区域</span><br><span class="line">【触发条件】：</span><br><span class="line"><span class="number">1</span>、根元素<span class="variable constant_">HTML</span>，本身就形成<span class="variable constant_">BFC</span></span><br><span class="line"><span class="number">2</span>、元素的 position 属性值为 absolute 或 fixed。</span><br><span class="line"><span class="number">3</span>、display的值为inline-block、table-cell、inline-flex、grid、inline-grid</span><br><span class="line"><span class="number">4</span>、浮动元素：float值为left、right</span><br><span class="line"><span class="number">5</span>、overflow值为 auto、scroll、hidden</span><br><span class="line">【作用】：</span><br><span class="line"><span class="number">1</span>、清除浮动：子元素设置浮动 -&gt; 父元素可能会出现高度塌陷 -&gt; 父：<span class="attr">overflow</span>: hidden</span><br><span class="line"><span class="number">2</span>、防止外边距折叠：两个块级元素垂直相邻时，上下边距可能会合并成两个中较大的边距</span><br><span class="line"><span class="number">3</span>、自适应多栏布局：两栏</span><br><span class="line">   两兄弟块级元素一个设置左浮动，可能会覆盖另一个部分空间，给另一个元素设置<span class="attr">overflow</span>: hidden，开启<span class="variable constant_">BFC</span>，会使另一个元素靠左浮动元素排列，不再重叠，达成自适应两栏布局。</span><br><span class="line">   </span><br><span class="line">【清除浮动】：</span><br><span class="line"><span class="number">1</span>、在浮动元素后面添加 <span class="attr">clear</span>:both的空 div 元素</span><br><span class="line"><span class="number">2</span>、给父元素添加 <span class="attr">overflow</span>:hidden 或者 auto 样式，触发<span class="variable constant_">BFC</span></span><br><span class="line"><span class="number">3</span>、使用伪元素，在元素末尾 :after 添加一个 点 并带有 <span class="attr">clear</span>: both 属性的元素实现的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">IFC</span> 内联格式化上下文  --  内联元素的布局规则（文本、链接）</span><br><span class="line">特点：</span><br><span class="line"><span class="number">1.</span> 从左到右水平排列</span><br><span class="line"><span class="number">2.</span> 默认基线对齐，可用vertical-align调整</span><br><span class="line"><span class="number">3.</span> 行高由字体大小和line-height决定</span><br><span class="line"><span class="number">4.</span> 元素宽度取决于内容</span><br><span class="line"><span class="number">5.</span> 垂直方向上margin不会重叠</span><br><span class="line">触发方法：display：inline/inline-block</span><br></pre></td></tr></table></figure>
<h3 id="水平垂直居中1"><a href="#水平垂直居中1" class="headerlink" title="水平垂直居中1"></a>水平垂直居中1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">行内元素：span a</span><br><span class="line"><span class="number">1</span>、line-height 设置为与父容器的 height 一致 和 text-align：center</span><br><span class="line"><span class="number">2</span>、justify-<span class="attr">content</span>: center 水平居中，align-<span class="attr">items</span>: center 垂直居中。</span><br><span class="line">○ 水平居中：text-<span class="attr">align</span>: center/父元素：<span class="attr">display</span>: flex; justify-<span class="attr">content</span>: center</span><br><span class="line">○ 垂直居中：</span><br><span class="line">   单行文本：height === line-height</span><br><span class="line">   多行文本父元素确认高度：<span class="attr">display</span>: table-cell; vertical-<span class="attr">align</span>: middle</span><br><span class="line"></span><br><span class="line">块元素：div</span><br><span class="line"><span class="number">1</span>、flex+margin</span><br><span class="line">  父元素：<span class="attr">display</span>: flex;</span><br><span class="line">         justify-<span class="attr">content</span>: center;</span><br><span class="line">         align-<span class="attr">items</span>: center</span><br><span class="line"><span class="number">2</span>、定位+tranform</span><br><span class="line">  父元素：<span class="attr">position</span>: relative</span><br><span class="line">  子元素：<span class="attr">position</span>: absolute;  使元素的左上角移动到父容器的正中央</span><br><span class="line">         <span class="attr">top</span>: <span class="number">50</span>%; <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">         <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">50</span>%)  使元素的中心点对齐</span><br><span class="line"><span class="number">3</span>、grid网格布局</span><br><span class="line">  父元素：<span class="attr">display</span>: grid;</span><br><span class="line">         place-<span class="attr">items</span>: center 让子元素在 <span class="title class_">Grid</span> 容器中水平和垂直方向居中</span><br></pre></td></tr></table></figure>
<h3 id="em-px-rem-vh-vw-区别"><a href="#em-px-rem-vh-vw-区别" class="headerlink" title="em/px/rem/vh/vw 区别"></a>em/px/rem/vh/vw 区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、vw：viewpoint width，视口宽度的百分比单位。100vw = <span class="number">100</span>% 视图窗口宽度。</span><br><span class="line"><span class="number">2</span>、vh：viewpoint height，视口高度的百分比单位。100vh = <span class="number">100</span>% 视图窗口高度。</span><br><span class="line"><span class="number">3</span>、rem：相对根节点html的字体大小的单位。默认情况下，根元素的字体大小等于浏览器的默认字体大小（16px, <span class="number">1</span> rem = 16px）。通过设置根元素的字体大小，可进行整体的比例调整</span><br><span class="line"><span class="number">4</span>、em：相对于父元素字体大小的单位。em 单位具有继承性，子元素会受到父元素字体大小的影响。如果自身定义了font-size按自身来计算（浏览器默认字体是16px）</span><br><span class="line"><span class="number">5</span>、px 绝对单位，页面精准按像素展示； % 相对于父元素的宽度比例</span><br><span class="line"></span><br><span class="line">主要区别如下：</span><br><span class="line">vw 和 vh 是相对于视口宽度和高度的单位，而 rem 和 em 是相对于字体大小的单位。</span><br><span class="line">vw 和 vh 单位可直接根据屏幕尺寸进行调整，而 rem 和 em 单位则需依赖于父元素的字体大小。</span><br><span class="line">rem 单位更适合用于整体的比例调整，而 em 单位更适合用于相对布局中的局部调整。</span><br></pre></td></tr></table></figure>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器（使用flex布局的元素）和项目（子元素），采用主轴和交叉轴来定义布局方向</span><br><span class="line">项目属性中很多时候会用到 <span class="attr">flex</span>: <span class="number">1</span> ，它具体包含了以下的意思</span><br><span class="line">● flex-<span class="attr">grow</span>: <span class="number">1</span> ：默认为 <span class="number">0</span> ，若存在剩余空间，元素也不放大。若设为 <span class="number">1</span> 项目会平分剩余空间</span><br><span class="line">● flex-<span class="attr">shrink</span>: <span class="number">1</span> ：默认为 <span class="number">1</span> ，如果空间不足，元素会缩小。（若值为 <span class="number">0</span>，项目不会缩小）</span><br><span class="line">● flex-<span class="attr">basis</span>: <span class="number">0</span>% ：表示项目的初始大小为 <span class="number">0</span>，即在分配多余空间之前，它不占据任何空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 <span class="number">0</span>% 之后，因为有 flex-grow 和 flex-shrink 的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis 设为auto 的话，其本身大小将会是 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、新增选择器，如</span><br><span class="line"><span class="number">2</span>、边框属性： border-radius圆角边框 box-shadow阴影 border-image用图片绘制边框</span><br><span class="line"><span class="number">3</span>、盒模型： 弹性布局flex 栅格布局grid</span><br><span class="line"><span class="number">4</span>、渐变：线性渐变:linear-<span class="title function_">gradient</span>(red, green, blue);</span><br><span class="line">        径向渐变:radial-gradient (red, green, blue)</span><br><span class="line"><span class="number">5</span>、阴影：box-<span class="attr">shadow</span>: 3px 3px 3px <span class="title function_">rgba</span>(<span class="number">0</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">0.3</span>)</span><br><span class="line"><span class="number">6</span>、背景：background-clip背景画区、background-origin图片对齐、</span><br><span class="line">        background-size和background-<span class="keyword">break</span></span><br><span class="line"><span class="number">7</span>、文字：text-overflow：clip/ellipsis，溢出时修剪/用...表示</span><br><span class="line"><span class="number">8</span>、transform：<span class="title function_">translate</span>(120px, <span class="number">50</span>%)：位移</span><br><span class="line">              <span class="title function_">scale</span>(<span class="number">2</span>, <span class="number">0.5</span>)：缩放</span><br><span class="line">              <span class="title function_">rotate</span>(<span class="number">0.</span>5turn)：旋转</span><br><span class="line">              <span class="title function_">skew</span>(30deg, 20deg)：倾斜</span><br><span class="line"><span class="number">9</span>、animation动画：animation-name：动画名称</span><br><span class="line">                 animation-duration：动画持续时间</span><br><span class="line">                 animation-timing-<span class="keyword">function</span>：动画时间函数</span><br><span class="line">                 animation-delay：动画延迟时间</span><br><span class="line">                 animation-iteration-count：动画执行次数</span><br><span class="line">                 animation-direction：动画执行方向</span><br><span class="line">                 animation-paly-state：动画播放状态</span><br><span class="line">                 animation-fill-mode：动画填充模式</span><br></pre></td></tr></table></figure>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、static（默认值）：元素处于正常的文档流中。</span><br><span class="line">2、relative：相对定位。元素在正常文档流中的位置不变，但可以通过设置top等属性来相对于其正常位置进行偏移。发生偏移时可能会覆盖其他元素，但不会影响其他元素的布局。</span><br><span class="line">3、absolute：绝对定位。元素脱离正常文档流，并相对于最近的已定位祖先元素或 &lt;body&gt; 元素进行定位。如果没有已定位的祖先元素，则相对于视口进行定位。</span><br><span class="line">4、fixed：固定定位。元素脱离正常文档流，并相对于视口进行定位。</span><br><span class="line">5、sticky：粘性定位。元素根据正常文档流进行定位，然后相对于离它最近的具有滚动机制的祖先元素或视口进行定位。当用户滚动页面时，元素的定位会发生变化。</span><br></pre></td></tr></table></figure>
<h3 id="隐藏页面元素"><a href="#隐藏页面元素" class="headerlink" title="隐藏页面元素"></a>隐藏页面元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="attr">display</span>:<span class="attr">none</span>: 彻底隐藏元素，元素从文档流中消失，不占据空间不能交互，也不影响布局</span><br><span class="line"><span class="number">2</span>、<span class="attr">visibility</span>:<span class="attr">hidden</span>: 隐藏元素，仍占据空间，但不可以交互</span><br><span class="line"><span class="number">3</span>、<span class="attr">opacity</span>: <span class="number">0</span>：将元素的透明度将为<span class="number">0</span>。看起来隐藏了，但依然占据空间，可以交互</span><br><span class="line"><span class="number">4</span>、<span class="attr">overflow</span>:<span class="attr">hidden</span>: 只隐藏元素溢出部分，占据空间且不可交互</span><br><span class="line"><span class="number">5</span>、z-<span class="attr">index</span>:-<span class="number">9999</span>: 原理是将层级放到底部，被覆盖，看起来隐藏了</span><br><span class="line"><span class="number">6</span>、<span class="attr">transform</span>:<span class="title function_">scale</span>(<span class="number">0</span>,<span class="number">0</span>): 平面变换，将元素缩放为<span class="number">0</span>，但依然占据空间，不可交互</span><br><span class="line"></span><br><span class="line"><span class="attr">display</span>: none 与 <span class="attr">visibility</span>: hidden 这两个属性都是让元素隐藏，不可见。区别：</span><br><span class="line"><span class="number">1</span>、<span class="attr">display</span>: none：让元素从文档流中移除，不占据任何空间；是非继承属性，所有子元素都不可见，对页面的渲染性能影响较小。</span><br><span class="line"><span class="number">2</span>、<span class="attr">visibility</span>: hidden：元素仍占据空间，但内容不可见。只是将元素的可见性设置为隐藏，其他元素的布局不受影响。子元素也会被隐藏，但可以通过单独设置子元素的 <span class="attr">visibility</span>: visible 来让子元素显示，而父元素仍然保持隐藏状态。</span><br></pre></td></tr></table></figure>
<h3 id="CSS动画和过渡"><a href="#CSS动画和过渡" class="headerlink" title="CSS动画和过渡"></a>CSS动画和过渡</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">css动画：transition -渐变动画  transform - 转变动画  animation - 自定义动画</span><br><span class="line"><span class="number">1</span>、transition属性：</span><br><span class="line">	transition-<span class="attr">property</span>: 填写需要变化的css属性</span><br><span class="line">  transition-<span class="attr">duration</span>: 完成过渡效果需要的时间单位(s或者ms)默认是 <span class="number">0</span></span><br><span class="line">  transition-timing-<span class="attr">function</span>: 完成效果的速度曲线</span><br><span class="line">  transition-<span class="attr">delay</span>: （规定过渡效果何时开始。默认是<span class="number">0</span>）</span><br><span class="line">  一般情况下，都是写一起的，比如：transition：width 2s ease 1s</span><br><span class="line"><span class="number">2</span>、transform 转变动画。包含四个常用的功能：</span><br><span class="line">  <span class="title function_">translate</span>(x,y)：位移      scale：缩放</span><br><span class="line">  rotate：旋转              skew：倾斜</span><br><span class="line">一般配合transition过渡使用。注意：transform不支持inline元素，使用前把它变成block</span><br><span class="line"><span class="number">3</span>、animation   @keyframes定义关键帧</span><br><span class="line">  <span class="variable constant_">CSS</span> 动画只需要定义一些关键的帧，而其余帧，浏览器会根据计时函数插值计算出来，</span><br><span class="line">  可以是<span class="keyword">from</span>-&gt;to（等同于<span class="number">0</span>%和<span class="number">100</span>%），<span class="keyword">from</span> 表示最开始的那一帧，to 表示结束时的那一帧</span><br></pre></td></tr></table></figure>
<h3 id="css提高性能的方法"><a href="#css提高性能的方法" class="headerlink" title="css提高性能的方法"></a>css提高性能的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、内联首屏关键<span class="variable constant_">CSS</span>：通过内联css关键代码能够使浏览器在下载完html后就能立刻渲染</span><br><span class="line"><span class="number">2</span>、异步加载<span class="variable constant_">CSS</span>：</span><br><span class="line">   对于不需要立即加载的 <span class="variable constant_">CSS</span> 文件，可以使用 media 属性或动态加载 <span class="variable constant_">CSS</span> 来推迟它的加载</span><br><span class="line"><span class="number">3</span>、资源压缩：利用webpack、gulp等模块化工具，将css文件进行压缩，降低浏览器的加载时间</span><br><span class="line"><span class="number">4</span>、合理使用选择器：</span><br><span class="line">    避免过度嵌套(会增加浏览器解析的成本),使用 <span class="variable constant_">ID</span> 和类选择器,避免使用复杂选择器</span><br><span class="line"><span class="number">5</span>、不要使用@important：会覆盖其他样式，增加渲染时间</span><br><span class="line"><span class="number">6</span>、其他：</span><br><span class="line">   使用<span class="variable constant_">CSS</span>预处理器</span><br><span class="line">   减少重排操作，以及减少不必要的重绘</span><br><span class="line">   了解哪些属性可以继承而来，避免对这些属性重复编写</span><br><span class="line">   css <span class="title class_">Sprite</span>，用宽高加上backgroud-position的背景图方式显现icon图，减少http请求</span><br><span class="line">   把小的icon图片转成base64编码</span><br><span class="line">   <span class="title class_">CSS3</span>动画或者过渡尽量使用transform和opacity来实现动画，不要使用left和top属性</span><br></pre></td></tr></table></figure>
<h3 id="两栏：左定宽右自适应1"><a href="#两栏：左定宽右自适应1" class="headerlink" title="两栏：左定宽右自适应1"></a>两栏：左定宽右自适应1</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;box-<span class="attribute">left</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;box-<span class="attribute">right</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line">【解决方案】：</span><br><span class="line">① 利用flexbox实现：</span><br><span class="line">首先给最外层的<span class="selector-tag">div</span>的<span class="attribute">display</span>属性设为<span class="attribute">flex</span>，再给左侧<span class="selector-tag">div</span>设置一个宽度<span class="number">200px</span>,</span><br><span class="line">最后给右侧<span class="selector-tag">div</span>的 <span class="attribute">flex-grow</span>属性设为<span class="number">1</span>，使其占据剩余的空间，达到自适应效果。</span><br><span class="line"></span><br><span class="line">② 利用<span class="attribute">grid</span>网格布局实现：</span><br><span class="line">给最外层的<span class="selector-tag">div</span>：<span class="attribute">display</span>：<span class="attribute">grid</span>，<span class="attribute">grid-template-columns</span>：<span class="number">200px</span> auto</span><br><span class="line">左边栏定宽 <span class="number">200px</span>，右边栏使用 auto 占据剩余空间，实现自适应布局。</span><br><span class="line"></span><br><span class="line">③ 利用<span class="attribute">float</span> 浮动实现：</span><br><span class="line">给左侧<span class="selector-tag">div</span>设置一个宽度<span class="number">200px</span>,并向左浮动，并给右侧<span class="selector-tag">div</span>的<span class="attribute">margin-left</span>值设为左侧<span class="selector-tag">div</span>的宽度，</span><br><span class="line">使其避开左边的定宽栏，达到自适应效果。</span><br><span class="line"></span><br><span class="line">④ 利用<span class="attribute">position</span>定位实现：</span><br><span class="line">最外层<span class="selector-tag">div</span>的<span class="attribute">position</span>属性设为相对定位，左侧<span class="selector-tag">div</span>的<span class="attribute">position</span>属性设为绝对定位，给定一个宽度，并将<span class="attribute">left</span>\<span class="attribute">top</span>\<span class="attribute">bottom</span>值设为<span class="number">0</span>，最后右侧<span class="selector-tag">div</span>的<span class="attribute">margin-left</span>值设为左侧<span class="selector-tag">div</span>的宽度。</span><br></pre></td></tr></table></figure>
<h3 id="画一条0-5px的线"><a href="#画一条0-5px的线" class="headerlink" title="画一条0.5px的线"></a>画一条0.5px的线</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、通过 transform 进行缩放：</span><br><span class="line"><span class="attr">height</span>: 1px <span class="comment">// 设置线的初始高度为 1px。</span></span><br><span class="line"><span class="attr">transform</span>: <span class="title function_">scaleY</span>(<span class="number">0.5</span>) <span class="comment">// 将线条沿 Y 轴缩小 50%，达到 0.5px 的效果。</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、采用 border 的方式：border-<span class="attr">top</span>: <span class="number">0.</span>5px solid black; <span class="comment">/* 设置0.5px的顶部边框 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、采用 meta viewport 的方式：</span><br><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可以利用 【边框】 属性来实现的：将一个元素的宽高设为 <span class="number">0</span>，然后只设置四个边框中的一个为有颜色（向下的三角形，给<span class="attribute">top</span>设颜色），其他边框设置为透明。</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">10px</span> solid red; // 向上的三角形</span><br><span class="line">  <span class="attribute">border-right</span>:<span class="number">10px</span> solid transparent; </span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">10px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表单中常见标签"><a href="#表单中常见标签" class="headerlink" title="表单中常见标签"></a>表单中常见标签</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>、select、<span class="selector-tag">textarea</span>多行文本、<span class="selector-tag">button</span>、<span class="selector-tag">label</span>标签</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型（栈）：直接存储在内存中的数据，值不可变</span><br><span class="line">	Number、String、Boolean、Null-空值、Undefined-未定义、Symbol(ES6)、BigInt(ES2020)</span><br><span class="line">	- Number特殊值：Infinity-正无穷大、-Infinity-负无穷大、NaN-非数值</span><br><span class="line">  - 当使用 var或 let声明了变量但没有初始化时，就相当于给变量赋予了 undefined值</span><br><span class="line">	- Symbol：表示一个独一无二的值，通常用于对象属性的唯一标识符。</span><br><span class="line">	- BigInt：表示任意大的整数，用来处理超过Number类型能表示的安全整数范围2^53-1</span><br><span class="line">引用数据类型（堆）：存储的是对象的地址或引用，变量保存的是指向内存中某个对象的引用，而不是实际的值。</span><br><span class="line">	- Object、Array、Function、Date、RegExp(正则表达式)、Map和Set(ES6)</span><br><span class="line">	- Map 是一个键值对的集合，键可以是任意类型;Set 是一个值的集合，值都是唯一的。</span><br></pre></td></tr></table></figure>
<h3 id="typeof类型判断"><a href="#typeof类型判断" class="headerlink" title="typeof类型判断"></a>typeof类型判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">typeof</span> - 主要用于检测基本数据类型</span><br><span class="line">	注意：对基本数据类型，除了 <span class="literal">null</span> （<span class="literal">null</span>返回object）都可以显示正确的类型；</span><br><span class="line">       引用类型除了函数返回的都是 object， 因为所有的对象的原型最终都是 <span class="title class_">Object</span>。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">instanceof</span> - 用于检查某个对象是否是某个类或构造函数的实例。  内部机制：原型链</span><br><span class="line">			主要用于判断复杂的引用类型。原理就是查找目标对象的原型链。</span><br><span class="line">	示例：[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//true  function()&#123;&#125; instanceof Function // true</span></span><br><span class="line"><span class="number">3</span>、<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>() - 更精确的方法，适用于判断所有类型。</span><br><span class="line">	示例：<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line">       <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/regex/</span>) <span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line">	手写：<span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>)); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="number">4</span>、constructor 属性 - 每个<span class="variable constant_">JS</span>对象都有，用于指向创建该对象的构造函数。可通过该属性判断类型。</span><br><span class="line">	注意：①<span class="literal">null</span> 和 <span class="literal">undefined</span>是无效的对象，不会有 constructor 存在，无法据此属性判断。</span><br><span class="line">			 ②<span class="variable constant_">JS</span>对象的 constructor 是不稳定的，主要体现在自定义对象上，当开发者重写</span><br><span class="line">       prototype 后，原有的 constructor会丢失，constructor 会默认为<span class="title class_">Object</span>。</span><br><span class="line">        ③类继承的也会出错，因为 <span class="title class_">Object</span> 被覆盖了，检测结果就不对了。</span><br><span class="line"><span class="number">5</span>、<span class="title class_">Array</span>.<span class="title function_">isArray</span>() - 专门用于判断某个值是否为数组，返回<span class="literal">true</span>/<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">【作用域】：全局作用域、函数作用域、块级作用域（在大括号中使用<span class="keyword">let</span>和<span class="keyword">const</span>声明的变量）</span><br><span class="line">【作用域链的作用】是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</span><br><span class="line"></span><br><span class="line">【原型】：每个构造函数都有prototype属性，称之为原型 | 原型对象。</span><br><span class="line">  原型可以放一些属性和方法，共享给实例对象使用，可以继承</span><br><span class="line">  <span class="comment">// ● 每个class都有显示原型prototype</span></span><br><span class="line">  <span class="comment">// ● 每个实例都有隐式原型__proto__</span></span><br><span class="line">  <span class="comment">// ● 实例的__proto__指向class的prototype</span></span><br><span class="line">【原型链】：当访问一个对象的属性时，如果这个对象内部不存在这个属性，</span><br><span class="line">那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，</span><br><span class="line">于是就这样一直找下去，也就是原型链的概念。（ 对象都有__proto__ 属性，</span><br><span class="line">这个属性指向它的原型对象，而原型对象也是对象，也有 __proto__ 属性，</span><br><span class="line">指向原型对象的原型对象,这样一层一层形成的链式结构称为原型链，最顶层找不到则返回 <span class="literal">null</span> ）</span><br><span class="line"></span><br><span class="line">由于<span class="title class_">Object</span>是构造函数，原型链终点是<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>，而</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>=== <span class="literal">null</span> <span class="comment">// true，所以，原型链的终点是null</span></span><br><span class="line"></span><br><span class="line">【访问一个对象的原型对象】：</span><br><span class="line"><span class="number">1.</span> 对象.<span class="property">__proto__</span>  指向构造函数的prototype</span><br><span class="line"><span class="number">2.</span> <span class="title class_">Object</span>.<span class="title function_">getPrototypeof</span>(对象)         更安全！！</span><br><span class="line"></span><br><span class="line">【与作用域链区别】：作用域链是找【变量】的链，找不到会报错；原型链</span><br><span class="line">是找【属性】的链，找不到会返回 <span class="literal">undefined</span> 。</span><br><span class="line"></span><br><span class="line">【原型的作用】：原型就相当于是一个公共的区域，可以被所有该类实例访问，</span><br><span class="line">可以将一个该类实例中，所有的公共属性（方法）统一存储到原型中，</span><br><span class="line">这样只需要创建一个属性，即可被所有实例访问。</span><br><span class="line"><span class="comment">// JS 中继承就是通过原型来实现的，当继承时，子类的原型就是一个父类的实例</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">instanceof</span> 检查的是对象的原型链上是否有该类实例。返回 <span class="literal">true</span> / <span class="literal">false</span> 。    </span><br><span class="line"><span class="title class_">Object</span> 是所有对象的原型，任何和对象和 <span class="title class_">Object</span> 进行 <span class="keyword">instanceof</span> 运算都会返回 <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">【大部分情况下是不需要修改原型对象】</span><br><span class="line">- 注意：千万不要通过类的实例去修改原型</span><br><span class="line">- 处了通过 __proto__ 能访问对象的原型外，还可以通过类的 prototype 属性，</span><br><span class="line">来访问实例的原型修改原型时，最好通过通过类去修改。</span><br><span class="line">- 好处：① 一修改就是修改所有实例的原型  ②无需创建实例即可完成对类的修改</span><br></pre></td></tr></table></figure>
<h3 id="闭包和内存泄露"><a href="#闭包和内存泄露" class="headerlink" title="闭包和内存泄露"></a>闭包和内存泄露</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">【闭包】：函数 A 内部有一个函数 B， B 可以访问到 A 中的变量，函数 B 就是闭包</span><br><span class="line">形成闭包的原因：内部的函数存在外部作用域的引用就会导致闭包。</span><br><span class="line">闭包特性：函数嵌套函数、函数内部可以引用函数外部的参数和变量、</span><br><span class="line">				参数和变量不会被垃圾回收机制回收。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包的作用：</span></span><br><span class="line"><span class="number">1</span>、用于封装私有变量，保护函数私有变量不受外部的访问和修改。</span><br><span class="line"><span class="number">2</span>、通常情况下，函数执行完毕后，函数内部的局部变量就会被销毁。</span><br><span class="line">但闭包可使局部变量在函数执行结束后依然存在，进而实现数据的持久化。</span><br><span class="line"><span class="number">3</span>、防抖节流、柯里化</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包导致内存泄漏：</span></span><br><span class="line"><span class="number">1.</span>代码中存在不再需要的函数引用，导致函数关联的词法环境无法销毁；</span><br><span class="line"><span class="number">2.</span>当多个函数共享词法环境时，会导致出现无法触达也无法回收的内存空间</span><br><span class="line">- 如何避免：</span><br><span class="line">在退出函数之前，将不使用的局部变量全部删除，或赋值为<span class="literal">null</span>;</span><br><span class="line">避免变量的循环引用和赋值</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包与异步执行函数：（for循环中 + setTimeOut）</span></span><br><span class="line"><span class="number">1.</span><span class="title class_">ES6</span>中<span class="keyword">let</span>，<span class="keyword">for</span>循环变块级作用域（原先i是全局）</span><br><span class="line"><span class="number">2.</span>立即执行函数（函数作用域可以保存变量）</span><br><span class="line">【经典面试题：循环中使用闭包解决<span class="keyword">var</span>定义函数的问题】</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// setTimeout 是个异步函数，会先把循环全部执行完毕，这时候 i就是 6 ，所以会输出一堆 6</span></span><br><span class="line"><span class="comment">// 解决方法：</span></span><br><span class="line"><span class="number">1</span>、使用 立即执行函数 将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j</span><br><span class="line"><span class="number">2</span>、使用 <span class="built_in">setTimeout</span> 的第三个参数，这个参数会被当成 timer 函数的参数传入</span><br><span class="line"><span class="number">3</span>、使用 <span class="keyword">let</span> 定义 i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下四种情况会造成内存泄漏：</span></span><br><span class="line"><span class="number">1</span>、意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class="line"><span class="number">2</span>、被遗忘的计时器或回调函数：设置了 <span class="built_in">setInterval</span> 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</span><br><span class="line"><span class="number">3</span>、脱离 <span class="variable constant_">DOM</span> 的引用： 获取一个 <span class="variable constant_">DOM</span> 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</span><br><span class="line"><span class="number">4</span>、闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用于复制对象和数组</span><br><span class="line">1、浅拷贝</span><br><span class="line">	只复制对象的第一层属性。如果属性是基本类型，拷贝的就是基本类型的值；</span><br><span class="line">	如果属性是引用类型（如对象或数组），浅拷贝将引用地址赋给新的对象。</span><br><span class="line">	因此，如果修改嵌套对象或数组，浅拷贝和原对象都会受到影响。</span><br><span class="line">	浅拷贝的方式：Object.assign()、Array.slice(), Array.concat()、扩展运算符（...）</span><br><span class="line">2、深拷贝</span><br><span class="line">	会递归地复制对象中的所有属性，无论是基本类型还是引用类型。</span><br><span class="line">	改变拷贝后新对象的值，不会影响原对象的值。</span><br><span class="line">	深拷贝的方式：JSON.parse(JSON.stringify())</span><br><span class="line">	</span><br><span class="line">深拷贝时如何解决循环依赖的问题：</span><br><span class="line">【缓存对象】：用于存储已经拷贝过的对象的引用。</span><br><span class="line">每次深拷贝 -&gt; 检查缓存中是否已经存在该对象的拷贝（已存在，则退出循环）</span><br><span class="line">-&gt; return 拷贝后的对象</span><br></pre></td></tr></table></figure>
<h3 id="async-await-的理解"><a href="#async-await-的理解" class="headerlink" title="async/await 的理解"></a>async/await 的理解</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【<span class="keyword">async</span> 关键字】：<span class="keyword">async</span> 用于定义一个异步函数。</span><br><span class="line"><span class="keyword">async</span> 函数会自动返回一个 <span class="title class_">Promise</span> 对象。若函数有返回值，那这个值会被 <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() 包装成一个 <span class="title class_">Promise</span> 返回。无返回值则，<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">undefined</span>)</span><br><span class="line">【<span class="keyword">await</span> 关键字】：用于等待<span class="title class_">Promise</span>完成，只能在 <span class="keyword">async</span> 函数中使用。</span><br><span class="line">当遇到 <span class="keyword">await</span> 时，函数执行会暂停，直到 <span class="title class_">Promise</span> 状态变为 resolved（成功），并返回 <span class="title class_">Promise</span> 的结果。<span class="keyword">await</span> 后面跟着的是一个 <span class="title class_">Promise</span>，它会暂停代码执行直到 <span class="title class_">Promise</span> 完成。</span><br><span class="line">● 执行 <span class="keyword">async</span> 函数，返回的是promise</span><br><span class="line">● <span class="keyword">await</span> 相当于 promise 的 then</span><br><span class="line">● <span class="keyword">try</span>...<span class="keyword">catch</span> 可捕获异常，代替了 promise 的 <span class="keyword">catch</span></span><br><span class="line">● <span class="keyword">await</span> 后面跟 <span class="title class_">Promise</span> 对象：会阻断后续代码，等待状态变为 fulfilled ，才获取结果并继续执行</span><br><span class="line">● <span class="keyword">await</span> 后续跟非 <span class="title class_">Promise</span> 对象：会直接返回</span><br></pre></td></tr></table></figure>
<h3 id="promise异步总结"><a href="#promise异步总结" class="headerlink" title="promise异步总结"></a>promise异步总结</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>、三种状态</span><br><span class="line">  ● pending、<span class="title function_">fulfilled</span>(通过resolve触发)、<span class="title function_">rejected</span>(通过reject触发)</span><br><span class="line">  ● pending =&gt; fulfilled 或者 pending =&gt; rejected</span><br><span class="line">  ● 状态变化不可逆</span><br><span class="line"><span class="number">2</span>、状态的表现和变化</span><br><span class="line">  ● pending状态，不会触发then和<span class="keyword">catch</span></span><br><span class="line">  ● fulfilled状态会触发后续的then回调</span><br><span class="line">  ● rejected状态会触发后续的<span class="keyword">catch</span>回调</span><br><span class="line"><span class="number">3</span>、then和<span class="keyword">catch</span>对状态的影响（重要）</span><br><span class="line">  ● then 正常返回 fulfilled，里面有报错返回 rejected</span><br><span class="line">  ● <span class="keyword">catch</span> 正常返回 fulfilled，里面有报错返回 rejected</span><br></pre></td></tr></table></figure>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">模块化好处：解决命名冲突、提供复用性、提高代码可维护性</span><br><span class="line"><span class="number">1</span>、立即执行函数</span><br><span class="line">  早期，用此实现模块化比较常见，通过函数作用域解决了命名冲突、污染全局作用域的问题</span><br><span class="line"><span class="number">2</span>、<span class="variable constant_">AMD</span> 和 <span class="variable constant_">CMD</span></span><br><span class="line">  <span class="variable constant_">AMD</span> 允许在浏览器端异步加载模块，以避免阻塞页面渲染。</span><br><span class="line">  使用 define 来定义模块，模块的依赖项会作为参数传递。 使用 <span class="built_in">require</span> 来加载模块。</span><br><span class="line"><span class="number">3</span>、<span class="title class_">CommonJS</span></span><br><span class="line">是 <span class="title class_">Node</span>.<span class="property">js</span> 使用的模块系统。核心思想是使用 <span class="built_in">require</span> 函数引入模块，使用 <span class="variable language_">module</span>.<span class="property">exports</span></span><br><span class="line">导出模块。<span class="title class_">CommonJS</span> 是同步的，因为在服务器端，文件可以直接从本地磁盘加载。</span><br><span class="line"><span class="number">4</span>、<span class="variable constant_">ES</span> <span class="title class_">Module</span></span><br><span class="line">  <span class="variable constant_">ESM</span> 是 <span class="title class_">ECMAScript</span> 规范中的官方模块化标准，支持浏览器和 <span class="title class_">Node</span>.<span class="property">js</span>。</span><br><span class="line">  在 <span class="variable constant_">ESM</span> 中，模块是静态的，即模块加载时会提前解析，导入的模块在编译时已经确定。</span><br><span class="line">  </span><br><span class="line">【<span class="variable constant_">ESM</span> vs <span class="title class_">CommonJS</span> 对比】：</span><br><span class="line"><span class="comment">// 1、导入导出机制:</span></span><br><span class="line"><span class="title class_">CommonJS</span>: 动态导入，导出的是一个对象，模块在运行时加载。</span><br><span class="line"><span class="attr">ESM</span>: 静态导入，导入的模块在编译时就确定，并且可以使用 tree-shaking 优化未使用的代码。</span><br><span class="line"><span class="comment">// 2、同步 vs 异步:</span></span><br><span class="line"><span class="title class_">CommonJS</span>: 同步加载模块，适用于服务器端环境。</span><br><span class="line"><span class="attr">ESM</span>: 支持异步加载，适用于浏览器环境，特别是需要从网络异步加载资源时。</span><br></pre></td></tr></table></figure>
<h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>箭头函数、解构赋值、模板字符串、promise</span><br><span class="line"><span class="number">5.</span><span class="title class_">Symbol</span> - 基本数据类型，表示一个独一无二的值，不能与其他数据类型进行运算</span><br><span class="line"><span class="number">6.</span><span class="keyword">let</span>和<span class="keyword">const</span> - 变量声明方式</span><br><span class="line"><span class="number">7.</span>模块化 - 根据功能封装模块，<span class="keyword">import</span>导入，<span class="keyword">export</span>导出，也可以使用<span class="keyword">export</span> <span class="keyword">default</span>导出</span><br><span class="line"><span class="number">8.</span><span class="keyword">for</span>…<span class="keyword">of</span> 循环 - 用于遍历可迭代对象(如数组、<span class="title class_">Map</span> 和 <span class="title class_">Set</span>)中的元素</span><br><span class="line"><span class="number">9.</span>展开运算符 - 用...表示，将数组或者对象进行展开</span><br><span class="line"><span class="number">10.</span><span class="title class_">Map</span> 和 <span class="title class_">Set</span> - 数据结构，分别用于存储 键值对 和 唯一值</span><br><span class="line"><span class="number">11.</span><span class="title class_">Proxy</span> - 允许在对象和函数调用等操作前后添加自定义的行为</span><br><span class="line"><span class="number">12.</span>类（<span class="title class_">Class</span>） - 引入了面向对象编程中类的概念</span><br><span class="line"><span class="number">13.</span>默认参数（<span class="title class_">Default</span> <span class="title class_">Parameter</span>） - 在定义函数时可以给参数设置默认值</span><br><span class="line"></span><br><span class="line">新数组方法：</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>()、<span class="title class_">Array</span>.<span class="title function_">of</span>()、find、findIndex、fill、keys、values</span><br></pre></td></tr></table></figure>
<h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 事件触发三阶段：</span><br><span class="line">● 事件从最顶层元素（<span class="variable language_">window</span>）开始向目标元素的路径传播 <span class="comment">// 捕获阶段：事件从父元素向子元素传播</span></span><br><span class="line">● 事件到达目标元素，事件的目标是用户实际操作的元素 <span class="comment">// 目标阶段</span></span><br><span class="line">● 事件从目标元素向上传播，直到最顶层元素 <span class="comment">// 冒泡阶段：事件从子元素冒泡回到父元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 注册事件</span><br><span class="line"><span class="variable constant_">JS</span> 中使用 <span class="title function_">addEventListener</span>() 来为元素添加事件监听器。该方法允许指定事件处理的阶段：捕获阶段或冒泡阶段。</span><br><span class="line"><span class="comment">// element.addEventListener(type, listener, options);</span></span><br><span class="line"><span class="attr">type</span>: 事件类型，比如 click、keyup 等。</span><br><span class="line"><span class="attr">listener</span>: 事件触发时执行的回调函数。</span><br><span class="line"><span class="attr">options</span>:</span><br><span class="line">  <span class="attr">capture</span>: 如果为 <span class="literal">true</span>，事件在捕获阶段触发；为 <span class="literal">false</span>（默认），在冒泡阶段触发。</span><br><span class="line">  <span class="attr">once</span>: 如果为 <span class="literal">true</span>，事件处理器在调用后自动移除。</span><br><span class="line">  <span class="attr">passive</span>: 如果为 <span class="literal">true</span>，表示不会调用 <span class="title function_">preventDefault</span>() 阻止默认行为。</span><br><span class="line">- 若希望事件只触发在目标上，可使用 event.<span class="title function_">stopPropagation</span>() 来阻止事件冒泡阶段的传播</span><br><span class="line">- 防止默认行为（如阻止表单提交、链接跳转）：event.<span class="title function_">preventDefault</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 事件代理(委托)</span><br><span class="line">若一个节点中的子节点是动态生成的（例如ul中的li），把子节点的事件注册在父节点上。</span><br><span class="line">它利用事件冒泡机制，只在一个父元素上添加事件监听器，而不是为每个子元素都添加事件监听器。</span><br><span class="line">优点：减少内存消耗和事件绑定操作</span><br><span class="line"></span><br><span class="line">【target和currentTarget区别】：</span><br><span class="line"><span class="number">1</span>、target 是事件的实际触发目标，即用户最初点击或触发事件的那个 <span class="variable constant_">DOM</span> 元素。无论事件冒泡</span><br><span class="line">到哪里，target 始终指向最初发生事件的那个元素。<span class="comment">// 事件的最初触发元素（用户操作的元素）</span></span><br><span class="line"><span class="number">2</span>、currentTarget 是事件当前正在处理的元素，即事件监听器所绑定的那个元素。在事件的冒泡</span><br><span class="line">或捕获阶段，事件会经过多个元素，而 currentTarget 会指向当前正在处理事件的那个元素。</span><br><span class="line"><span class="comment">// 绑定事件处理器的元素</span></span><br><span class="line"></span><br><span class="line">事件循环event</span><br><span class="line">执行全局代码 --&gt; 异步任务（定时器、网络请求） --&gt; 异步回调放入消息队列</span><br><span class="line">异步任务放入调用栈   定时器、网络请求放入<span class="title class_">Web</span> <span class="variable constant_">API</span></span><br><span class="line"></span><br><span class="line">单线程：同一时间只能执行一个任务 -&gt; 一个任务时间过长--阻塞后续 -- promise/<span class="keyword">async</span>、<span class="keyword">await</span></span><br></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">● 箭头函数中没有 <span class="variable language_">arguments</span>，可以使用 ...args 代替</span><br><span class="line">● 箭头函数没有 prototype 属性，不能进行 <span class="keyword">new</span> 实例化</span><br><span class="line">● 箭头函数不能通过 call、apply 等绑定 <span class="variable language_">this</span>，因为箭头函数底层是使用bind永久绑定<span class="variable language_">this</span></span><br><span class="line">了，bind绑定过的<span class="variable language_">this</span>不能修改</span><br><span class="line">● 箭头函数的<span class="variable language_">this</span>指向创建时父级的<span class="variable language_">this</span></span><br><span class="line">● 箭头函数不能使用<span class="keyword">yield</span>关键字，不能作为<span class="title class_">Generator</span>函数</span><br><span class="line">不适用的场景：对象方法、对象原型、构造函数、动态上下文的回调函数、vue的生命周期和method</span><br></pre></td></tr></table></figure>
<h3 id="let、const、var区别"><a href="#let、const、var区别" class="headerlink" title="let、const、var区别"></a>let、const、var区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）块级作用域： <span class="keyword">let</span>和<span class="keyword">const</span>具有块级作用域，<span class="keyword">var</span>不存在块级作用域。</span><br><span class="line"><span class="number">2</span>）变量提升： <span class="keyword">var</span>存在变量提升，<span class="keyword">let</span>和<span class="keyword">const</span>不存在变量提升（变量只能在声明之后使用）。</span><br><span class="line"><span class="number">3</span>）给全局添加属性： 浏览器的全局对象是<span class="variable language_">window</span>，<span class="title class_">Node</span>的全局对象是<span class="variable language_">global</span>。</span><br><span class="line"><span class="keyword">var</span>声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但<span class="keyword">let</span>和<span class="keyword">const</span>不会。</span><br><span class="line"><span class="number">4</span>）重复声明： <span class="keyword">var</span>声明变量时，可以重复声明，后声明的同名变量会覆盖之前声明的。</span><br><span class="line"><span class="keyword">const</span>和<span class="keyword">let</span>不允许。</span><br><span class="line"><span class="number">5</span>）暂时性死区： 在使用<span class="keyword">let</span>、<span class="keyword">const</span>命令声明变量之前，该变量都是不可用的。</span><br><span class="line">这在语法上，称为暂时性死区。使用<span class="keyword">var</span>声明的变量不存在暂时性死区。</span><br><span class="line"><span class="number">6</span>）初始值设置： 变量声明时，<span class="keyword">var</span> 和 <span class="keyword">let</span> 可不用设置初始值。而<span class="keyword">const</span>必须设置。</span><br><span class="line"><span class="number">7</span>）指针指向： <span class="keyword">let</span>创建的变量是可以更改指针指向（重新赋值）。但<span class="keyword">const</span>是不允许的。</span><br></pre></td></tr></table></figure>
<h3 id="和"><a href="#和" class="headerlink" title="==和==="></a><code>==</code>和<code>===</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">等于操作符（==）：</span><br><span class="line">	在比较中会先进行类型转换，再确定操作数是否相等。如果操作数相等，则会返回 <span class="literal">true</span>。</span><br><span class="line">	<span class="number">1</span>、两个都为简单类型，字符串和布尔值都会转换成数值，再比较</span><br><span class="line">	<span class="number">2</span>、简单类型与引用类型比较，对象转化成其原始类型的值，再比较</span><br><span class="line">	<span class="number">3</span>、两个都为引用类型，则比较它们是否指向同一个对象</span><br><span class="line">	<span class="number">4</span>、<span class="literal">null</span> 和 <span class="literal">undefined</span> 相等</span><br><span class="line">	<span class="number">5</span>、存在 <span class="title class_">NaN</span> 则返回 <span class="literal">false</span></span><br><span class="line">全等操作符（===）：</span><br><span class="line">	只有两个操作数在不转换的前提下相等才返回 <span class="literal">true</span>。即类型相同，值也需相同</span><br><span class="line">【区别】：</span><br><span class="line">	相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换</span><br><span class="line">	<span class="literal">null</span> 和 <span class="literal">undefined</span> 比较，相等操作符（==）为<span class="literal">true</span>，全等为<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="数组原生方法"><a href="#数组原生方法" class="headerlink" title="数组原生方法"></a>数组原生方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、数组和【字符串】的转换方法：<span class="title function_">toString</span>()、<span class="title function_">toLocalString</span>()、<span class="title function_">join</span>() </span><br><span class="line">其中 <span class="title function_">join</span>() 方法可以指定转换为字符串时的分隔符。</span><br><span class="line"><span class="number">2</span>、数组【尾部】操作的方法 <span class="title function_">pop</span>() 和 <span class="title function_">push</span>()，push 方法可以传入多个参数。</span><br><span class="line"><span class="number">3</span>、数组【首部】操作的方法 <span class="title function_">shift</span>() 和 <span class="title function_">unshift</span>() </span><br><span class="line">重排序的方法 <span class="title function_">reverse</span>() 和 <span class="title function_">sort</span>()，<span class="title function_">sort</span>() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</span><br><span class="line"><span class="number">4</span>、数组连接的方法 <span class="title function_">concat</span>() ，返回的是拼接好的数组，不影响原数组。</span><br><span class="line"><span class="number">5</span>、数组截取办法 <span class="title function_">slice</span>()，用于截取数组中的一部分返回，不影响原数组。</span><br><span class="line"><span class="number">6</span>、数组插入方法 <span class="title function_">splice</span>()，影响原数组查找特定项的索引的方法，<span class="title function_">indexOf</span>() 和 <span class="title function_">lastIndexOf</span>() 迭代方法 <span class="title function_">every</span>()、<span class="title function_">some</span>()、<span class="title function_">filter</span>()、<span class="title function_">map</span>() 和 <span class="title function_">forEach</span>() 方法</span><br><span class="line"><span class="number">7</span>、数组归并方法 <span class="title function_">reduce</span>() 和 <span class="title function_">reduceRight</span>() 方法</span><br><span class="line"></span><br><span class="line">【js数组去重】</span><br><span class="line"><span class="number">1</span>、<span class="title class_">Set</span></span><br><span class="line"><span class="number">2</span>、filter</span><br><span class="line"><span class="number">3</span>、reduce</span><br><span class="line"><span class="number">4</span>、<span class="keyword">for</span>循环+indexOf方法</span><br><span class="line"><span class="number">5</span>、<span class="title class_">Map</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历数组对象"><a href="#遍历数组对象" class="headerlink" title="遍历数组对象"></a>遍历数组对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【<span class="keyword">for</span> <span class="keyword">in</span>和<span class="keyword">for</span> <span class="keyword">of</span>的区别】：<span class="keyword">for</span>…<span class="keyword">in</span> 会遍历对象的整个原型链</span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span> 循环主要是为了遍历对象而生，不适用于遍历数组；<span class="keyword">for</span>...<span class="keyword">of</span> 循环可以用来遍历数组、类数组对象，字符串、<span class="title class_">Set</span>、<span class="title class_">Map</span> 以及 <span class="title class_">Generator</span> 对象。</span><br><span class="line"></span><br><span class="line">【forEach和map的区别】：都是用来遍历数组的</span><br><span class="line"><span class="title function_">forEach</span>()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，没有返回值；</span><br><span class="line"><span class="title function_">map</span>()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</span><br></pre></td></tr></table></figure>
<h3 id="JS中的this"><a href="#JS中的this" class="headerlink" title="JS中的this"></a>JS中的this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span> 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、以函数形式调用时， <span class="variable language_">this</span> 指向的是 <span class="variable language_">window</span>全局作用域（优先级最低）</span><br><span class="line"><span class="number">2</span>、以方法的形式调用时，<span class="variable language_">this</span> 指向的是调用方法的对象（优先级再次）</span><br><span class="line"><span class="number">3</span>、构造器形式调用时，如果一个函数用 <span class="keyword">new</span> 调用时，函数执行前会新创建一个对象，</span><br><span class="line"><span class="variable language_">this</span> 指向这个新创建的对象。（优先级最高）</span><br><span class="line"><span class="number">4</span>、 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 <span class="variable language_">this</span> 指向。</span><br><span class="line">其中 apply 方法接收两个参数：一个是 <span class="variable language_">this</span> 绑定的对象，一个是参数数组。</span><br><span class="line">call 方法接收的参数，第一个是 <span class="variable language_">this</span> 绑定的对象，后面的其余参数是传入函数执行的参数。</span><br><span class="line">bind 方法通过传入一个对象，返回一个 <span class="variable language_">this</span> 绑定了传入对象的新函数。这个函数的 <span class="variable language_">this</span> 指向除了使用 <span class="keyword">new</span> 时会被改变，其他情况下都不会改变。（优先级其次）</span><br><span class="line"></span><br><span class="line">箭头函数没有自己的 <span class="variable language_">this</span> ，它只会在自己作用域的上一层继承 <span class="variable language_">this</span> 。</span><br><span class="line">箭头函数的 <span class="variable language_">this</span> 和它的调用方式无关</span><br></pre></td></tr></table></figure>
<h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>操作符的执行过程：</span><br><span class="line">（<span class="number">1</span>）首先创建了一个新的空对象</span><br><span class="line">（<span class="number">2</span>）设置原型，将对象的原型设置为函数的 prototype 对象。</span><br><span class="line">（<span class="number">3</span>）让函数的 <span class="variable language_">this</span> 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span><br><span class="line">（<span class="number">4</span>）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</span><br></pre></td></tr></table></figure>
<h3 id="微任务宏任务"><a href="#微任务宏任务" class="headerlink" title="微任务宏任务"></a>微任务宏任务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">○ 宏任务：<span class="built_in">setTimeout</span> 、<span class="built_in">setInterval</span> 、<span class="variable constant_">DOM</span>事件、<span class="title class_">Ajax</span> </span><br><span class="line">○ 微任务：<span class="title class_">Promise</span>.<span class="property">then</span>、<span class="keyword">async</span>/<span class="keyword">await</span></span><br><span class="line">○ 微任务比宏任务执行的更早：宏任务：<span class="variable constant_">DOM</span> 渲染后再触发，微任务：<span class="variable constant_">DOM</span> 渲染前会触发</span><br></pre></td></tr></table></figure>
<h3 id="请求接口作用"><a href="#请求接口作用" class="headerlink" title="请求接口作用"></a>请求接口作用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取和更新服务器上的数据</span><br><span class="line">例如：</span><br><span class="line"><span class="number">1.</span> 获取列表数据</span><br><span class="line"><span class="number">2.</span> 创建、更新、删除数据</span><br><span class="line"><span class="number">3.</span> 文件上传和下载（上传头像、下载附件）</span><br><span class="line"><span class="number">4.</span> 需要实时数据的场景（在线聊天、股票详情）</span><br></pre></td></tr></table></figure>
<h3 id="BOM和DOM"><a href="#BOM和DOM" class="headerlink" title="BOM和DOM"></a>BOM和DOM</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="variable constant_">DOM</span>：文档对象模型。将 文档 转化为 树状结构</span><br><span class="line">每一个节点都是一个对象 -&gt; 可通过js脚本操作和修改这些对象</span><br><span class="line"><span class="number">2</span>、<span class="variable constant_">BOM</span>：浏览器对象模型。用于 与浏览器窗口进行交互，控制浏览器窗口和进行浏览器相关操作</span><br><span class="line">包含：<span class="variable language_">window</span>、navigator、location、history、screen</span><br><span class="line">获取和设置：浏览器窗口大小、位置、打开新窗口、导航历史记录</span><br><span class="line"></span><br><span class="line">【区别】：<span class="variable constant_">BOM</span> 用于与浏览器环境交互，而 <span class="variable constant_">DOM</span> 用于操作文档内容。</span><br><span class="line"></span><br><span class="line">【<span class="variable constant_">DOM</span>渲染 --- 阻塞渲染原因】</span><br><span class="line"><span class="number">1</span>、脚本执行 - 浏览器遇到script停止渲染、执行脚本</span><br><span class="line"><span class="number">2</span>、样式计算和布局 - 复杂的css选择器有大量样式计算</span><br><span class="line"><span class="number">3</span>、资源加载 - 需要下载的头部资源（图片、样式表、脚本）</span><br><span class="line"><span class="number">4</span>、<span class="title class_">JavaScript</span>执行 - 会修改<span class="variable constant_">DOM</span>结构和样式</span><br><span class="line"><span class="number">5</span>、渲染树的构建 - <span class="variable constant_">DOM</span>树 + css样式表</span><br><span class="line">优化策略：</span><br><span class="line"><span class="number">1</span>、异步加载脚本</span><br><span class="line"><span class="number">2</span>、压缩合并css和js文件</span><br><span class="line"><span class="number">3</span>、使用defer和<span class="keyword">async</span>属性，延迟脚本执行</span><br><span class="line"><span class="number">4</span>、css动画代替js动画</span><br><span class="line"><span class="number">5</span>、图片懒加载/按需加载</span><br></pre></td></tr></table></figure>
<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">伪类： :开头，选择文档中的【特定状态、特定元素】   例，:hover、:active、:focus</span><br><span class="line">伪元素： ::开头，元素的【特定部分】   例，::before、::first-line</span><br></pre></td></tr></table></figure>
<h2 id="HTTP和浏览器"><a href="#HTTP和浏览器" class="headerlink" title="HTTP和浏览器"></a>HTTP和浏览器</h2><h3 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a><strong>HTTP常见状态码</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1XX：信息状态码 2XX：成功状态码 3XX：重定向 4XX：客户端错误 5<span class="attr">XX</span>: 服务器错误</span><br><span class="line"><span class="number">200</span> <span class="variable constant_">OK</span>：请求成功，服务器返回所请求的数据。</span><br><span class="line"><span class="number">301</span> <span class="title class_">Moved</span> <span class="title class_">Permanently</span>：资源永久重定向，新的 <span class="variable constant_">URL</span> 在响应中给出。</span><br><span class="line"><span class="number">302</span> <span class="title class_">Found</span>：资源临时重定向，客户端应使用新的 <span class="variable constant_">URL</span> 继续请求。</span><br><span class="line"><span class="number">400</span> <span class="title class_">Bad</span> <span class="title class_">Request</span>：请求无效，服务器无法理解请求内容。</span><br><span class="line"><span class="number">401</span> <span class="title class_">Unauthorized</span>：未授权，需要提供认证信息。</span><br><span class="line"><span class="number">403</span> <span class="title class_">Forbidden</span>：服务器拒绝请求，客户端无权限访问资源。</span><br><span class="line"><span class="number">404</span> <span class="title class_">Not</span> <span class="title class_">Found</span>：资源未找到，服务器上不存在请求的资源。</span><br><span class="line"><span class="number">500</span> <span class="title class_">Internal</span> <span class="title class_">Server</span> <span class="title class_">Error</span> 服务器内部错误，无法处理请求。</span><br><span class="line"><span class="number">502</span> <span class="title class_">Bad</span> <span class="title class_">Gateway</span></span><br><span class="line"><span class="number">503</span> <span class="title class_">Service</span> <span class="title class_">Unavailable</span> 服务器暂时不可用，可能是因为过载或维护。</span><br><span class="line"><span class="number">504</span> <span class="title class_">Gateway</span> <span class="title class_">Timeout</span>网关超时</span><br></pre></td></tr></table></figure>
<h3 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【三次握手】：建立tcp连接的过程,可以进行数据的传输</span><br><span class="line"><span class="number">1</span>、客户端向服务器发送一个<span class="variable constant_">SYN</span>包 <span class="variable constant_">SYN</span>=<span class="number">1</span>,<span class="variable constant_">ACK</span>=<span class="number">0</span>，这个包中包含客户端的初始序列号<span class="title function_">ISN</span>(c)。</span><br><span class="line">此步骤目的：向服务器请求建立连接。</span><br><span class="line"><span class="number">2</span>、服务器收到<span class="variable constant_">SYN</span>包后，回复一个<span class="variable constant_">SYN</span>+<span class="variable constant_">ACK</span>包。标记为<span class="variable constant_">SYN</span>=<span class="number">1</span>,<span class="variable constant_">ACK</span>=<span class="number">1</span>。</span><br><span class="line">包中包含了服务器的初始序列号<span class="title function_">ISN</span>(c)，并对客户端的<span class="variable constant_">SYN</span>进行确认，确认号：<span class="variable constant_">ACK</span>=<span class="title function_">ISN</span>(c)+<span class="number">1</span>。</span><br><span class="line"><span class="number">3</span>、客户端收到<span class="variable constant_">SYN</span>+<span class="variable constant_">ACK</span>包后，回复一个<span class="variable constant_">ACK</span>包作最后确认。标记为<span class="variable constant_">SYN</span>=<span class="number">0</span>,<span class="variable constant_">ACK</span>=<span class="number">1</span></span><br><span class="line">这个<span class="variable constant_">ACK</span>包中包含了对服务器<span class="variable constant_">SYN</span>的确认。确认号：<span class="variable constant_">ACK</span>=<span class="title function_">ISN</span>(c)+<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">【四次挥手】：断开连接的过程</span><br><span class="line"><span class="number">1</span>、客户端发送一个<span class="variable constant_">FIN</span>包给服务器，标记为<span class="variable constant_">FIN</span>=<span class="number">1</span>,<span class="variable constant_">ACK</span>=<span class="number">0</span>。</span><br><span class="line">表示已完成数据的发送，并希望关闭连接。</span><br><span class="line"><span class="number">2</span>、服务器收到客户端的<span class="variable constant_">FIN</span>包后，回复一个<span class="variable constant_">ACK</span>包作为确认。标记为<span class="variable constant_">ACK</span>=<span class="number">1</span> 确认号<span class="variable constant_">ACK</span>=客户端序号+<span class="number">1</span>。</span><br><span class="line">此时客户端不再发送数据，但服务器仍可发送数据（连接处于半关闭状态）。</span><br><span class="line"><span class="number">3</span>、服务器继续发送一个<span class="variable constant_">FIN</span>包给客户端。标记为<span class="variable constant_">FIN</span>=<span class="number">1</span>,<span class="variable constant_">ACK</span>=<span class="number">0</span>。</span><br><span class="line"><span class="number">4</span>、客户端收到<span class="variable constant_">FIN</span>包回复一个<span class="variable constant_">ACK</span>包，作为最后的确认。标记为<span class="variable constant_">ACK</span>=<span class="number">1</span> 确认号<span class="variable constant_">ACK</span>=客户端序号+<span class="number">1</span>。</span><br><span class="line">至此，<span class="variable constant_">TCP</span>连接被完全关闭。</span><br><span class="line"></span><br><span class="line">【需要四次挥手原因】</span><br><span class="line">服务端在收到客户端断开连接<span class="title class_">Fin</span>报文后，并不会立即关闭连接，而是先发送一个<span class="variable constant_">ACK</span>包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送<span class="variable constant_">FIN</span>报文断开连接，因此需要四次挥手</span><br></pre></td></tr></table></figure>
<h3 id="TCP请求头报文头"><a href="#TCP请求头报文头" class="headerlink" title="TCP请求头报文头"></a>TCP请求头报文头</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">请求头：</span><br><span class="line"><span class="number">1</span>、源端口号：发送端口号</span><br><span class="line"><span class="number">2</span>、目的端口号：接收端口号</span><br><span class="line"><span class="number">3</span>、序列号：本次传输的数据段序号</span><br><span class="line"><span class="number">4</span>、确认号：期待接收的下一个数据段序号</span><br><span class="line"><span class="number">5</span>、数据偏移量：<span class="variable constant_">TCP</span>头部长度</span><br><span class="line"><span class="number">6</span>、保留位：保留为<span class="number">0</span></span><br><span class="line"><span class="number">7</span>、控制位：标识<span class="variable constant_">TCP</span>的连接状态</span><br><span class="line"><span class="number">8</span>、窗口大小：接收方可接收的数据量</span><br><span class="line"><span class="number">9</span>、校验位：校验<span class="variable constant_">TCP</span>头部和数据的完整性</span><br><span class="line"><span class="number">10</span>、紧急指针：紧急数据的位置</span><br><span class="line"><span class="number">11</span>、用于控制和管理<span class="variable constant_">TCP</span>连接的建立、数据传输和断开，提供一些可选的功能和优化选项</span><br><span class="line"></span><br><span class="line">报文头：</span><br><span class="line"><span class="number">1</span>、源<span class="variable constant_">IP</span>地址：发送方<span class="variable constant_">IP</span>地址</span><br><span class="line"><span class="number">2</span>、目的<span class="variable constant_">IP</span>地址：接收方<span class="variable constant_">IP</span>地址</span><br><span class="line"><span class="number">3</span>、协议类型：上层协议类型，<span class="variable constant_">TCP</span>为<span class="number">6</span></span><br><span class="line"><span class="number">4</span>、<span class="variable constant_">IP</span>头部长度：</span><br><span class="line"><span class="number">5</span>、服务类型</span><br><span class="line"><span class="number">6</span>、标识：数据包唯一标识</span><br><span class="line"><span class="number">7</span>、标志：数据包状态</span><br><span class="line"><span class="number">8</span>、偏移：数据包在原始数据中的位置</span><br><span class="line"><span class="number">9</span>、生存时间</span><br><span class="line"><span class="number">10</span>、协议校验和：校验<span class="variable constant_">IP</span>头部和数据的完整性</span><br></pre></td></tr></table></figure>
<h3 id="储存"><a href="#储存" class="headerlink" title="储存"></a>储存</h3><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
<th>indexDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>除非被清理，否则一直存在</td>
<td>页面关闭就清理</td>
<td>除非被清理，否则一直存在</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>4KB</td>
<td>5M</td>
<td>5M</td>
<td>无限</td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在header中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有几种方式可以实现存储功能，分别有什么优缺点？什么是 Service Worker？</span></span><br><span class="line">cookie 已不建议用于存储。若没有大量数据存储需求，可使用 <span class="variable language_">localStorage</span>/<span class="variable language_">sessionStorage</span> 对于不怎么改变的数据尽量使用 <span class="variable language_">localStorage</span> 存储。</span><br><span class="line"><span class="number">1</span>、【cookie】</span><br><span class="line">value - 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</span><br><span class="line">http-only - 不能通过 <span class="variable constant_">JS</span> 访问 <span class="title class_">Cookie</span>，减少 <span class="variable constant_">XSS</span> 攻击</span><br><span class="line">secure - 只能在协议为 <span class="variable constant_">HTTPS</span> 的请求中携带</span><br><span class="line">same-site - 规定浏览器不能在跨域请求中携带 <span class="title class_">Cookie</span>，减少 <span class="variable constant_">CSRF</span> 攻击</span><br><span class="line"><span class="number">2</span>、【<span class="title class_">Service</span> <span class="title class_">Worker</span>】</span><br><span class="line">● <span class="title class_">Service</span> <span class="title class_">Worker</span> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</span><br><span class="line">使用 <span class="title class_">Service</span> <span class="title class_">Worker</span>的话，传输协议必须为 <span class="variable constant_">HTTPS</span>。</span><br><span class="line">因为 <span class="title class_">Service</span> <span class="title class_">Worker</span> 中涉及到请求拦截，所以必须使用 <span class="variable constant_">HTTPS</span> 协议来保障安全</span><br><span class="line">● <span class="title class_">Service</span> <span class="title class_">Worker</span> 实现缓存功能一般分为三个步骤：首先需要先注册 <span class="title class_">Service</span> <span class="title class_">Worker</span>，然后监</span><br><span class="line">听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的</span><br><span class="line">方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</span><br><span class="line"></span><br><span class="line">【记录用户状态、信息】：</span><br><span class="line">cookie：保存在客户端浏览器</span><br><span class="line"> 服务器自动发给浏览器   很多浏览器限制一个站点最多保存<span class="number">20</span>个cookie</span><br><span class="line">session：保存在服务器 -- 依据cookie识别用户</span><br><span class="line"> 安全性⬆ 大小原则上无限制 <span class="title function_">sessionID</span>(第一次访问服务器生成)存在cookie</span><br></pre></td></tr></table></figure>
<h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">数据请求：网络请求 -&gt; 后端处理 -&gt; 浏览器响应</span><br><span class="line"><span class="number">1.</span> 缓存位置</span><br><span class="line">分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络</span><br><span class="line"><span class="title class_">Service</span> <span class="title class_">Worker</span> -&gt; <span class="title class_">Memory</span> <span class="title class_">Cache</span> -&gt; <span class="title class_">Disk</span> <span class="title class_">Cache</span> -&gt; <span class="title class_">Push</span> <span class="title class_">Cache</span> -&gt; 网络请求</span><br><span class="line"><span class="number">2</span>、缓存策略</span><br><span class="line">通常分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 <span class="variable constant_">HTTP</span> <span class="title class_">Header</span> 来实现的</span><br><span class="line"><span class="number">2.1</span> 强缓存</span><br><span class="line">强缓存可通过设置两种 <span class="variable constant_">HTTP</span> <span class="title class_">Header</span> 实现：<span class="title class_">Expires</span> 和 <span class="title class_">Cache</span>-<span class="title class_">Control</span> 。</span><br><span class="line">强缓存表示在缓存期间不需要请求，state code 为 <span class="number">200</span></span><br><span class="line"><span class="number">2.2</span> 协商缓存</span><br><span class="line">● 如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 <span class="variable constant_">HTTP</span> <span class="title class_">Header</span> 实现：<span class="title class_">Last</span>-<span class="title class_">Modified</span> 和 <span class="title class_">ETag</span></span><br><span class="line">● 当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 <span class="number">304</span> 状态码，并且更新浏览器缓存有效期。</span><br><span class="line"></span><br><span class="line">优点：提升页面加载速度、减少带宽消耗、减轻服务器压力</span><br></pre></td></tr></table></figure>
<h3 id="从输入URL-到网页显示的完整过程"><a href="#从输入URL-到网页显示的完整过程" class="headerlink" title="从输入URL 到网页显示的完整过程"></a>从输入URL 到网页显示的完整过程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、网络请求：</span><br><span class="line">  <span class="variable constant_">DNS</span>查询（得到<span class="variable constant_">IP</span>)，建立<span class="variable constant_">TCP</span>连接（三次握手）-&gt; 浏览器发送<span class="variable constant_">HTTP</span>请求 -&gt; 收到请求响应，得到<span class="variable constant_">HTML</span>源码。继续请求静态资源</span><br><span class="line"><span class="number">2</span>、解析：字符串 =&gt; 结构化数据（<span class="variable constant_">HTML</span>构建<span class="variable constant_">DOM</span>树 -&gt; renter tree）</span><br><span class="line"><span class="number">3</span>、渲染：<span class="title class_">Render</span> <span class="title class_">Tree</span>绘制到页面</span><br><span class="line">  ○ 计算<span class="variable constant_">DOM</span>的尺寸、定位，最后绘制到页面</span><br><span class="line">  ○ 遇到<span class="variable constant_">JS</span>会执行，阻塞<span class="variable constant_">HTML</span>解析。如果设置了defer，则并行下载<span class="variable constant_">JS</span>，等待<span class="variable constant_">HTML</span>解析完，在执行<span class="variable constant_">JS</span>；如果设置了<span class="keyword">async</span>，则并行下载<span class="variable constant_">JS</span>，下载完立即执行，在继续解析<span class="variable constant_">HTML</span>（<span class="variable constant_">JS</span>是单线程的，<span class="variable constant_">JS</span>执行和<span class="variable constant_">DOM</span>渲染互斥，等<span class="variable constant_">JS</span>执行完，在解析渲染<span class="variable constant_">DOM</span>）</span><br><span class="line">  ○ 异步<span class="variable constant_">CSS</span>、异步图片，可能会触发重新渲染</span><br><span class="line">  </span><br><span class="line">【连环问：网页重绘repaint和重排reflow有什么区别】</span><br><span class="line">● 重绘</span><br><span class="line">  ○ 元素外观改变：如颜色、背景色</span><br><span class="line">  ○ 但元素的尺寸、定位不变，不会影响其他元素的位置</span><br><span class="line">● 重排</span><br><span class="line">  ○ 重新计算尺寸和布局，可能会影响其他元素的位置</span><br><span class="line">  ○ 如元素高度的增加，可能会使相邻的元素位置改变</span><br><span class="line">  ○ 重排必定触发重绘，重绘不一定触发重排。重绘的开销较小，重排的代价较高。</span><br><span class="line">  ○ 减少重排的方法</span><br><span class="line">    ■ 使用<span class="variable constant_">BFC</span>特性，不影响其他元素位置</span><br><span class="line">    ■ 频繁触发（resize、scroll）使用节流和防抖</span><br><span class="line">    ■ 使用createDocumentFragment批量操作<span class="variable constant_">DOM</span></span><br></pre></td></tr></table></figure>
<h3 id="常见的web前端攻击方式"><a href="#常见的web前端攻击方式" class="headerlink" title="常见的web前端攻击方式"></a>常见的web前端攻击方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">XSS - Cross Site Script 跨站脚本攻击</span><br><span class="line"> - 手段：黑客将JS代码插入到网页内容中，渲染时执行JS代码</span><br><span class="line"> - 预防：特殊字符串替换（前端或后端）</span><br><span class="line">CSRF - Cross Site Request Forgery 跨站请求伪造</span><br><span class="line"> ● 手段：黑盒诱导用户去访问另一个网站的接口，伪造请求</span><br><span class="line"> ● 预防：严格的跨域限制 + 验证码机制</span><br><span class="line"> 注意：偷取cookie是XSS做的事，CSRF的作用是借用cookie，并不能获取cookie</span><br><span class="line">DDOS - Distribute denial-of-service 分布式拒绝服务</span><br><span class="line"> ● 手段：分布式的大规模的流量访问，使服务器瘫痪</span><br><span class="line"> ● 预防：软件层不好做，需硬件预防（如阿里云的WAF 购买高防）</span><br><span class="line">SQL注入</span><br><span class="line"> ● 手段：黑客提交内容时，写入sql语句，破坏数据库</span><br><span class="line"> ● 预防：处理内容的输入，替换特殊字符</span><br></pre></td></tr></table></figure>
<h3 id="跨域方案"><a href="#跨域方案" class="headerlink" title="跨域方案"></a>跨域方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">浏览器出于安全考虑，有同源策略。即，如果协议、域名、端口有不同就是跨域，<span class="title class_">Ajax</span> 请求会失败</span><br><span class="line"><span class="number">1</span>、<span class="title class_">JSON</span>P</span><br><span class="line"> 利用 &lt;script&gt; 标签没有跨域限制的漏洞。</span><br><span class="line"> 通过 &lt;script&gt; 标签指向一个需要访问的地址并提供一个回调函数来接收数据</span><br><span class="line"> <span class="title class_">JSON</span>P 使用简单且兼容性不错，但是【只限于 get 请求】</span><br><span class="line"><span class="number">2</span>、<span class="variable constant_">CORS</span> - 目前最广泛的解决跨域问题的方案。</span><br><span class="line"> 方案依赖服务端/后端在响应头中添加 <span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-* 头，告知浏览器端通过此请求</span><br><span class="line"> <span class="variable constant_">CORS</span> 的实现只需要增加一些 <span class="variable constant_">HTTP</span> 头，让服务器能声明允许的访问来源。</span><br><span class="line"> 只要后端实现了 <span class="variable constant_">CORS</span>，就实现了跨域</span><br><span class="line"><span class="number">3</span>、nginx反向代理</span><br><span class="line"> nginx 配置跨域，可以为全局配置和单个代理配置（两者不能同时配置）</span><br><span class="line"> 【全局配置】：在nginx.<span class="property">conf</span>文件中的 http 节点加入跨域信息</span><br><span class="line"> 【局部配置（单个代理配置跨域）】： 在路径匹配符中加入跨域信息</span><br><span class="line"> <span class="number">4</span>、<span class="title class_">Node</span> 中间层接口转发</span><br><span class="line"> <span class="number">5</span>、<span class="title class_">Proxy</span></span><br><span class="line"> 若是通过vue-cli脚手架工具搭建项目，可通过webpack起一个本地服务器作为请求的代理对象</span><br><span class="line"> 通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用</span><br><span class="line"> 和接口服务器不在一起仍会跨域</span><br><span class="line"> <span class="number">6</span>、websocket</span><br><span class="line"> webSocket本身不存在跨域问题，可以利用webSocket来进行非同源之间的通信</span><br><span class="line"> 【原理】：利用webSocket的<span class="variable constant_">API</span>，可直接<span class="keyword">new</span>一个socket实例，然后通过open方法内send要传输</span><br><span class="line">  到后台的值，也可以利用message方法接收后台传来的数据。后台是通过<span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123;<span class="attr">port</span>:<span class="number">3000</span>&#125;)</span><br><span class="line">  实例，利用message接收数据，利用send向客户端发送数据。</span><br></pre></td></tr></table></figure>
<h3 id="实现网页多标签tab通讯"><a href="#实现网页多标签tab通讯" class="headerlink" title="实现网页多标签tab通讯"></a>实现网页多标签tab通讯</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、通过websocket：无跨域限制，需要服务端支持，成本高</span><br><span class="line"><span class="number">2</span>、通过<span class="variable language_">localStorage</span>同域通讯（推荐）√</span><br><span class="line">  同域的A和B两个页面，A页面设置<span class="variable language_">localStorage</span>，B页面可监听到<span class="variable language_">localStorage</span>值的修改</span><br><span class="line"><span class="number">3</span>、通过<span class="title class_">SharedWorker</span>通讯</span><br><span class="line">  ○ <span class="title class_">SharedWorker</span>是<span class="title class_">WebWorker</span>的一种</span><br><span class="line">  ○ <span class="title class_">WebWorker</span>可开启子进程执行<span class="variable constant_">JS</span>，但不能操作<span class="variable constant_">DOM</span></span><br><span class="line">  ○ <span class="title class_">SharedWorker</span>可单独开启一个进程，用于同域页面通讯</span><br><span class="line">  ○ <span class="title class_">SharedWorker</span>兼容性不太好，调试不方便，<span class="title class_">IE11</span>不支持</span><br></pre></td></tr></table></figure>
<h3 id="如何提高前端页面性能"><a href="#如何提高前端页面性能" class="headerlink" title="如何提高前端页面性能"></a>如何提高前端页面性能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 减少 <span class="variable constant_">HTTP</span> 请求：减少静态资源的请求次数，可通过使用 <span class="variable constant_">CSS</span> <span class="title class_">Sprites</span>、合并<span class="variable constant_">JS</span>和 <span class="variable constant_">CSS</span> 文件等手段实现。</span><br><span class="line"><span class="number">2.</span> 压缩文件大小：压缩 <span class="title class_">JavaScript</span>、<span class="variable constant_">CSS</span> 和图片等文件，可有效减小文件大小，加快下载速度。</span><br><span class="line"><span class="number">3.</span> 避免重复加载：避免重复加载相同的文件或资源，可以通过浏览器缓存、<span class="variable constant_">HTTP</span> 缓存和服务端缓存等手段来实现。</span><br><span class="line"><span class="number">4.</span> 异步加载资源：延迟加载非关键资源，可以通过懒加载和异步加载等手段来实现。</span><br><span class="line"><span class="number">5.</span> 减少 <span class="variable constant_">DOM</span> 操作：减少不必要的 <span class="variable constant_">DOM</span> 操作，可通过避免多次查询 <span class="variable constant_">DOM</span> 元素、使用文档片段、事件委托等手段来实现。</span><br><span class="line"><span class="number">6.</span> 优化 <span class="variable constant_">CSS</span> 选择器：避免使用过于复杂的 <span class="variable constant_">CSS</span> 选择器，可以通过简化选择器、使用 <span class="variable constant_">ID</span> 选择器、避免使用通配符等手段来实现。</span><br><span class="line"><span class="number">7.</span> 使用 <span class="title class_">Web</span> <span class="title class_">Workers</span> 和 <span class="title class_">Service</span> <span class="title class_">Workers</span>：使用 <span class="title class_">Web</span> <span class="title class_">Workers</span> 和 <span class="title class_">Service</span> <span class="title class_">Workers</span> 可以将一些耗时的计算和 I/O 操作转移到后台线程中，避免阻塞主线程，提高页面响应速度。</span><br><span class="line"><span class="number">8.</span> 移动端优化：移动端页面的性能优化可以通过图片压缩、使用 <span class="title class_">CSS3</span> 动画代替 <span class="variable constant_">JS</span> 动画、避免使用 fixed 定位等手段来实现。</span><br></pre></td></tr></table></figure>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据包是信息传输的基本单位</span><br><span class="line">抓包：截取数据包、分析  --&gt;  获取其中的信息，调试网络问题</span><br><span class="line">工具：wireShark、<span class="title class_">Fiddler</span> ==&gt; 详细的数据包内容、协议信息、源和目标地址</span><br></pre></td></tr></table></figure>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化：<span class="title class_">Webpack</span> 读取配置文件（如 webpack.<span class="property">config</span>.<span class="property">js</span>），初始化项目设置。</span><br><span class="line">入口：指定入口文件（如 index.<span class="property">js</span>），<span class="title class_">Webpack</span> 从这里开始构建依赖图。</span><br><span class="line">模块解析：分析入口文件及其依赖，递归地解析每个模块（<span class="title class_">JavaScript</span>、<span class="variable constant_">CSS</span>、图片等）。</span><br><span class="line">加载器（<span class="title class_">Loaders</span>）：通过加载器处理不同类型的文件，比如将 <span class="title class_">ES6</span> 转换为 <span class="title class_">ES5</span>、将 <span class="title class_">Sass</span> 转换为 <span class="variable constant_">CSS</span> 等。</span><br><span class="line">插件（<span class="title class_">Plugins</span>）：在构建过程中使用插件进行更复杂的操作，比如压缩代码、提取 <span class="variable constant_">CSS</span>、生成 <span class="variable constant_">HTML</span> 文件等。</span><br><span class="line">输出：将处理后的文件打包到输出目录（如 dist 文件夹），生成最终的可用文件。</span><br><span class="line">监视（可选）：如果启用，<span class="title class_">Webpack</span> 可以在文件变化时自动重新构建，提升开发效率。</span><br></pre></td></tr></table></figure>
<h3 id="Vite-为什么快"><a href="#Vite-为什么快" class="headerlink" title="Vite 为什么快"></a>Vite 为什么快</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动快：</span><br><span class="line">【基于浏览器的原生 <span class="variable constant_">ES</span> 模块加载】：<span class="title class_">Vite</span> 不需要像 <span class="title class_">Webpack</span> 那样在启动时打包所有文件，它直接利用浏览器的原生支持来按需加载模块，因此不需要预先打包整个项目。</span><br><span class="line">【即时编译（依赖预构建）】：<span class="title class_">Vite</span> 只对项目的依赖进行一次性预编译，大大减少了构建时间，代码变化时只重新编译修改过的部分，避免了大规模重编译。</span><br><span class="line"></span><br><span class="line">打包快：</span><br><span class="line">【依赖预构建】：<span class="title class_">Vite</span> 在开发时只对项目中使用的依赖库（如第三方模块）进行预构建，避免每次更改代码都重新处理整个项目。</span><br><span class="line">【基于浏览器的模块加载】：<span class="title class_">Vite</span> 使用浏览器原生的 <span class="variable constant_">ES</span> 模块，按需加载文件，减少了打包时对模块的分析和打包工作，使得开发时不需要打包整个应用，速度更快。</span><br></pre></td></tr></table></figure>
<h3 id="微前端iframe"><a href="#微前端iframe" class="headerlink" title="微前端iframe"></a>微前端iframe</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">将前端应用划分为多个微服务，每个微服务负责一个特定的功能或页面</span><br><span class="line"></span><br><span class="line">【解决的问题】</span><br><span class="line"><span class="number">1</span>、大型前端应用的可维护性（对比单页应用）</span><br><span class="line"><span class="number">2</span>、多团队协作的效率</span><br><span class="line"><span class="number">3</span>、技术栈的灵活性（允许每个微服务，使用不同的技术栈）</span><br><span class="line">子工程以npm包的形式</span><br><span class="line"></span><br><span class="line">iframe --- 硬隔离的微前端解决方案 样式隔离，js隔离</span><br><span class="line">但隔离性无法突破：上下文无法共享、组件通信复杂</span><br><span class="line">不同域之间使用iframe的lacation.<span class="property">hash</span>传值，互相通信：<span class="title function_">postMessage</span>()方法</span><br><span class="line"></span><br><span class="line">将共享的资源放在一个基站应用管理，其他人可以快速引用</span><br></pre></td></tr></table></figure>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">分布式版本控制系统 - 多人协作并行开发</span><br><span class="line">分为：工作区、暂存区、本地仓库、远程仓库</span><br><span class="line"></span><br><span class="line">【 git pull 和 git fetch 】</span><br><span class="line">git pull 相当于 从远程仓库获取最新版本git fetch，然后再与本地分支merge合并，</span><br><span class="line">即git pull = git fetch + git merge</span><br><span class="line"></span><br><span class="line">【 git rebase 和 git merge】</span><br><span class="line">rebase：将一个分支的提交记录应用到另一个分支上，避免合并提交带来的冗余</span><br><span class="line"> git rebase &lt;目标分支&gt;  ----  提交到另一分支</span><br><span class="line"> git rebase -i &lt;目标分支&gt; ---- 修改提交历史</span><br><span class="line"></span><br><span class="line">【 git stach 】</span><br><span class="line">git stach  ---  临时存储代码修改（会把暂存区和工作区的改动进行保存）</span><br></pre></td></tr></table></figure>
<h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">路由前置守卫、路由后置守卫、解析守卫。</span><br><span class="line">作用：</span><br><span class="line">验证用户是否有权限访问某个路由</span><br><span class="line">检查用户是否已登录或其他功能</span><br></pre></td></tr></table></figure>
<h3 id="交接文件readme"><a href="#交接文件readme" class="headerlink" title="交接文件readme"></a>交接文件readme</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、项目概述：名称、目的、功能特点</span><br><span class="line"><span class="number">2</span>、安装指南：安装步骤、所需依赖项、环境配置</span><br><span class="line"><span class="number">3</span>、使用说明：运行步骤、配置文件示例</span><br><span class="line"><span class="number">4</span>、文件结构：各个文件的作用</span><br><span class="line"><span class="number">5</span>、示例和演示：代码示例、截图、链接</span><br><span class="line"><span class="number">6</span>、联系方式</span><br><span class="line"><span class="number">7</span>、版权和许可：开源许可证</span><br></pre></td></tr></table></figure>
<h3 id="文件上线流程"><a href="#文件上线流程" class="headerlink" title="文件上线流程"></a>文件上线流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、准备工具：选择合适的云服务器，安装<span class="title class_">FinalShell</span>或其它服务器管理工具</span><br><span class="line"><span class="number">2</span>、服务器设置：首先连接云服务器需要重置实例密码，然后配置安全组规则（开启常用端口）</span><br><span class="line"><span class="number">3</span>、项目打包及部署：</span><br><span class="line"> <span class="number">1.</span> 使用 npm run build 命令打包，打包成功后，原项目文件会产生一个 dist文件夹</span><br><span class="line"> <span class="number">2.</span> 连接到云服务器，打开<span class="title class_">FinalShell</span>新建连接，输入服务器公网地址，协议默认，端口选择<span class="number">22</span>，然后点击连接，输入用户名密码</span><br><span class="line"> <span class="number">3.</span> 上传项目文件，将打包好的静态资源文件上传到云服务器上的合适目录</span><br><span class="line">  更新系统：sudo yum update  安装<span class="title class_">Nodejs</span>：sudo yum install -y nodejs</span><br><span class="line"> <span class="number">4.</span> 配置服务器：根据项目需要配置服务器。例如设置<span class="title class_">Nginx</span>反向代理、配置域名等</span><br></pre></td></tr></table></figure>
<h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><h3 id="instanceof-方法"><a href="#instanceof-方法" class="headerlink" title="instanceof 方法"></a>instanceof 方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left); <span class="comment">// 获取对象left原型</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 获取目标构造函数right原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 到达原型链顶端仍未找到目标原型，则返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到目标原型，则返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto); <span class="comment">// 继续查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(p, <span class="title class_">Person</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖：处理频繁触发的事件。函数被连续调用时，只执行最后一次调用。（输入框搜索、窗口调整、按钮点击）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer); <span class="comment">//每一次时间清空，重新计时</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流：限制事件的触发频率，规定时间间隔只执行一次相应操作。（页面滚动、鼠标移动）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浅拷贝和浅拷贝"><a href="#浅拷贝和浅拷贝" class="headerlink" title="浅拷贝和浅拷贝"></a>浅拷贝和浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      newObj[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">//查看要拷贝的对象是数组还是对象，如果数组创建空数组，是对象创建空对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// K属性名  obj[k]值</span></span><br><span class="line">    <span class="comment">//判断当前每个元素是否是对象或者数组，若是对象，继续递归拷贝</span></span><br><span class="line">    <span class="comment">//若是值，直接添加到新创建的对象或者数组里</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[k] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      newObj[k] = <span class="title function_">deepClone</span>(obj[k]); <span class="comment">// 递归拷贝完 放入到新对象的属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则是值， 直接添加到新建的 newObj中</span></span><br><span class="line">      newObj[k] = obj[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj; <span class="comment">//返回新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  caches = &#123;&#125;; <span class="comment">// 事件中心</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// eventName事件名-独一无二, fn订阅后执行的自定义行为</span></span><br><span class="line">  on (eventName, fn)&#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">caches</span>[eventName] = <span class="variable language_">this</span>.<span class="property">caches</span>[eventName] || [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">caches</span>[eventName].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发布 =&gt; 将订阅的事件进行统一执行</span></span><br><span class="line">  emit (eventName, data) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">caches</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">caches</span>[eventName]</span><br><span class="line">      .<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消订阅 =&gt; 若fn不传, 直接取消该事件所有订阅信息</span></span><br><span class="line">  off (eventName, fn) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">caches</span>[eventName]) &#123;</span><br><span class="line">      <span class="keyword">const</span> newCaches = fn </span><br><span class="line">        ? <span class="variable language_">this</span>.<span class="property">caches</span>[eventName].<span class="title function_">filter</span>(<span class="function"><span class="params">e</span> =&gt;</span> e !== fn) </span><br><span class="line">        : [];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">caches</span>[eventName] = newCaches;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、使用<span class="title class_">Token</span>：</span><br><span class="line">用户登录成功，服务器返回 token  -&gt;  前端将token存在 本地<span class="variable language_">localStorage</span>/cookie 中</span><br><span class="line">每次请求需要认证的接口：前端将token附加在请求头中，交给服务器验证</span><br><span class="line"><span class="number">2</span>、使用session：</span><br><span class="line">服务器为每个用户创建一个 session  -&gt;  session <span class="variable constant_">ID</span>  存在 cookie 中</span><br><span class="line">前端将 sessionID 附加在请求头中，交给服务器验证，识别身份</span><br><span class="line"><span class="number">3</span>、<span class="title class_">OAuth</span>（用户授权第三方应用）</span><br><span class="line">用户登录 -&gt; 服务器验证 -&gt; 授权第三方应用 -&gt; 返回授权码/token -&gt; 跳转回用户登录页</span><br><span class="line">-&gt; 服务器验证</span><br><span class="line">不存储token的话，<span class="title class_">Session</span> <span class="variable constant_">ID</span>/<span class="variable constant_">JWT</span>/第三方</span><br><span class="line">不存储token可能会导致一些安全问题：<span class="variable constant_">XSS</span>跨域脚本攻击 + token泄露</span><br></pre></td></tr></table></figure>
<h2 id="看代码题"><a href="#看代码题" class="headerlink" title="看代码题"></a>看代码题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="comment">// JS单线程，同步代码优先执行，然后再去处理异步任务（如 setTimeout 和 Promise 的 .then()）。</span></span><br><span class="line"><span class="comment">// 同步代码直接在当前执行栈中运行，异步代码则在 微任务队列 或 宏任务队列 中排队。</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// setTimeout属于【宏任务】，会在所有同步代码和微任务执行完之后再执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Promise的.then() 属于【微任务】，会在当前事件循环的结尾执行，优先级高于 setTimeout</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"><span class="comment">// 输出顺序：2 3 5 4 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  async / await</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，</span></span><br><span class="line"><span class="comment">// 等到触发的异步操作完成，再执行函数体内后面的语句。可理解为:让出线程，跳出了 async 函数体。</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一题</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>))<span class="comment">// 状态返回fulfilled</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)) <span class="comment">// catch中没有报错，状态返回fulfilled，后面的then会执行</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)) <span class="comment">// 1,3</span></span><br><span class="line"><span class="comment">// 整个执行完没有报错，状态返回fulfilled</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二题</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// then中有报错 状态返回rejected,后面的catch会执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)) <span class="comment">// catch中没有报错，状态返回fulfilled，后面的then会执行</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)) <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="comment">// 整个执行完没有报错，状态返回fulfilled</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三题</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;<span class="comment">//then中有报错 状态返回rejected，后面的catch会执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)) <span class="comment">// catch中没有报错，状态返回fulfilled，后面的catch不会执行</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)) <span class="comment">// 1，2</span></span><br><span class="line"><span class="comment">// 整个执行完没有报错，状态返回fulfilled</span></span><br></pre></td></tr></table></figure>
<h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一面：有几轮面试、HC headcount多吗、培养机制</span><br><span class="line">日常职责、技术栈 </span><br><span class="line">主要工作地点</span><br><span class="line">一般多久出结果</span><br><span class="line">有什么给我的建议吗</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>项目总结</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/">http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>IZDLOYL</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-08-27</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-11-01</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A7%8B%E6%8B%9B/">秋招</a></div><div class="post_share"><div class="social-share" data-image="/gallery/wallpaper5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端八股</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/23/frontEnd-nodejs/" title="node"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">node</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">IZDLOYL</div><div class="author-info__description">🎬𝙏𝙪𝙧𝙣 𝙤𝙛𝙛 𝙬𝙤𝙧𝙧𝙮✨</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/IZDLOYL-G"><i class="fab fa-github"></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/IZDLOYL-G" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1215472755@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #dfc600;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1174008660" target="_blank" title="Weixin"><i class="fab fa-weixin" style="color: #48b700;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">welcome to my blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E4%BA%AB%E6%B1%87"><span class="toc-text">图享汇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%88%E9%9A%BE%E7%82%B9%E3%80%81%E8%A7%A3%E5%86%B3%EF%BC%89"><span class="toc-text">介绍（难点、解决）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9D%97"><span class="toc-text">登录注册模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91"><span class="toc-text">登录逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81"><span class="toc-text">滑动验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95"><span class="toc-text">第三方扫码登录</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85"><span class="toc-text">axios二次封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%B5%81%E5%92%8C%E9%95%BF%E5%88%97%E8%A1%A8"><span class="toc-text">瀑布流和长列表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%B5%81%E7%BB%84%E4%BB%B6"><span class="toc-text">瀑布流组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%95%BF%E5%88%97%E8%A1%A8"><span class="toc-text">长列表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%A3%81"><span class="toc-text">懒加裁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">图片懒加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">组件懒加载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96"><span class="toc-text">防抖搜索优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">移动端适配 - 响应式布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE"><span class="toc-text">人力资源后台项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%88%E9%9A%BE%E7%82%B9%E8%A7%A3%E5%86%B3%EF%BC%89"><span class="toc-text">介绍（难点解决）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90"><span class="toc-text">权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex%E7%AE%A1%E7%90%86"><span class="toc-text">vuex管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="toc-text">excel导入导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%88%97%E8%A1%A8%E8%BD%AC%E6%A0%91"><span class="toc-text">递归列表转树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A7%82%E9%A2%98"><span class="toc-text">主观题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue"><span class="toc-text">vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">vue生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2-3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">vue2&#x2F;3响应式原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3%E5%92%8Cvue2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">vue3和vue2的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-text">v-model 双向绑定原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">vue组件通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F-%E9%80%89%E9%A1%B9%E5%BC%8FAPI"><span class="toc-text">组合式&#x2F;选项式API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E5%92%8Chistory%E8%B7%AF%E7%94%B1"><span class="toc-text">hash和history路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if-%E4%B8%8E-v-show-%E5%8C%BA%E5%88%AB"><span class="toc-text">v-if 与 v-show 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nextTick"><span class="toc-text">nextTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E4%B8%8E-React-%E5%8C%BA%E5%88%AB"><span class="toc-text">Vue 与  React 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">vue 项目的性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86vuex-pinia"><span class="toc-text">状态管理vuex&#x2F;pinia</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-toRef-toRefs"><span class="toc-text">ref &#x2F;toRef&#x2F;toRefs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6"><span class="toc-text">如何封装组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css-%E6%9D%83%E9%87%8D"><span class="toc-text">css 权重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC"><span class="toc-text">BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD1"><span class="toc-text">水平垂直居中1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#em-px-rem-vh-vw-%E5%8C%BA%E5%88%AB"><span class="toc-text">em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flex%E5%B8%83%E5%B1%80"><span class="toc-text">flex布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">CSS3新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D"><span class="toc-text">定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0"><span class="toc-text">隐藏页面元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS%E5%8A%A8%E7%94%BB%E5%92%8C%E8%BF%87%E6%B8%A1"><span class="toc-text">CSS动画和过渡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">css提高性能的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%A0%8F%EF%BC%9A%E5%B7%A6%E5%AE%9A%E5%AE%BD%E5%8F%B3%E8%87%AA%E9%80%82%E5%BA%941"><span class="toc-text">两栏：左定宽右自适应1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E4%B8%80%E6%9D%A10-5px%E7%9A%84%E7%BA%BF"><span class="toc-text">画一条0.5px的线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">画三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%A0%87%E7%AD%BE"><span class="toc-text">表单中常见标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">js 数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">typeof类型判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型和原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">闭包和内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">async&#x2F;await 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E5%BC%82%E6%AD%A5%E6%80%BB%E7%BB%93"><span class="toc-text">promise异步总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">ES6新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">事件机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let%E3%80%81const%E3%80%81var%E5%8C%BA%E5%88%AB"><span class="toc-text">let、const、var区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C"><span class="toc-text">&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-text">数组原生方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">遍历数组对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E4%B8%AD%E7%9A%84this"><span class="toc-text">JS中的this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">new操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="toc-text">微任务宏任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E4%BD%9C%E7%94%A8"><span class="toc-text">请求接口作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM%E5%92%8CDOM"><span class="toc-text">BOM和DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">伪类和伪元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">HTTP和浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">TCP三次握手和四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%8A%A5%E6%96%87%E5%A4%B4"><span class="toc-text">TCP请求头报文头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%82%A8%E5%AD%98"><span class="toc-text">储存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">浏览器缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL-%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B"><span class="toc-text">从输入URL 到网页显示的完整过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84web%E5%89%8D%E7%AB%AF%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-text">常见的web前端攻击方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88"><span class="toc-text">跨域方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E5%A4%9A%E6%A0%87%E7%AD%BEtab%E9%80%9A%E8%AE%AF"><span class="toc-text">实现网页多标签tab通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD"><span class="toc-text">如何提高前端页面性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8C%85"><span class="toc-text">抓包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">前端工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">webpack 构建流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vite-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-text">Vite 为什么快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AFiframe"><span class="toc-text">微前端iframe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git"><span class="toc-text">git</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-text">路由守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8E%A5%E6%96%87%E4%BB%B6readme"><span class="toc-text">交接文件readme</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B"><span class="toc-text">文件上线流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-text">手写代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-%E6%96%B9%E6%B3%95"><span class="toc-text">instanceof 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-text">防抖节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">浅拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-text">发布订阅</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-text">场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD"><span class="toc-text">登录功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E4%BB%A3%E7%A0%81%E9%A2%98"><span class="toc-text">看代码题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E9%97%AE"><span class="toc-text">反问</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端八股"/></a><div class="content"><a class="title" href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股">前端八股</a><time datetime="2024-08-29T13:06:26.092Z" title="发表于 2024-08-29 21:06:26">2024-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/27/interview-%E6%80%BB%E7%BB%93/" title="项目总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目总结"/></a><div class="content"><a class="title" href="/2024/08/27/interview-%E6%80%BB%E7%BB%93/" title="项目总结">项目总结</a><time datetime="2024-08-27T12:58:34.417Z" title="发表于 2024-08-27 20:58:34">2024-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-nodejs/" title="node"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="node"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-nodejs/" title="node">node</a><time datetime="2024-08-23T08:14:35.116Z" title="发表于 2024-08-23 16:14:35">2024-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-JavaScript/" title="JS基本语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS基本语法"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-JavaScript/" title="JS基本语法">JS基本语法</a><time datetime="2024-08-23T08:06:33.574Z" title="发表于 2024-08-23 16:06:33">2024-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-TypeScript/" title="TypeScript"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-TypeScript/" title="TypeScript">TypeScript</a><time datetime="2024-08-23T08:06:10.608Z" title="发表于 2024-08-23 16:06:10">2024-08-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By IZDLOYL</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hope you have a nice day!🍭🍭🍭</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 IZDLOYLの前端笔记 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/项目/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 IZDLOYLの项目 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 IZDLOYLの算法笔记 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/面试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 IZDLOYLの面试总结 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://www.izdloyl.cn/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-JavaScript/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-JavaScript/" alt="">JS基本语法</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-JavaScript/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-TypeScript/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-TypeScript/" alt="">TypeScript</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-TypeScript/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/01/frontEnd-vue3/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" href="2024/08/01/frontEnd-vue3/" alt="">vue3</a><div class="blog-slider__text">vue3学习笔记</div><a class="blog-slider__button" href="2024/08/01/frontEnd-vue3/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-nodejs/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-nodejs/" alt="">node</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-nodejs/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/01/frontEnd-vue2/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" href="2024/08/01/frontEnd-vue2/" alt="">vue2</a><div class="blog-slider__text">vue2学习笔记</div><a class="blog-slider__button" href="2024/08/01/frontEnd-vue2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-数组/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-数组/" alt="">数组篇</a><div class="blog-slider__text">代码随想录 - 数组篇</div><a class="blog-slider__button" href="2024/08/02/algorithm-数组/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-hot100/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-hot100/" alt="">hot100</a><div class="blog-slider__text">LeetCode - hot100</div><a class="blog-slider__button" href="2024/08/02/algorithm-hot100/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-字符串/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-字符串/" alt="">字符串篇</a><div class="blog-slider__text">代码随想录 - 字符串篇</div><a class="blog-slider__button" href="2024/08/02/algorithm-字符串/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>
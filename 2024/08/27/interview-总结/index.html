<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>项目总结 | IZDLOYL's Blog</title><meta name="author" content="IZDLOYL"><meta name="copyright" content="IZDLOYL"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="123456789（面试官您好）我叫朱晓霞，目前是杭州电子科技大学通信工程专业研三的学生，在校期间，我系统学习了前端开发的相关知识，比较熟悉JS，且在Vue开发方面也积累了一定的实践经验。目前，主要参与过两个前端项目的开发。一个是人力资源后台管理系统，另一个是一个响应式设计的图片分享平台，通过这些项目实践，我掌握了组件化开发、状态管理以及前后端接口联调等核心技能。同时呢，为了整理和分享自己的所学">
<meta property="og:type" content="article">
<meta property="og:title" content="项目总结">
<meta property="og:url" content="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="IZDLOYL&#39;s Blog">
<meta property="og:description" content="123456789（面试官您好）我叫朱晓霞，目前是杭州电子科技大学通信工程专业研三的学生，在校期间，我系统学习了前端开发的相关知识，比较熟悉JS，且在Vue开发方面也积累了一定的实践经验。目前，主要参与过两个前端项目的开发。一个是人力资源后台管理系统，另一个是一个响应式设计的图片分享平台，通过这些项目实践，我掌握了组件化开发、状态管理以及前后端接口联调等核心技能。同时呢，为了整理和分享自己的所学">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.izdloyl.cn/gallery/wallpaper1.jpg">
<meta property="article:published_time" content="2024-08-27T12:58:34.417Z">
<meta property="article:modified_time" content="2024-09-25T13:57:16.567Z">
<meta property="article:author" content="IZDLOYL">
<meta property="article:tag" content="秋招">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.izdloyl.cn/gallery/wallpaper1.jpg"><link rel="shortcut icon" href="/gallery/favicon.jpg"><link rel="canonical" href="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '项目总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-25 21:57:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/gallery/wallpaper1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="IZDLOYL's Blog"><span class="site-name">IZDLOYL's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">项目总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-27T12:58:34.417Z" title="发表于 2024-08-27 20:58:34">2024-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-25T13:57:16.567Z" title="更新于 2024-09-25 21:57:16">2024-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="项目总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（面试官您好）我叫朱晓霞，目前是杭州电子科技大学通信工程专业研三的学生，</span><br><span class="line">在校期间，我系统学习了前端开发的相关知识，</span><br><span class="line">比较熟悉JS，且在Vue开发方面也积累了一定的实践经验。</span><br><span class="line">目前，主要参与过两个前端项目的开发。</span><br><span class="line">一个是人力资源后台管理系统，另一个是一个响应式设计的图片分享平台，</span><br><span class="line">通过这些项目实践，我掌握了组件化开发、状态管理以及前后端接口联调等核心技能。</span><br><span class="line">同时呢，为了整理和分享自己的所学知识，我基于hexo 搭建了自己的个人博客网站，</span><br><span class="line">主要记录自己学习前端的心得体会和开发中的一些日常积累。</span><br><span class="line">以上是我的一些基本情况。</span><br></pre></td></tr></table></figure>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">项目介绍:</span><br><span class="line">1.背景，这是一个 xxx 项目(体检相关的)，主要有 xxx 功能，为 xxx 服务</span><br><span class="line">2.分 B℃两端，C 端分 App 小程序 公众号，三个使用角色(医生、患者、公司运维)</span><br><span class="line">3.举例(体检)说明功能流程</span><br><span class="line">4.作为项目前端负责人，统一负责这个系统的所有端的 FE 部分。参与最多的还是 B端，因为 B端足够复杂</span><br><span class="line">4.1 微前端，xx个子模块。一共有 xx 个页面、组件 -- 规模比较大</span><br><span class="line">4.2还有，一些 xx 功能也比较复杂</span><br><span class="line">结束 +引导</span><br></pre></td></tr></table></figure>
<h3 id="图享汇"><a href="#图享汇" class="headerlink" title="图享汇"></a>图享汇</h3><h4 id="1、登录注册"><a href="#1、登录注册" class="headerlink" title="1、登录注册"></a>1、登录注册</h4><h5 id="使用slideCaptcha完成滑动验证"><a href="#使用slideCaptcha完成滑动验证" class="headerlink" title="使用slideCaptcha完成滑动验证"></a>使用<code>slideCaptcha</code>完成滑动验证</h5><p>原理：将用户拖动行为的时间、精度，滑动轨迹等信息到服务器，然后进行后台算法验证。</p>
<p>过程：首先在人类行为验证组件完成对应<code>UI</code>样式，在组件挂载（<code>onMounted</code>）时初始化并配置一个滑动验证码（<code>sliderCaptcha</code>），并指定处理成功、失败的回调函数，在用户拼图成功这个回调中，通过调用 <code>getCaptcha</code> 方法发送行为数据给后端进行进一步的验证</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCaptcha &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/sys&#x27;</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  captcha = <span class="title function_">sliderCaptcha</span>(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;captcha&#x27;</span>, <span class="comment">// 渲染位置</span></span><br><span class="line">    <span class="comment">// 用户拼图成功之后的回调</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">onSuccess</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getCaptcha</span>(&#123;</span><br><span class="line">        <span class="attr">behavior</span>: arr</span><br><span class="line">        <span class="keyword">if</span> (res) &#123; <span class="comment">// 人类行为验证通过</span></span><br><span class="line">          <span class="title function_">emits</span>(<span class="variable constant_">EMITS_SUCCESS</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 用户拼图失败之后的回调</span></span><br><span class="line">    <span class="title function_">onFail</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onFail&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 默认的验证方法，咱们不在此处进行验证，而是选择在用户拼图成功之后进行验证，所以此处永远返回为 true</span></span><br><span class="line">    <span class="title function_">verify</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="实现第三方QQ、微信扫码登录。"><a href="#实现第三方QQ、微信扫码登录。" class="headerlink" title="实现第三方QQ、微信扫码登录。"></a>实现第三方<code>QQ</code>、微信扫码登录。</h5><p><code>OAuth</code> 的思路：<code>OAuth</code>是一个关于授权（<code>authorization</code>）的开放网络标准。<span style="color: #165689"><strong>应用通过引导用户在第三方平台的授权层进行登录授权，获得一个限制权限和有效时间的令牌（token），在令牌有效期内即可从第三方平台换取用户授权使用的信息</strong></span>。</p>
<p>客户端授权模式：授权码模式、简化模式、密码模式、客户端模式。</p>
<p><strong><em>授权码模式</em></strong> 是功能最完整、流程最严密的授权模式。基于授权码模式的第三方登录流程如下：</p>
<ol>
<li>用户访问应用，点击登录按钮，跳转至第三方平台的登录授权页。</li>
<li>用户授权成功后会跳转至应用在第三方平台设置的回调地址，并携带授权码（<code>code</code>）。</li>
<li>应用服务器处理从第三方平台的登录授权页跳转至回调地址产生的<code>get</code>请求并从<code>query</code>中获得授权码，使用授权码和其他信息（比如应用在第三方平台注册的<code>appId</code>和<code>appKey</code>，设置的回调地址等）向第三方平台请求访问令牌（<code>access token</code>）。</li>
<li>在访问令牌的有效期内，应用服务器请求第三方平台接口获取用户的身份标识（<code>openid</code>、<code>unionid</code>等）和用户授权使用的信息（比如用户昵称和头像等开放信息）。</li>
<li>应用服务器根据获取的用户信息，完成注册登录的逻辑并跳转至应用首页。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408272059929.jpg" alt=""></p>
<p><strong>QQ 登录流程</strong>：【扫码登录之后，进入的地址为<strong>线上的回调地址</strong>，调试必须在线上进行】</p>
<ol>
<li><p>点击<code>QQ</code>登录按钮触发事件，进入第三方登录页（<code>window.open</code>）展示 <code>QQ</code> 登录二维码</p>
</li>
<li><p>获取用户信息：在执行<code>QQ</code>挂起登录时，由于<code>QQ</code>登录存在缓存，为防止下次进入时自动重新登录，在离开登录页面时，注销登录；获取当前用户唯一标识，作为判断用户是否已注册的依据，将获得的用户信息进行跨页面传输。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QQ 登录挂起</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable constant_">QC</span>.<span class="title class_">Login</span>(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">btnId</span>: <span class="string">&quot;qqLoginBtn&quot;</span>, <span class="comment">//插入按钮的节点id</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 登录成功之后的回调，但是需要注意，这个回调只会在《登录回调页面中被执行》</span></span><br><span class="line">    <span class="comment">// 登录存在缓存，登录成功一次之后，下次进入会自动重新登录（即：触发该方法，所以我们应该在离开登录页面时，注销登录）</span></span><br><span class="line">    <span class="function">(<span class="params">data, opts</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable constant_">QC</span>.<span class="property">Login</span>.<span class="title function_">signOut</span>(); <span class="comment">// 1. 注销登录，否则在后续登录中会直接触发该回调</span></span><br><span class="line">      <span class="comment">// 2. 获取当前用户唯一标识，作为判断用户是否已注册的依据</span></span><br><span class="line">      <span class="keyword">const</span> accessToken = <span class="regexp">/access_token=((.*))&amp;expires_in/</span>.<span class="title function_">exec</span>(</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span></span><br><span class="line">      )[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 3. 拼接请求对象</span></span><br><span class="line">      <span class="keyword">const</span> oauthObj = &#123;</span><br><span class="line">        <span class="attr">nickname</span>: data.<span class="property">nickname</span>,</span><br><span class="line">        <span class="attr">figureurl_qq_2</span>: data.<span class="property">figureurl_qq_2</span>,</span><br><span class="line">        accessToken,</span><br><span class="line">      &#125;;</span><br><span class="line">      broadcast.<span class="title function_">send</span>(oauthObj); <span class="comment">// 4. 完成跨页面传输</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 针对于 移动端而言：通过移动端触发 QQ 登录会展示三个页面，原页面、QQ 吊起页面、回调页面。并且移动端一个页面展示整屏内容，且无法直接通过 window.close() 关闭，所以在移动端中，我们需要在当前页面继续进行后续操作。</span></span><br><span class="line">      <span class="title function_">oauthLogin</span>(<span class="variable constant_">LOGIN_TYPE_QQ</span>, oauthObj);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">close</span>(); <span class="comment">// 5. 在 PC 端下，关闭第三方窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成跨页面数据传输：</p>
</li>
<li><p>认证是否已注册</p>
</li>
<li><p>完成 <code>QQ</code> 对接</p>
</li>
</ol>
<p><strong>微信登录流程</strong>：</p>
<ol>
<li><p>通过 <strong>微信登录前置数据获取</strong> 接口，获取登录数据（比如 <code>APP ID</code>）</p>
</li>
<li><p>根据获取到的数据，拼接得到 <code>open url</code> 地址</p>
</li>
<li><p>打开该地址，展示微信登录二维码</p>
</li>
<li><p>移动端微信扫码确定登录</p>
</li>
<li><p>从当前窗口中解析 <code>window.location.search</code> 得到用户的 <code>code</code> 数据</p>
</li>
<li><p>根据 <code>appId、appSecret、code</code> 通过接口获取用户的 <code>access_token</code></p>
</li>
<li><p>根据 <code>access_token</code> 获取用户信息</p>
</li>
<li><p>通过用户信息触发 <code>oauthLogin</code> 方法</p>
</li>
</ol>
<h4 id="2、axios二次封装"><a href="#2、axios二次封装" class="headerlink" title="2、axios二次封装"></a>2、<code>axios</code>二次封装</h4><blockquote>
<p>在请求拦截器中设置接口基础地址、超时时间、登录成功后请求头携带<code>token</code>，响应拦截器做异常处理。</p>
</blockquote>
<p><strong><em>axios 的使用</em></strong> ：请求方式：<code>axios.get()</code>、<code>axios.post()</code>、<code>axios(&#123;&#125;)</code></p>
<ul>
<li>get 请求</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给后端传递的参数 ==&gt; 参数1=值&amp;参数2=值</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;url?参数1=值&amp;参数2=值&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>post 请求</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;url&quot;</span>, &#123;</span><br><span class="line">  参数<span class="number">1</span>: 值,</span><br><span class="line">  参数<span class="number">2</span>: 值,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>axios(&#123;&#125;)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;xxxX&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post或get&#x27;</span></span><br><span class="line">  <span class="attr">params</span>:&#123;&#125;, <span class="comment">// get请求方式给后端传递的参数</span></span><br><span class="line">  <span class="attr">data</span>:&#123;&#125;, <span class="comment">// post请求方式给后端传递的参数</span></span><br><span class="line">  <span class="attr">header</span>:&#123;&#125;, <span class="comment">// 自定义请求头</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>, <span class="comment">// 请求时间超过timeout,则请求会被中断</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;默认为json格式数据&#x27;</span> <span class="comment">// 相应的数据类型</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong><em>axios 二次封装</em></strong> ：</p>
<blockquote>
<ol>
<li>提高代码复用性，减少代码量，减低维护难度。</li>
<li>统一处理一些常规的问题一劳永逸，如 http 错误。</li>
<li>拦截请求和响应，提前对数据进行处理，如获取 token，修改配置项。</li>
</ol>
</blockquote>
<p>步骤：</p>
<ol>
<li>在 src 目录下创建<code>request.js</code>对 axios 进行二次封装，并导入 axios</li>
<li>配置全局的一些基础配置：baseURL、timeout、header、responseType、withCredentials</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 利用axios对象的方法create,去创建一个axios实例</span></span><br><span class="line"><span class="keyword">const</span> requests = axios.<span class="title function_">create</span>(&#123; <span class="comment">// requests就是axios,只不过稍微配置一下</span></span><br><span class="line">  <span class="attr">baseURL</span>: process.<span class="property">env</span>.<span class="property">VUE_APP_BASE_API</span>, <span class="comment">// 基础地址⭐</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>, <span class="comment">// 超出时间⭐</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span> <span class="comment">// 相应的数据类型</span></span><br><span class="line">  <span class="attr">header</span>:&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;123&quot;</span>&#125;, <span class="comment">// 自定义请求头</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>根据 node 环境变量区分开发、生产环境：文件<code>.env.production</code>和<code>.env.development</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .env.production文件：</span></span><br><span class="line"><span class="variable constant_">ENV</span> = <span class="string">&#x27;production&#x27;</span> # just a flag</span><br><span class="line"><span class="variable constant_">VUE_APP_BASE_API</span> = <span class="string">&#x27;/prod-api&#x27;</span> # 基地址</span><br><span class="line"></span><br><span class="line"><span class="comment">// .env.development文件：</span></span><br><span class="line"><span class="variable constant_">ENV</span> = <span class="string">&#x27;development&#x27;</span> # just a flag</span><br><span class="line"><span class="variable constant_">VUE_APP_BASE_API</span> = <span class="string">&#x27;/api&#x27;</span> # 基地址</span><br><span class="line"></span><br><span class="line">接着在package.<span class="property">json</span>文件中修改命令配置：</span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve --mode serveDwp&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;vue-cli-service serve --mode devDwp&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build --mode production&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;vue-cli-service build --mode test&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<ol>
<li>配置请求拦截器：token、密钥的设置</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器：在发请求之前，请求拦截器可以检测到,可以在请求发出去之前做一些事情</span></span><br><span class="line">requests.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每次发送请求之前判断是否存在token</span></span><br><span class="line">    <span class="comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span></span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">token</span>) &#123;</span><br><span class="line">      config.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="string">`Bearer <span class="subst">$&#123;store.getters.token&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error); <span class="comment">// 失败执行promise</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol>
<li>配置响应拦截器：响应的统一处理</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应拦截器：包含两个函数（一个是成功返回的函数，一个是失败的返回的函数）</span></span><br><span class="line">requests.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// axios默认包裹了data</span></span><br><span class="line">    <span class="comment">// 判断是不是Blob</span></span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">data</span> <span class="keyword">instanceof</span> <span class="title class_">Blob</span>) <span class="keyword">return</span> response.<span class="property">data</span>; <span class="comment">// 返回了Blob对象</span></span><br><span class="line">    <span class="keyword">const</span> &#123; data, message, success &#125; = response.<span class="property">data</span>; <span class="comment">// 默认json格式</span></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title class_">Message</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;error&quot;</span>, message &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(message));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> (error) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">      <span class="title class_">Message</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;warning&quot;</span>, <span class="attr">message</span>: <span class="string">&quot;token超时了&quot;</span> &#125;);</span><br><span class="line">      <span class="comment">// 说明token超时了，主动跳到登录页</span></span><br><span class="line">      <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&quot;user/logout&quot;</span>); <span class="comment">// 调用action 退出登录</span></span><br><span class="line">      router.<span class="title function_">push</span>(<span class="string">&quot;/login&quot;</span>); <span class="comment">// 跳转到登录页</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error.message</span></span><br><span class="line">    <span class="title class_">Message</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;error&quot;</span>, <span class="attr">message</span>: error.<span class="property">message</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="3、组件封装"><a href="#3、组件封装" class="headerlink" title="3、组件封装"></a>3、组件封装</h4><blockquote>
<p>封装了包括瀑布流、上拉加载等通用组件，用于改善用户界面的流畅性和响应速度，提升了整体用户体验。</p>
<p>小红书首页布局：<strong>瀑布流和虚拟列表的结合</strong></p>
</blockquote>
<h5 id="瀑布流组件："><a href="#瀑布流组件：" class="headerlink" title="瀑布流组件："></a><strong><em>瀑布流组件：</em></strong></h5><ol>
<li><p>瀑布流的核心就是：通过<code>relative</code> 和<code>absolute</code>定位的方式，来控制每个 <code>item</code> 的位置</p>
</li>
<li><p>影响瀑布流高度的主要元素，通常都是<code>img</code>标签</p>
</li>
<li><p>有些服务端会返回<strong>关键<code>img</code>的高度</strong>，有些不会，所以需要分别处理：</p>
<ul>
<li><p>当服务端<strong>不返回</strong>高度时：需要等待 <code>img</code> 加载完成之后(预加载)，再来计算高度，然后通过得到的高度计算定位。否则则会出现高度计算不准确导致定位计算不准确的问题。</p>
</li>
<li><p>当服务端<strong>返回</strong>高度时：开发者则必须利用此高度为 <code>item</code> 进行高度设定。一旦 <code>item</code>具备指定高度，那么就不需要等待 <code>img</code>加载的过程，这样效率更高，并且可以业务的逻辑会变得更加简单。</p>
</li>
</ul>
</li>
<li><p>当进行响应式切换时，同样需要区分对应场景：</p>
<ul>
<li><p>当服务端<strong>不返回</strong>高度时：需要<strong>重新执行整个渲染流程</strong>，虽然会耗费一些性能，但可以最大可能的避免出现逻辑错误。让组件拥有更强的普适性。</p>
</li>
<li><p>当服务端<strong>返回</strong>高度时：同样需要重新计算<strong>列宽</strong>和<strong>定位</strong>，但因为 <code>item</code>具备明确的高度，所以可以直接拿到具体的高度，而无需重复整个渲染流程，从而可以实现更多的交互逻辑。比如：位移动画、将来的图片懒加载占位…</p>
</li>
</ul>
</li>
</ol>
<p>瀑布流布局的核心实现思想：</p>
<ol>
<li><strong>控制容器内每一列卡片的宽度相同</strong>（不同图片尺寸等比例缩放）</li>
<li>第一行卡片紧挨着排列，<strong>第二行开始采取贪心思想，每张卡片摆放到当前所有列中高度最小的一列下面</strong></li>
</ol>
<p>每个卡片<code>item</code>必须使用<code>absolute</code>绝对布局，并通过<code>top</code>和<code>left</code>来手动控制位置</p>
<p>通过<code>props</code>传递关键数据：数据源、唯一标识<code>key</code>、列数、列间距、行间距、是否需要预加载</p>
<p>计算容器宽度【<code>offsetWidth -</code>左右边距】和列宽【（容器的宽度 - 所有的列间距宽度）/ 列数】</p>
<p>想要计算每列的<code>left</code>、<code>top</code>，必须要拿到每个<code>item</code>的高度，才可以判断下一列的第一个<code>item</code>的位置。根据<code>pitturePreReading</code>可以分为两种情况：① 需要图片预加载时：图片高度未知 ② 不需要图片预加载时：图片高度已知</p>
<p>计算下一个<code>item</code>位置：<code>left =</code>最小高度所在的列 * (列宽 + 间距) <code>top =</code>最小高度所在列高+列间距</p>
<p>适配移动端：自定义列数变化<code>:column = &quot;isMobileTerminal ? 2 : 5&quot;</code>，在<strong>列宽发生变化</strong>时，重新执行计算列宽</p>
<p>难点：当设置<code>:picturePreReading=&quot;false&quot;</code>，不进行图片预加载时，在切换 PC 端和移动端时会出现图片重叠现象（图片高度计算出现错误）。出现原因：不进行图片预加载时，会直接获取当前<code>item</code>的高度，因为没有等待图片加载完成，此时的高度是不包含图片的高度，从而使整个<code>item</code>高度计算错误。</p>
<p>根据服务端返回的图片接口数据使用作用域插槽返回图片宽度，进而计算等比例缩放后的图片高度【计算后的图片高度 = （计算得到宽度/图片真实宽度）* 图片真实高度】。重新监听列数变换，增加图片不进行预加载的情况</p>
<h5 id="上拉加载："><a href="#上拉加载：" class="headerlink" title="上拉加载："></a><strong><em>上拉加载：</em></strong></h5><p>当滚动到列表底部时，加载数据</p>
<p>构建<code>props</code>传递<code>是否处于加载状态</code>和<code>是否全部加载完成</code>配置，加载下一页数据的触发事件，处理双向数据绑定逻辑，利用<code>vueuse</code>提供的 <a target="_blank" rel="noopener" href="https://vueuse.org/core/useIntersectionObserver/">useIntersectionObserver</a> 方法，监听元素可见行为，用于判断列表滚动到底部</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> laodingTarget = <span class="title function_">ref</span>(<span class="literal">null</span>); <span class="comment">// 滚动的元素</span></span><br><span class="line"><span class="title function_">useIntersectionObserver</span>(laodingTarget, <span class="function">(<span class="params">[&#123; isIntersecting &#125;]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当加载更多的视图可见时，同时 loading 为 false，同时 数据尚未全部加载完</span></span><br><span class="line">  <span class="comment">// 处理加载更多的逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (isIntersecting &amp;&amp; !loading.<span class="property">value</span> &amp;&amp; !props.<span class="property">isFinished</span>) &#123;</span><br><span class="line">    loading.<span class="property">value</span> = <span class="literal">true</span>; <span class="comment">// 修改加载数据标记</span></span><br><span class="line">    <span class="title function_">emits</span>(<span class="string">&quot;onLoad&quot;</span>); <span class="comment">// 触发加载更多行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="4、懒加裁"><a href="#4、懒加裁" class="headerlink" title="4、懒加裁"></a>4、懒加裁</h4><blockquote>
<p>使用<code>uselntersectionObserver</code>和<code>AsyncComponent</code>分别实现图片和组件的懒加裁，确保首屏加载速度。</p>
</blockquote>
<h5 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h5><p>当图片不可见时，不加载图片。当图片可见时，才去加载图片。</p>
<p><strong>可以监听所有图片是否被可见，如果图片处于不可见状态，那么就不加载图片，如果图片处于可见状态，那么开始加载图片。</strong>而这个功能的实现关键就是 <strong><code>IntersectionObserver</code></strong>。</p>
<p><code>vueuse</code>包提供的<code>useIntersectionObserver</code>方法：<code>const &#123;stop&#125; = useIntersectionObserver(target, fn, options)</code></p>
<ol>
<li><code>target</code>表示被监听的<code>DOM</code>元素</li>
<li>参数 2 是回调函数，用于通知监听的动作（回调函数的第一个形参<code>isIntersecting</code>表示被监听的元素已经进入了可视区）</li>
<li>参数 3 表示配置选项</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useIntersectionObserver <span class="keyword">from</span> <span class="string">&quot;@vueuse/core&quot;</span>;</span><br><span class="line"><span class="comment">// 处理图片懒加载</span></span><br><span class="line"><span class="comment">// 1、在元素挂载到页面中的钩子函数中、保存img的src</span></span><br><span class="line"><span class="comment">// 2、将img的src属性置为 空 或者置位默认图片</span></span><br><span class="line"><span class="comment">// 3、监听图片是否在可视范围内？ 在可视范围内将img保存在src重新复制到img上 并 取消监听</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> imgSrc = el.<span class="property">src</span>; <span class="comment">// 1、拿到当前 img 标签的 src</span></span><br><span class="line">    el.<span class="property">src</span> = <span class="string">&quot;&quot;</span>; <span class="comment">// 2、将img的src属性置为 空 或者置位默认图片</span></span><br><span class="line">    <span class="comment">//  3、监听图片是否在可视范围内</span></span><br><span class="line">    <span class="keyword">const</span> &#123; stop &#125; = <span class="title function_">useIntersectionObserver</span>(el, <span class="function">(<span class="params">&#123; isIntersecting &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isIntersecting) &#123;</span><br><span class="line">        el.<span class="property">src</span> = imgSrc; <span class="comment">// 3. 当图片可见时,加载图片</span></span><br><span class="line">        <span class="title function_">stop</span>(); <span class="comment">// 4. 停止监听</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h5><p><code>defineAsyncComponent</code> 方法接收一个返回<code>Promise</code>的加载函数。这个<code>Promise</code>的 <code>resolve</code> 回调方法应该在从服务器获得组件定义时调用。也可以调用 <code>reject(reason)</code> 表明加载失败。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动化注册组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; confirm &#125; <span class="keyword">from</span> <span class="string">&quot;./confirm/index&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">&quot;./message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出对象、这个对象有install方法，这样既可以通过app.use(options)来使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">app</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、获取当前路径下所有文件夹中以index.vue结尾的文件</span></span><br><span class="line">    <span class="keyword">const</span> components = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&quot;./*/index.vue&quot;</span>);</span><br><span class="line">    <span class="comment">// 2、遍历获取到的组件模块：利用path生成组件名称, defineAsyncComponent生成动态组件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [path, fn] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(components)) &#123;</span><br><span class="line">      <span class="comment">// path: ./popup/index.vue</span></span><br><span class="line">      <span class="comment">// 根据路径动态生成组件名称</span></span><br><span class="line">      <span class="keyword">const</span> componentName = <span class="string">&quot;m-&quot;</span> + path.<span class="title function_">replace</span>(<span class="string">&quot;./&quot;</span>, <span class="string">&quot;&quot;</span>).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 3、利用 app.component 将生成的组件名称和对应的异步组件注册到 Vue 应用上。使用 defineAsyncComponent 包装每个组件，这样组件会在第一次被使用时才加载，实现了组件的懒加载</span></span><br><span class="line">      app.<span class="title function_">component</span>(componentName, <span class="title function_">defineAsyncComponent</span>(fn));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5、防抖搜索优化"><a href="#5、防抖搜索优化" class="headerlink" title="5、防抖搜索优化"></a>5、防抖搜索优化</h4><p>对输入框搜索功能实现防抖封装，减少了频繁请求，优化了页面性能和用户体验。</p>
<p>防抖主要用于减少频繁触发的事件处理次数，避免资源浪费和性能问题</p>
<p>防抖的核心思想：当触发一个事件时，不去立刻执行，而是延迟一段时间，该事件变为等待执行事件。如果在这段时间之内，该事件被再次触发，则上次等待执行的事件取消，本次触发的事件变为等待执行事件。循环往复，直到某一个等待事件被执行为止</p>
<p>项目中搜索提示组件是通过 <code>watch</code> 监听输入内容的变化，所以当输入内容发生变化时，就会立刻触发 <code>getHintData</code> 事件。此时需要做防抖处理， <code>vueuse</code> 中提供了对应的 <a target="_blank" rel="noopener" href="https://vueuse.org/shared/watchDebounced/">watchDebounced</a> ，可以直接利用这个 <code>API</code> 直接实现防抖的<code>watch</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; getHint &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/pexels&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; watchDebounced &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">// 监听搜索文本的变化，并获取对应提示数据</span></span><br><span class="line"><span class="title function_">watchDebounced</span>(<span class="function">() =&gt;</span> props.<span class="property">searchText</span>, getHintData, &#123;</span><br><span class="line">  <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">debounce</span>: <span class="number">500</span> <span class="comment">// 每次事件触发时，延迟的时间</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="移动端适配-响应式布局"><a href="#移动端适配-响应式布局" class="headerlink" title="移动端适配 - 响应式布局"></a>移动端适配 - 响应式布局</h4><ol>
<li><p><strong><em>百分比布局</em></strong>：通过百分比单位使浏览器中的组件的宽和高随着浏览器的变化而变化</p>
<ul>
<li><p><code>height</code>、<code>width</code>属性的百分比依托于父标签的宽高。但是<code>padding</code>、<code>border</code>、<code>margin</code>等属性的情况又不一样</p>
</li>
<li><p>1、子元素的<code>top</code>和<code>bottom</code>如果设置百分比，则相对于直接非<code>static</code>定位（默认定位）的父元素的高度，同样，子元素的<code>left</code>和<code>right</code>如果设置百分比，则相对于直接非<code>static</code>定位（默认定位的）父元素的宽度。<br>2、子元素的<code>padding</code>和<code>margin</code>如果设置百分比，不论是垂直方向或者是水平方向都相对于直接父亲元素的<code>width</code>，而与父元素的<code>height</code>无关。</p>
</li>
<li><p><code>border-radius</code>为百分比，则是相对于自身的宽度</p>
</li>
<li><p><strong>缺点：</strong>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位</p>
</li>
</ul>
</li>
<li><p><strong><em>媒体查询布局</em></strong>：通过<code>@media</code>媒体查询，给不同屏幕的大小编写不同的样式来实现。</p>
<ul>
<li>缺点：如果浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。</li>
</ul>
</li>
<li><p><strong><em><code>rem</code>布局</em></strong>： <code>rem</code> 是<code>CSS3</code>新增的一个相对单位，<em>1rem = 16px</em></p>
<ul>
<li><p><code>rem</code>是相对于<code>html</code>根元素的字体大小的单位。</p>
</li>
<li><p>通过修改<code>html</code>中<code>font-size</code>的字体大小来控制<code>rem</code>的大小。</p>
</li>
</ul>
</li>
<li><p><strong><em><code>vw</code>、<code>vh</code>响应式布局</em></strong>：<code>vw</code>和<code>vh</code>分别相对的是视图窗口的宽度和高度。</p>
<ul>
<li><code>100vw = 100%</code>视图窗口宽度 ，<code>100vh = 100%</code> 视图窗口高度</li>
</ul>
</li>
<li><p><strong><em><code>flex</code>弹性布局</em></strong>：只需要依赖于<code>CSS</code>样式的实现响应式布局的方式</p>
<ol>
<li>父元素：常用的弹性布局的属性<ul>
<li><code>flex-direction</code> ：水平方向对齐方式（<code>wrap\wrap-reverse\colume\colume</code>）</li>
<li><code>flex-wrap</code> ：是否换行</li>
<li><code>justify-content</code> ： 水平方向对齐方式</li>
<li><code>align-items</code> ：控制子元素在垂直方向上的对齐方式</li>
<li><code>align-content</code>：垂直方向的对齐方式</li>
</ul>
</li>
<li>子元素：常用的弹性布局的属性<ul>
<li><code>order</code>：排序，给元素指定不同数值，数值越大越靠后</li>
<li><code>flex-grow</code>： 对容器剩余空间，按指定比例放大元素填充容器</li>
<li><code>flex-shrink</code>：对超出容器空间按数值比例收缩填充</li>
<li><code>flex-basis</code>：指定元素在主轴（水平）方向上的初始大小</li>
<li><code>align-self</code>：控制单个元素在交叉轴（垂直）上的对齐</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>项目中使用的是<strong><code>flex + rem</code></strong>响应式布局的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次加载成功时设置html跟标签的fontSize属性值；最大基准值为40px</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useREM</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">MAX_FONT_SIZE</span> = <span class="number">40</span>; <span class="comment">// 最大基准值</span></span><br><span class="line">  <span class="comment">// 当文档被解析成功时调用</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;html&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置屏幕基准值的标准为 屏幕的宽度 / 10</span></span><br><span class="line">    <span class="keyword">const</span> fontSize = <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="number">10</span>;</span><br><span class="line">    html.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="title class_">Math</span>.<span class="title function_">min</span>(fontSize, <span class="variable constant_">MAX_FONT_SIZE</span>) + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="人力资源后台项目"><a href="#人力资源后台项目" class="headerlink" title="人力资源后台项目"></a>人力资源后台项目</h3><h4 id="1、权限"><a href="#1、权限" class="headerlink" title="1、权限"></a>1、权限</h4><blockquote>
<p>使用<code>vue-router</code>配置路由切换视图，在权限模块中基于<code>RBAC</code>权限模型实现动态添加路由规则，完成不同角色的权限分配。（员工 - 角色 - 权限）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RBAC权限控制和Token认证的使用，流程大致如下:</span><br><span class="line">1.用户登录时，客户端向服务端发送登录请求，服务端验证用户名密码是否正确，如果正确则返回一个Token值给客户端。</span><br><span class="line">2.客户端在后续的请求中，在Header中携带这个Token值，服务端根据Token值来识别用户身份。</span><br><span class="line">3.服务端根据用户的身份和角色信息，对请求的API接口或页面元素进行权限判断，如果有权限则返回数据，否则返回403或401等错误码。</span><br></pre></td></tr></table></figure>
<p>权限管理就是让不同的用户只能访问自己权限内的资源，有以下几种</p>
<ul>
<li>路由权限，用户登录后只能看到自己权限内的导航菜单，且只能访问自己权限内的路由地址</li>
<li>视图权限，用户只能看到自己权限内的内容和按钮</li>
<li>请求权限，越权请求将其拦截</li>
</ul>
<p><strong>权限管理</strong>：接口权限、按钮权限、菜单权限、路由权限</p>
<ul>
<li><strong>接口权限</strong></li>
</ul>
<p>用户登录成功拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，请求头要携带<code>token</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.<span class="property">headers</span>[<span class="string">&#x27;token&#x27;</span>] = cookie.<span class="title function_">get</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;,&#123;response&#125;=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">203</span>) &#123; <span class="comment">//token过期或者错误</span></span><br><span class="line">    router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>路由权限</strong></li>
</ul>
<p><strong>方法 1</strong>：在路由初始化的时候挂载全部路由，在路由上标记相应的权限信息，当路由跳转的时候做校验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/home&quot;</span>),</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;homePage&quot;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;主页&quot;</span>,</span><br><span class="line">      <span class="attr">roles</span>: [<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;editor&quot;</span>], <span class="comment">//权限</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>会加载所有的路由，当路由很多的时候，对性能会有影响；</li>
<li>每次路由跳转都要做权限判断；</li>
<li>菜单信息写在前端，需要修改标题的时候，需要重新编译；</li>
<li>菜单跟路由耦合在一起，路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<p><strong>方法 2：项目</strong>：初始化的时候先挂载静态（不需要权限控制的）路由，比如登录页，404 页。如果用户通过 URL 进行强制访问，会直接进入 404。登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用<code>addRoutes</code>添加路由（⭐）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022028328.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拆分静态路由和动态路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态路由：没有权限的页面，所有角色都可以进入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> constantRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>, <span class="comment">// 登录页</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/login/index&quot;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/404&quot;</span>, <span class="comment">// 404页</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/404&quot;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="comment">// 首页</span></span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&quot;/dashboard&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;dashboard&quot;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Dashboard&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/dashboard/index&quot;</span>),</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;首页&quot;</span>, <span class="attr">icon</span>: <span class="string">&quot;dashboard&quot;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// &#123; path: &#x27;*&#x27;, redirect: &#x27;/404&#x27;, hidden: true &#125;// 404 页必须放在末尾 !!!</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// 动态路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> asyncRoutes = [</span><br><span class="line">  departmentRouter,</span><br><span class="line">  roleRouter,</span><br><span class="line">  employeeRouter,</span><br><span class="line">  permissionRouter,</span><br><span class="line">  attendanceRouter,</span><br><span class="line">  approvalRouter,</span><br><span class="line">  salaryRouter,</span><br><span class="line">  socialRouter,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createRouter</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">    <span class="comment">// mode: &#x27;history&#x27;, // 需要服务支持</span></span><br><span class="line">    <span class="attr">scrollBehavior</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</span><br><span class="line">    <span class="attr">routes</span>: constantRoutes, <span class="comment">// 默认引入静态路由</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resetRouter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newRouter = <span class="title function_">createRouter</span>();</span><br><span class="line">  router.<span class="property">matcher</span> = newRouter.<span class="property">matcher</span>; <span class="comment">// 重置路由</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>
<p>使用<code>addRoutes</code>动态挂载路由：应用初始化的时候先挂载不需要权限控制的路由，比如登录页，404 页。登录成功后，获取用户资料的权限信息（vuex），然后筛选有权限访问的路由(asyncRoutes.filter)，再在全局路由守卫里调用 addRoutes 添加路由。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022028370.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;@/router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> nprogress <span class="keyword">from</span> <span class="string">&quot;nprogress&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;nprogress/nprogress.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;@/store&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; asyncRoutes &#125; <span class="keyword">from</span> <span class="string">&quot;@/router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置守卫</span></span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/404&quot;</span>]; <span class="comment">// 白名单：不需要token也能访问</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  nprogress.<span class="title function_">start</span>(); <span class="comment">// 开启进度条nprogress</span></span><br><span class="line">  <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">token</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在token</span></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&quot;/login&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 跳转到主页</span></span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">// 主页</span></span><br><span class="line">      nprogress.<span class="title function_">done</span>(); <span class="comment">//next（地址）并没有执行后置守卫，需手动关闭进度条</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//////// 重点代码 ////////////////////////////////////////////////////</span></span><br><span class="line">      <span class="keyword">if</span> (!store.<span class="property">getters</span>.<span class="property">userId</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否获取过用户资料</span></span><br><span class="line">        <span class="keyword">const</span> &#123; roles &#125; = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&quot;user/getUserInfo&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> filterRoutes = asyncRoutes.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> roles.<span class="property">menus</span>.<span class="title function_">includes</span>(item.<span class="property">name</span>);</span><br><span class="line">        &#125;); <span class="comment">// 筛选后的路由，filter返回一个布尔值</span></span><br><span class="line">        store.<span class="title function_">commit</span>(<span class="string">&quot;user/setRoutes&quot;</span>, filterRoutes); <span class="comment">//将筛选后的路由添加到vuex</span></span><br><span class="line">        router.<span class="title function_">addRoutes</span>([</span><br><span class="line">          ...filterRoutes,</span><br><span class="line">          &#123; <span class="attr">path</span>: <span class="string">&quot;*&quot;</span>, <span class="attr">redirect</span>: <span class="string">&quot;/404&quot;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        ]); <span class="comment">// 添加动态路由信息到路由表</span></span><br><span class="line">        <span class="title function_">next</span>(to.<span class="property">path</span>); <span class="comment">// router添加动态路由之后,需要转发一下,目的是让路由拥有信息(router的已知缺陷)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">next</span>(); <span class="comment">// 放过</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/////// 重点代码 ///////////////////////////////////////////////////////</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有token</span></span><br><span class="line">    <span class="keyword">if</span> (whiteList.<span class="title function_">includes</span>(to.<span class="property">path</span>)) &#123;</span><br><span class="line">      <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&quot;/login&quot;</span>); <span class="comment">// 中转到登录页</span></span><br><span class="line">      nprogress.<span class="title function_">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置守卫</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  nprogress.<span class="title function_">done</span>(); <span class="comment">// 关闭进度条</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p>
<p><em>缺点</em> ：① 全局路由守卫里，每次路由跳转都要做判断 ② 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译 ③ 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</p>
<ul>
<li><strong>菜单权限</strong></li>
</ul>
<p>用户登录之后服务端返回一个数据，这个数据有菜单列表和<code>token</code>，我们把这个数据放入到<code>vuex</code>中，然后主页根据<code>vuex</code>中的数据进行菜单列表的渲染（⭐）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">在vuex用户模块添加路由信息state，筛选路由后提交mutation更新state，渲染左侧菜单</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; constantRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">token</span>: <span class="title function_">getToken</span>(), <span class="comment">// 从缓存中读取初始值</span></span><br><span class="line">  <span class="attr">userInfo</span>: &#123;&#125;, <span class="comment">// 存储用户基本资料状态</span></span><br><span class="line">  <span class="attr">routes</span>: constantRoutes <span class="comment">// 静态路由的数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="title function_">setRoutes</span>(<span class="params">state, newRoutes</span>) &#123;</span><br><span class="line">    state.<span class="property">routes</span> = [...constantRoutes, ...newRoutes] <span class="comment">// 静态路由 + 动态路由</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;user/setRoutes&#x27;</span>, filterRoutes)<span class="comment">//将筛选后的路由添加到vuex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染左侧菜单</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  .......</span><br><span class="line">  <span class="attr">routes</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">user</span>.<span class="property">routes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getters</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">SidebarItem</span>, <span class="title class_">Logo</span> &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapGetters</span>([</span><br><span class="line">      <span class="string">&#x27;sidebar&#x27;</span>, <span class="string">&#x27;routes&#x27;</span></span><br><span class="line">    ]),</span><br><span class="line">    <span class="comment">// 路由信息的计算属性</span></span><br><span class="line">    <span class="comment">// routes() &#123;</span></span><br><span class="line">    <span class="comment">//   // 返回所有的路由信息</span></span><br><span class="line">    <span class="comment">//   return this.$router.options.routes</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案 1：菜单与路由分离，菜单由后端返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">name字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;login&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/pages/Login.vue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是对应的，后端返回的菜单就已经是经过权限过滤的。若根据路由name找不到对应的菜单，就表示用户有没权限访问。</span><br><span class="line"></span><br><span class="line">如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载（路由权限方法<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line">这种方式的缺点：</span><br><span class="line">菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</span><br><span class="line">全局路由守卫里，每次路由跳转都要做判断</span><br></pre></td></tr></table></figure>
<p>方案 2：菜单和路由都由后端返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端统一定义路由组件：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../pages/Home.vue&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserInfo</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../pages/UserInfo.vue&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">home</span>: <span class="title class_">Home</span>,</span><br><span class="line">    <span class="attr">userInfo</span>: <span class="title class_">UserInfo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后端路由组件返回以下格式：</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">&quot;home&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/userinfo&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">&quot;userInfo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件</span><br><span class="line">如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理</span><br><span class="line"></span><br><span class="line">这种方法也会存在缺点：全局路由守卫里，每次路由跳转都要做判断；前后端的配合要求更高</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>按钮权限</strong></li>
</ul>
<p>方案 1：用<code>v-if</code>判断。但如果页面过多，每个页面页面都要获取用户权限<code>role</code>和路由表里的<code>meta.btnPermissions</code>，然后再做判断。</p>
<p>方案 2：通过自定义指令进行按钮权限的判断（⭐）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装自定义指令 用来控制操作权</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;permission&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 会在指令作用的元素插入到页面完成以后触发</span></span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(el) <span class="comment">// el 指令作用的元素的dom对象</span></span><br><span class="line">    <span class="keyword">const</span> points = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>?.<span class="property">roles</span>?.<span class="property">points</span> || [] <span class="comment">// 当前用户信息的操作权</span></span><br><span class="line">    <span class="keyword">if</span> (!points.<span class="title function_">includes</span>(binding.<span class="property">value</span>))&#123; <span class="comment">// 不存在就要删除或者禁用</span></span><br><span class="line">      el.<span class="title function_">remove</span>() <span class="comment">// 删除元素</span></span><br><span class="line">      <span class="comment">// el.disabled = true</span></span><br><span class="line">      <span class="comment">// 线上的权限数据和线下的代码进行对应</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用自定义指令</span></span><br><span class="line">&lt;el-button v-permission=<span class="string">&quot;&#x27;add-employee&#x27;&quot;</span> size=<span class="string">&quot;mini&quot;</span> type=<span class="string">&quot;primary&quot;</span> @click=<span class="string">&quot;$router.push(&#x27;/employee/detail&#x27;)&quot;</span>&gt;</span><br><span class="line">  添加员工</span><br><span class="line">&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2、vuex管理"><a href="#2、vuex管理" class="headerlink" title="2、vuex管理"></a>2、<code>vuex</code>管理</h4><blockquote>
<p>在<code>vuex</code>中对<code>token</code>进行管理，将用户的<code>token</code>状态共享，实现后续高效目方便的读取。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">项目登录流程：表单校验通过 --&gt; 调用<span class="title class_">Vuex</span>提供的登录的action --&gt; 登录的<span class="title class_">Action</span>中会调用接口 --&gt; 登录接口如果成功执行，会返回token --&gt; 利用<span class="title class_">Vuex</span>特性，将token共享的到<span class="title class_">Vuex</span>中，这样直接通过 <span class="title class_">Vuex</span> 就可以登录接口会调用单独封装的请求模块(api) --&gt; 请求模块中又会使用用到 axios 封装的请求工具 --&gt; 而请求工具又要考虑区分 开发环境和生产环境的问题 --&gt; 请求时还要考虑前后分离项目产生的跨域问题，要使用代理解决跨域</span><br><span class="line"><span class="title class_">Vuex</span>中声明用户信息状态，修改用户信息的mutations， 和获取用户信息的action</span><br><span class="line">实现token的<span class="title class_">Vue</span>数据持久化</span><br><span class="line"><span class="keyword">import</span> &#123; getToken, setToken, removeToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; login, getUserInfo &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; constantRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; resetRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">token</span>: <span class="title function_">getToken</span>(), <span class="comment">// 从缓存中读取初始值</span></span><br><span class="line">  <span class="attr">userInfo</span>: &#123;&#125;, <span class="comment">// 存储用户基本资料状态</span></span><br><span class="line">  <span class="attr">routes</span>: constantRoutes <span class="comment">// 静态路由的数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="title function_">setToken</span>(<span class="params">state, token</span>) &#123;</span><br><span class="line">    state.<span class="property">token</span> = token</span><br><span class="line">    <span class="title function_">setToken</span>(token) <span class="comment">// 同步到缓存</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">removeToken</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">token</span> = <span class="literal">null</span> <span class="comment">// 删除Vuex的token</span></span><br><span class="line">    <span class="title function_">removeToken</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setUserInfo</span>(<span class="params">state, userInfo</span>) &#123;</span><br><span class="line">    state.<span class="property">userInfo</span> = userInfo</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setRoutes</span>(<span class="params">state, newRoutes</span>) &#123;</span><br><span class="line">    state.<span class="property">routes</span> = [...constantRoutes, ...newRoutes] <span class="comment">// 静态路由 + 动态路由</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">login</span>(<span class="params">context, data</span>) &#123;<span class="comment">// context上下文，传入参数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    <span class="comment">// todo: 调用登录接口</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="keyword">await</span> <span class="title function_">login</span>(data)</span><br><span class="line">    <span class="comment">// 返回一个token 123456</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;setToken&#x27;</span>, token)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getUserInfo</span>(<span class="params">context</span>) &#123;<span class="comment">// 获取用户的基本资料</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getUserInfo</span>()</span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;setUserInfo&#x27;</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result <span class="comment">// 返回数据</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// token失效响应拦截器异常，会调用退出登录action</span></span><br><span class="line">  <span class="title function_">logout</span>(<span class="params">context</span>) &#123; <span class="comment">// 退出登录的action</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;removeToken&#x27;</span>) <span class="comment">// 删除token</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;setUserInfo&#x27;</span>, &#123;&#125;) <span class="comment">// 设置用户信息为空对象</span></span><br><span class="line">    <span class="title function_">resetRouter</span>()<span class="comment">// 重置路由</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用户信息不同于token，token是当前用户的唯一标识，在几个小时内都是有效的，但是用户信息可能会进行修改或者发生变化，所以用户信息在一般的项目或者业务中不进行缓存。</span><br></pre></td></tr></table></figure>
<h4 id="3、excel导入导出"><a href="#3、excel导入导出" class="headerlink" title="3、excel导入导出"></a>3、<code>excel</code>导入导出</h4><blockquote>
<p>使用 FileSaver.js 第三方库实现员工信息 excel 文件的导入导出。</p>
</blockquote>
<ul>
<li>员工管理 - excel 导出</li>
</ul>
<p>导出员工接口返回的是二进制流，axios 配置 responseType 为 blob 接收二进制流文件为 Blob 格式。安装 file-saver 包，实现下载 Blob 文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>封装导出员工excel的<span class="variable constant_">API</span></span><br><span class="line"><span class="comment">// 导出员工的excel</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">exportEmployee</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/sys/user/export&#x27;</span>,</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span> <span class="comment">// 改变接收数据的类型：使用blob接收二进制文件流</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>拦截器判断是不是blob类型，如果是直接返回数据，不再进行解构</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// axios默认包裹了data，判断是不是Blob</span></span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">data</span> <span class="keyword">instanceof</span> <span class="title class_">Blob</span>) <span class="keyword">return</span> response.<span class="property">data</span> <span class="comment">// 返回了Blob对象</span></span><br><span class="line">  <span class="keyword">const</span> &#123; data, message, success &#125; = response.<span class="property">data</span> <span class="comment">// 默认json格式</span></span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title class_">Message</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>, message &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(message))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>点击按钮调用接口，使用file-saver将blob转化成文件下载</span><br><span class="line">&lt;el-button size=<span class="string">&quot;mini&quot;</span> @click=<span class="string">&quot;exportEmployee&quot;</span>&gt;excel导出&lt;/el-button&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FileSaver</span> <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportEmployee &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/employee&#x27;</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">exportEmployee</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">exportEmployee</span>() <span class="comment">// 导出所有的员工接口</span></span><br><span class="line">  <span class="comment">// FileSaver.saveAs(blob对象, 文件名称)</span></span><br><span class="line">  <span class="title class_">FileSaver</span>.<span class="title function_">saveAs</span>(result, <span class="string">&#x27;员工信息表.xlsx&#x27;</span>) <span class="comment">// 下载文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>员工管理 - excel 导入</li>
</ul>
<p><code>创建组件 --&gt; 点击按钮弹出组件 --&gt; 下载模板、上传excel、拖拽上传 --&gt; 导入成功、取消 --&gt; 关闭并重新加载、关闭</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>下载导入模板：调用下载模板接口 --&gt; 接收二进制blob --&gt; 下载文件</span><br><span class="line"><span class="comment">// 下载员工导入模版api</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getExportTemplate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/sys/user/import/template&#x27;</span>,</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span> <span class="comment">// 二进制文件流</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点击按钮进行下载模板</span></span><br><span class="line">&lt;el-button type=<span class="string">&quot;text&quot;</span> @click=<span class="string">&quot;getTemplate&quot;</span>&gt;下载导入模板&lt;/el-button&gt;</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getTemplate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">getExportTemplate</span>()</span><br><span class="line">  <span class="title class_">FileSaver</span>.<span class="title function_">saveAs</span>(data, <span class="string">&#x27;员工导入模版.xlsx&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>上传excel：弹出文件选择框 --&gt; 文件选择 --&gt; 调用上传接口 --&gt; 成功 --&gt; 重新加载数据-关闭弹窗 --&gt; 清空文件选择器</span><br><span class="line"><span class="comment">// 1、封装上传excel的API：上传用户的excel</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">uploadExcel</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/sys/user/import&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data <span class="comment">// form-data类型 因为要上传文件类型</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、点击上传-弹出文件选择框</span></span><br><span class="line">&lt;el-button type=<span class="string">&quot;text&quot;</span> @click=<span class="string">&quot;handleUpload&quot;</span>&gt;点击上传&lt;/el-button&gt;</span><br><span class="line"><span class="title function_">handleUpload</span>(<span class="params"></span>) &#123; <span class="comment">// 触发文件选择框的input的输入框，绑定ref值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>[<span class="string">&#x27;excel-upload-input&#x27;</span>].<span class="title function_">click</span>() <span class="comment">// this.$refs.属性名 和 this.$refs[属性名] 等价</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 3、监听文件改变-上传excel-关闭弹层</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">ref</span>=<span class="string">&quot;excel-upload-input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">class</span>=<span class="string">&quot;excel-upload-input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">accept</span>=<span class="string">&quot;.xlsx, .xls&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  @<span class="attr">change</span>=<span class="string">&quot;uploadChange&quot;</span> // ⭐</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">async uploadChange(event) &#123; // event.target.files[0]内为excel文件</span></span><br><span class="line"><span class="language-xml">  // 调用上传接口：uploadExcel() 中参数form-data 需要文件file</span></span><br><span class="line"><span class="language-xml">  const files = event.target.files // 文件选择框的input的文件列表</span></span><br><span class="line"><span class="language-xml">  if (files.length &gt; 0) &#123;// 大于0 说明有文件要上传</span></span><br><span class="line"><span class="language-xml">    const data = new FormData()</span></span><br><span class="line"><span class="language-xml">    data.append(&#x27;file&#x27;, files[0]) // file: file类型，将文件参数加入到formData中</span></span><br><span class="line"><span class="language-xml">    try &#123;</span></span><br><span class="line"><span class="language-xml">      await uploadExcel(data)</span></span><br><span class="line"><span class="language-xml">      this.$emit(&#x27;uploadSuccess&#x27;) // 通知父组件上传成功 -&gt; 重新加载数据</span></span><br><span class="line"><span class="language-xml">      this.$emit(&#x27;update:showExcelDialog&#x27;, false) // 关闭弹层</span></span><br><span class="line"><span class="language-xml">      // this.$refs[&#x27;excel-upload-input&#x27;].value = &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">    &#125; catch (error) &#123;// 捕获失败</span></span><br><span class="line"><span class="language-xml">      // this.$refs[&#x27;excel-upload-input&#x27;].value = &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">    &#125; finally &#123;</span></span><br><span class="line"><span class="language-xml">      // 不论成功或者失败都会执行finally，所以在这里执行清空文件选择器操作</span></span><br><span class="line"><span class="language-xml">      this.$refs[&#x27;excel-upload-input&#x27;].value = &#x27;&#x27;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">// 4、父组件需要监听上传成功的事件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">import-excel</span> <span class="attr">:show-excel-dialog.sync</span>=<span class="string">&quot;showExcelDialog&quot;</span> @<span class="attr">uploadSuccess</span>=<span class="string">&quot;getEmployeeList&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="4、递归列表转树"><a href="#4、递归列表转树" class="headerlink" title="4、递归列表转树"></a>4、递归列表转树</h4><blockquote>
<p>使用递归算法将组织架构的树形组件中的列表型结构转换为树形结构。</p>
</blockquote>
<p>树形组件-用层级结构展示信息，可展开或折叠，<code>element-ui</code>提供了树组件<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN/component/tree">el-tree</a>的应用</p>
<p>default-expand-all (默认展开所有节点)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022013813.png" alt=""></p>
<ol>
<li>首先分析数据的关联关系（部门 id 是子部门的 pid）</li>
<li>封装递归函数根据关联关系转化层级结构</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://izdloyl-blog.oss-cn-hangzhou.aliyuncs.com/202408022013695.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、获取组织架构数据：① 封装获取组织的<span class="variable constant_">API</span>   ② 在组织架构初始化时调用方法</span><br><span class="line"><span class="comment">// 封装获取组织的API</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"><span class="comment">// 获取组织架构数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getDepartment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/company/department&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在组织架构初始化时调用方法</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; getDepartment &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/department&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>  &#123;</span><br><span class="line">      <span class="attr">depts</span>: [],</span><br><span class="line">      <span class="attr">defaultProps</span>: &#123;</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;children&#x27;</span>, <span class="comment">// 设置子节点的字段名</span></span><br><span class="line">        <span class="attr">label</span>: <span class="string">&#x27;name&#x27;</span> <span class="comment">// 设置显示内容的字段名</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getDepartment</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">   <span class="keyword">async</span> <span class="title function_">getDepartment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getDepartment</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depts</span> = result</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、递归转化树形结构</span><br><span class="line"><span class="comment">// 封装方法：列表型数据转化树形</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">transListToTreeData</span>(<span class="params">list, rootValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  list.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">pid</span> === rootValue) &#123;<span class="comment">// 找到了匹配的节点</span></span><br><span class="line">      <span class="comment">// 当前节点的id 和 当前节点的子节点的pid是想等的</span></span><br><span class="line">      <span class="keyword">const</span> children = <span class="title function_">transListToTreeData</span>(list, item.<span class="property">id</span>) <span class="comment">// 找到的节点的子节点⭐</span></span><br><span class="line">      item.<span class="property">children</span> = children  <span class="comment">// 将子节点赋值给当前节点</span></span><br><span class="line">      arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取完的组织数据使用转化方法转化成树形</span></span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getDepartment</span>() <span class="comment">// 调用获取数据的接口</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getDepartment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getDepartment</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depts</span> = <span class="title function_">transListToTreeData</span>(result, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归特点：① 一般用来处理未知层级的数据 ② 递归要有跳出条件 ③ 自身调用自身时参数不能重复</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型（栈）：直接存储在内存中的数据，值不可变</span><br><span class="line">	<span class="title class_">Number</span>、<span class="title class_">String</span>、<span class="title class_">Boolean</span>、<span class="title class_">Null</span>-空值、<span class="title class_">Undefined</span>-未定义、<span class="title class_">Symbol</span>(<span class="title class_">ES6</span>)、<span class="title class_">BigInt</span>(<span class="title class_">ES2020</span>)</span><br><span class="line">	- <span class="title class_">Number</span>特殊值：<span class="title class_">Infinity</span>-正无穷大、-<span class="title class_">Infinity</span>-负无穷大、<span class="title class_">NaN</span>-非数值</span><br><span class="line">  - 当使用 <span class="keyword">var</span>或 <span class="keyword">let</span>声明了变量但没有初始化时，就相当于给变量赋予了 <span class="literal">undefined</span>值</span><br><span class="line">	- <span class="title class_">Symbol</span>：表示一个独一无二的值，通常用于对象属性的唯一标识符。</span><br><span class="line">	- <span class="title class_">BigInt</span>：表示任意大的整数，用来处理超过<span class="title class_">Number</span>类型能表示的安全整数范围<span class="number">2</span>^<span class="number">53</span>-<span class="number">1</span></span><br><span class="line">引用数据类型（堆）：存储的是对象的地址或引用，变量保存的是指向内存中某个对象的引用，而不是实际的值。</span><br><span class="line">	- <span class="title class_">Object</span>、<span class="title class_">Array</span>、<span class="title class_">Function</span>、<span class="title class_">Date</span>、<span class="title class_">RegExp</span>(正则表达式)、<span class="title class_">Map</span>和<span class="title class_">Set</span>(<span class="title class_">ES6</span>)</span><br><span class="line">	- <span class="title class_">Map</span> 是一个键值对的集合，键可以是任意类型;<span class="title class_">Set</span> 是一个值的集合，值都是唯一的。</span><br></pre></td></tr></table></figure>
<h3 id="判断数据类型的方法及区别"><a href="#判断数据类型的方法及区别" class="headerlink" title="判断数据类型的方法及区别"></a>判断数据类型的方法及区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">typeof</span> - 主要用于检测基本数据类型</span><br><span class="line">	注意：<span class="literal">null</span> 返回的是 <span class="title class_">Object</span> （js缺陷）；且对于引用类型</span><br><span class="line">       返回的都是 object 因为所有的对象的原型最终都是 <span class="title class_">Object</span>。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">instanceof</span> - 用于检查某个对象是否是某个类或构造函数的实例，</span><br><span class="line">			主要用于判断复杂的引用类型。原理就是查找目标对象的原型链。</span><br><span class="line">	示例：[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//true  function()&#123;&#125; instanceof Function // true</span></span><br><span class="line"><span class="number">3</span>、<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>() - 更精确的方法，适用于判断所有类型。</span><br><span class="line">	示例：<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line">       <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/regex/</span>) <span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line">	手写：<span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>)); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="number">4</span>、constructor 属性 - 每个<span class="variable constant_">JS</span>对象都有，用于指向创建该对象的构造函数。可通过该属性判断类型。</span><br><span class="line">	注意：①<span class="literal">null</span> 和 <span class="literal">undefined</span>是无效的对象，不会有 constructor 存在，无法据此属性判断。</span><br><span class="line">			 ②<span class="variable constant_">JS</span>对象的 constructor 是不稳定的，主要体现在自定义对象上，当开发者重写</span><br><span class="line">       prototype 后，原有的 constructor会丢失，constructor 会默认为<span class="title class_">Object</span>。</span><br><span class="line">        ③类继承的也会出错，因为 <span class="title class_">Object</span> 被覆盖了，检测结果就不对了。</span><br><span class="line"><span class="number">5</span>、<span class="title class_">Array</span>.<span class="title function_">isArray</span>() - 专门用于判断某个值是否为数组，返回<span class="literal">true</span>/<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">【作用域】：全局作用域、函数作用域、块级作用域（在大括号中使用<span class="keyword">let</span>和<span class="keyword">const</span>声明的变量）</span><br><span class="line">【作用域链的作用】是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</span><br><span class="line">【原型】：每个构造函数都有prototype属性，称之为原型 | 原型对象。</span><br><span class="line">  原型可以放一些属性和方法，共享给实例对象使用</span><br><span class="line">  原型可以做继承</span><br><span class="line">【原型链】：当访问一个对象的属性时，如果这个对象内部不存在这个属性，</span><br><span class="line">那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，</span><br><span class="line">于是就这样一直找下去，也就是原型链的概念。（ 对象都有__proto__ 属性，</span><br><span class="line">这个属性指向它的原型对象，而原型对象也是对象，也有 __proto__ 属性，</span><br><span class="line">指向原型对象的原型对象,这样一层一层形成的链式结构称为原型链，最顶层找不到则返回 <span class="literal">null</span> ）</span><br><span class="line"></span><br><span class="line">由于<span class="title class_">Object</span>是构造函数，原型链终点是<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>，而</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>=== <span class="literal">null</span> <span class="comment">// true，所以，原型链的终点是null</span></span><br><span class="line"></span><br><span class="line">【访问一个对象的原型对象】：</span><br><span class="line"><span class="number">1.</span> 对象.<span class="property">__proto__</span>  指向构造函数的prototype</span><br><span class="line"><span class="number">2.</span> <span class="title class_">Object</span>.<span class="title function_">getPrototypeof</span>(对象)         更安全！！</span><br><span class="line"></span><br><span class="line">【原型对象中的数据】：</span><br><span class="line"><span class="number">1.</span> 对象中的数据（属性、方法等）</span><br><span class="line"><span class="number">2.</span> <span class="title function_">constructor</span>(<span class="params">对象的构造函数）</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">【与作用域链区别】：作用域链是找【变量】的链，找不到会报错；原型链</span></span><br><span class="line"><span class="params">是找【属性】的链，找不到会返回 <span class="literal">undefined</span> 。</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">【原型的作用】：原型就相当于是一个公共的区域，可以被所有该类实例访问，</span></span><br><span class="line"><span class="params">可以将一个该类实例中，所有的公共属性（方法）统一存储到原型中，</span></span><br><span class="line"><span class="params">这样只需要创建一个属性，即可被所有实例访问。</span></span><br><span class="line"><span class="params">JS 中继承就是通过原型来实现的，当继承时，子类的原型就是一个父类的实例</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">instanceof</span> 检查的是对象的原型链上是否有该类实例。返回 <span class="literal">true</span> / <span class="literal">false</span> 。    </span></span><br><span class="line"><span class="params"><span class="built_in">Object</span> 是所有对象的原型，任何和对象和 <span class="built_in">Object</span> 进行 <span class="keyword">instanceof</span> 运算都会返回 <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">【大部分情况下是不需要修改原型对象】</span></span><br><span class="line"><span class="params">- 注意：千万不要通过类的实例去修改原型</span></span><br><span class="line"><span class="params">- 处了通过 __proto__ 能访问对象的原型外，还可以通过类的 prototype 属性，</span></span><br><span class="line"><span class="params">来访问实例的原型修改原型时，最好通过通过类去修改。</span></span><br><span class="line"><span class="params">- 好处：① 一修改就是修改所有实例的原型  ②无需创建实例即可完成对类的修改</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包和内存泄露"><a href="#闭包和内存泄露" class="headerlink" title="闭包和内存泄露"></a>闭包和内存泄露</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">闭包是指有权访问另一个函数作用域中变量的函数</span><br><span class="line">形成闭包的原因：内部的函数存在外部作用域的引用就会导致闭包。</span><br><span class="line">闭包特性：函数嵌套函数、函数内部可以引用函数外部的参数和变量、</span><br><span class="line">				参数和变量不会被垃圾回收机制回收。</span><br><span class="line"></span><br><span class="line">闭包的作用：</span><br><span class="line"><span class="number">1</span>、用于封装私有变量，保护函数私有变量不受外部的访问和修改。</span><br><span class="line"><span class="number">2</span>、通常情况下，函数执行完毕后，函数内部的局部变量就会被销毁。</span><br><span class="line">但闭包可使局部变量在函数执行结束后依然存在，进而实现数据的持久化。</span><br><span class="line"><span class="number">3</span>、防抖节流、柯里化</span><br><span class="line"></span><br><span class="line">闭包导致内存泄漏：</span><br><span class="line"><span class="number">1.</span>代码中存在不再需要的函数引用，导致函数关联的词法环境无法销毁；</span><br><span class="line"><span class="number">2.</span>当多个函数共享词法环境时，会导致出现无法触达也无法回收的内存空间</span><br><span class="line">- 如何避免：</span><br><span class="line">在退出函数之前，将不使用的局部变量全部删除，或赋值为<span class="literal">null</span>;</span><br><span class="line">避免变量的循环引用和赋值</span><br><span class="line"></span><br><span class="line">闭包与异步执行函数：（<span class="keyword">for</span>循环中 + setTimeOut）</span><br><span class="line"><span class="number">1.</span><span class="title class_">ES6</span>中<span class="keyword">let</span>，<span class="keyword">for</span>循环变块级作用域（原先i是全局）</span><br><span class="line"><span class="number">2.</span>立即执行函数（函数作用域可以保存变量）</span><br><span class="line"></span><br><span class="line">以下四种情况会造成内存泄漏：</span><br><span class="line"><span class="number">1</span>、意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class="line"><span class="number">2</span>、被遗忘的计时器或回调函数：设置了 <span class="built_in">setInterval</span> 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</span><br><span class="line"><span class="number">3</span>、脱离 <span class="variable constant_">DOM</span> 的引用： 获取一个 <span class="variable constant_">DOM</span> 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</span><br><span class="line"><span class="number">4</span>、闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用于复制对象和数组</span><br><span class="line">1、浅拷贝</span><br><span class="line">	只复制对象的第一层属性。如果属性是基本类型，拷贝的就是基本类型的值；</span><br><span class="line">	如果属性是引用类型（如对象或数组），浅拷贝将引用地址赋给新的对象。</span><br><span class="line">	因此，如果修改嵌套对象或数组，浅拷贝和原对象都会受到影响。</span><br><span class="line">	浅拷贝的方式：Object.assign()、Array.slice(), Array.concat()、扩展运算符（...）</span><br><span class="line">2、深拷贝</span><br><span class="line">	会递归地复制对象中的所有属性，无论是基本类型还是引用类型。</span><br><span class="line">	改变拷贝后新对象的值，不会影响原对象的值。</span><br><span class="line">	深拷贝的方式：JSON.parse(JSON.stringify())</span><br></pre></td></tr></table></figure>
<h3 id="async-await-的理解"><a href="#async-await-的理解" class="headerlink" title="async/await 的理解"></a>async/await 的理解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【async 关键字】：async 用于定义一个异步函数。</span><br><span class="line">async 函数会自动返回一个 Promise 对象。若函数有返回值，那这个值会被 Promise.resolve() 包装成一个 Promise 返回。无返回值则，Promise.resolve(undefined)</span><br><span class="line">【await 关键字】：用于等待Promise完成，只能在 async 函数中使用。</span><br><span class="line">当遇到 await 时，函数执行会暂停，直到 Promise 状态变为 resolved（成功），并返回 Promise 的结果。await 后面跟着的是一个 Promise，它会暂停代码执行直到 Promise 完成。</span><br></pre></td></tr></table></figure>
<h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>箭头函数</span><br><span class="line"><span class="number">2.</span>解构赋值</span><br><span class="line"><span class="number">3.</span>模板字符串</span><br><span class="line"><span class="number">4.</span>promise</span><br><span class="line"><span class="number">5.</span>symbol <span class="title class_">Symbol</span>:基本数据类型,用于表示一个独一无二的值,不能与其他数据类型进行运算</span><br><span class="line"><span class="number">6.</span>新的变量声明方式-<span class="keyword">let</span>和<span class="keyword">const</span></span><br><span class="line"><span class="number">7.</span>模块化-es6新增了模块化，根据功能封装模块，通过<span class="keyword">import</span>导入，然后通过<span class="keyword">export</span>导出也可以使用<span class="keyword">export</span> <span class="keyword">default</span>导出</span><br><span class="line"><span class="number">8.</span><span class="keyword">for</span>…<span class="keyword">of</span> 循环,用于遍历可迭代对象(如数组、<span class="title class_">Map</span> 和 <span class="title class_">Set</span>)中的元素</span><br><span class="line"><span class="number">9.</span>扩展运算符:使用 ... 可以将数组或对象展开成多个参数,或者将多个参数合并成一个数组</span><br><span class="line"><span class="number">10.</span>展开运算符:在<span class="title class_">ES6</span>中用...来表示展开运算符,它可以将数组或者对象进行展开</span><br><span class="line"><span class="number">11.</span><span class="title class_">Map</span> 和 <span class="title class_">Set</span>，引入了两种新的数据结构，分别用于存储键值对和唯一值</span><br><span class="line"><span class="number">12.</span><span class="title class_">Proxy</span>，允许在对象和函数调用等操作前后添加自定义的行为</span><br><span class="line"><span class="number">13.</span>类（<span class="title class_">Class</span>），引入了面向对象编程中类的概念</span><br><span class="line"><span class="number">14.</span>默认参数（<span class="title class_">Default</span> <span class="title class_">Parameter</span>），在定义函数时可以给参数设置默认值</span><br></pre></td></tr></table></figure>
<h3 id="事件循环（-调用堆栈和任务队列）"><a href="#事件循环（-调用堆栈和任务队列）" class="headerlink" title="事件循环（ 调用堆栈和任务队列）"></a>事件循环（ 调用堆栈和任务队列）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行</span><br></pre></td></tr></table></figure>
<h3 id="let、const、var区别"><a href="#let、const、var区别" class="headerlink" title="let、const、var区别"></a>let、const、var区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）块级作用域： <span class="keyword">let</span>和<span class="keyword">const</span>具有块级作用域，<span class="keyword">var</span>不存在块级作用域。</span><br><span class="line"><span class="number">2</span>）变量提升： <span class="keyword">var</span>存在变量提升，<span class="keyword">let</span>和<span class="keyword">const</span>不存在变量提升（变量只能在声明之后使用）。</span><br><span class="line"><span class="number">3</span>）给全局添加属性： 浏览器的全局对象是<span class="variable language_">window</span>，<span class="title class_">Node</span>的全局对象是<span class="variable language_">global</span>。</span><br><span class="line"><span class="keyword">var</span>声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但<span class="keyword">let</span>和<span class="keyword">const</span>不会。</span><br><span class="line"><span class="number">4</span>）重复声明： <span class="keyword">var</span>声明变量时，可以重复声明，后声明的同名变量会覆盖之前声明的。</span><br><span class="line"><span class="keyword">const</span>和<span class="keyword">let</span>不允许。</span><br><span class="line"><span class="number">5</span>）暂时性死区： 在使用<span class="keyword">let</span>、<span class="keyword">const</span>命令声明变量之前，该变量都是不可用的。</span><br><span class="line">这在语法上，称为暂时性死区。使用<span class="keyword">var</span>声明的变量不存在暂时性死区。</span><br><span class="line"><span class="number">6</span>）初始值设置： 变量声明时，<span class="keyword">var</span> 和 <span class="keyword">let</span> 可不用设置初始值。而<span class="keyword">const</span>必须设置。</span><br><span class="line"><span class="number">7</span>）指针指向： <span class="keyword">let</span>创建的变量是可以更改指针指向（重新赋值）。但<span class="keyword">const</span>是不允许的。</span><br></pre></td></tr></table></figure>
<h3 id="和"><a href="#和" class="headerlink" title="==和==="></a><code>==</code>和<code>===</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">等于操作符（==）：</span><br><span class="line">	在比较中会先进行类型转换，再确定操作数是否相等。如果操作数相等，则会返回 <span class="literal">true</span>。</span><br><span class="line">	<span class="number">1</span>、两个都为简单类型，字符串和布尔值都会转换成数值，再比较</span><br><span class="line">	<span class="number">2</span>、简单类型与引用类型比较，对象转化成其原始类型的值，再比较</span><br><span class="line">	<span class="number">3</span>、两个都为引用类型，则比较它们是否指向同一个对象</span><br><span class="line">	<span class="number">4</span>、<span class="literal">null</span> 和 <span class="literal">undefined</span> 相等</span><br><span class="line">	<span class="number">5</span>、存在 <span class="title class_">NaN</span> 则返回 <span class="literal">false</span></span><br><span class="line">全等操作符（===）：</span><br><span class="line">	只有两个操作数在不转换的前提下相等才返回 <span class="literal">true</span>。即类型相同，值也需相同</span><br><span class="line">【区别】：</span><br><span class="line">	相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换</span><br><span class="line">	<span class="literal">null</span> 和 <span class="literal">undefined</span> 比较，相等操作符（==）为<span class="literal">true</span>，全等为<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="数组原生方法"><a href="#数组原生方法" class="headerlink" title="数组原生方法"></a>数组原生方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、数组和【字符串】的转换方法：<span class="title function_">toString</span>()、<span class="title function_">toLocalString</span>()、<span class="title function_">join</span>() </span><br><span class="line">其中 <span class="title function_">join</span>() 方法可以指定转换为字符串时的分隔符。</span><br><span class="line"><span class="number">2</span>、数组【尾部】操作的方法 <span class="title function_">pop</span>() 和 <span class="title function_">push</span>()，push 方法可以传入多个参数。</span><br><span class="line"><span class="number">3</span>、数组【首部】操作的方法 <span class="title function_">shift</span>() 和 <span class="title function_">unshift</span>() </span><br><span class="line">重排序的方法 <span class="title function_">reverse</span>() 和 <span class="title function_">sort</span>()，<span class="title function_">sort</span>() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</span><br><span class="line"><span class="number">4</span>、数组连接的方法 <span class="title function_">concat</span>() ，返回的是拼接好的数组，不影响原数组。</span><br><span class="line"><span class="number">5</span>、数组截取办法 <span class="title function_">slice</span>()，用于截取数组中的一部分返回，不影响原数组。</span><br><span class="line"><span class="number">6</span>、数组插入方法 <span class="title function_">splice</span>()，影响原数组查找特定项的索引的方法，<span class="title function_">indexOf</span>() 和 <span class="title function_">lastIndexOf</span>() 迭代方法 <span class="title function_">every</span>()、<span class="title function_">some</span>()、<span class="title function_">filter</span>()、<span class="title function_">map</span>() 和 <span class="title function_">forEach</span>() 方法</span><br><span class="line"><span class="number">7</span>、数组归并方法 <span class="title function_">reduce</span>() 和 <span class="title function_">reduceRight</span>() 方法</span><br></pre></td></tr></table></figure>
<h3 id="遍历数组对象"><a href="#遍历数组对象" class="headerlink" title="遍历数组对象"></a>遍历数组对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【<span class="keyword">for</span> <span class="keyword">in</span>和<span class="keyword">for</span> <span class="keyword">of</span>的区别】：<span class="keyword">for</span>…<span class="keyword">in</span> 会遍历对象的整个原型链</span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span> 循环主要是为了遍历对象而生，不适用于遍历数组；<span class="keyword">for</span>...<span class="keyword">of</span> 循环可以用来遍历数组、类数组对象，字符串、<span class="title class_">Set</span>、<span class="title class_">Map</span> 以及 <span class="title class_">Generator</span> 对象。</span><br><span class="line"></span><br><span class="line">【forEach和map的区别】：都是用来遍历数组的</span><br><span class="line"><span class="title function_">forEach</span>()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，没有返回值；</span><br><span class="line"><span class="title function_">map</span>()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</span><br></pre></td></tr></table></figure>
<h3 id="JS中的this"><a href="#JS中的this" class="headerlink" title="JS中的this"></a>JS中的this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span> 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、以函数形式调用时， <span class="variable language_">this</span> 指向的是 <span class="variable language_">window</span>全局作用域（优先级最低）</span><br><span class="line"><span class="number">2</span>、以方法的形式调用时，<span class="variable language_">this</span> 指向的是调用方法的对象（优先级再次）</span><br><span class="line"><span class="number">3</span>、构造器形式调用时，如果一个函数用 <span class="keyword">new</span> 调用时，函数执行前会新创建一个对象，</span><br><span class="line"><span class="variable language_">this</span> 指向这个新创建的对象。（优先级最高）</span><br><span class="line"><span class="number">4</span>、 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 <span class="variable language_">this</span> 指向。</span><br><span class="line">其中 apply 方法接收两个参数：一个是 <span class="variable language_">this</span> 绑定的对象，一个是参数数组。</span><br><span class="line">call 方法接收的参数，第一个是 <span class="variable language_">this</span> 绑定的对象，后面的其余参数是传入函数执行的参数。</span><br><span class="line">bind 方法通过传入一个对象，返回一个 <span class="variable language_">this</span> 绑定了传入对象的新函数。这个函数的 <span class="variable language_">this</span> 指向除了使用 <span class="keyword">new</span> 时会被改变，其他情况下都不会改变。（优先级其次）</span><br><span class="line"></span><br><span class="line">箭头函数没有自己的 <span class="variable language_">this</span> ，它只会在自己作用域的上一层继承 <span class="variable language_">this</span> 。</span><br><span class="line">箭头函数的 <span class="variable language_">this</span> 和它的调用方式无关</span><br></pre></td></tr></table></figure>
<h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>操作符的执行过程：</span><br><span class="line">（<span class="number">1</span>）首先创建了一个新的空对象</span><br><span class="line">（<span class="number">2</span>）设置原型，将对象的原型设置为函数的 prototype 对象。</span><br><span class="line">（<span class="number">3</span>）让函数的 <span class="variable language_">this</span> 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span><br><span class="line">（<span class="number">4</span>）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JavaScript</span>中的异步机制可以分为以下几种：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</span><br><span class="line"><span class="number">2</span>、<span class="title class_">Promise</span> 的方式，使用 <span class="title class_">Promise</span> 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</span><br><span class="line"><span class="number">3</span>、generator的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</span><br><span class="line"><span class="number">4</span>、<span class="keyword">async</span> 函数的方式，<span class="keyword">async</span> 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 <span class="keyword">await</span> 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate是<span class="keyword">new</span> <span class="title class_">Vue</span>()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</span><br><span class="line">created在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与<span class="title class_">Dom</span>进行交互，如果非要想，可以通过vm.<span class="property">$nextTick</span>来访问<span class="title class_">Dom</span>。</span><br><span class="line">beforeMount发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟<span class="title class_">Dom</span>已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。</span><br><span class="line">mounted在挂载完成后发生，在当前阶段，真实的<span class="title class_">Dom</span>挂载完毕，数据完成双向绑定，可以访问到<span class="title class_">Dom</span>节点，使用$refs属性对<span class="title class_">Dom</span>进行操作。</span><br><span class="line">beforeUpdate发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</span><br><span class="line">updated发生在更新完成之后，当前阶段组件<span class="title class_">Dom</span>已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</span><br><span class="line">beforeDestroy发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</span><br><span class="line">destroyed发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</span><br></pre></td></tr></table></figure>
<h3 id="vue2-3响应式原理"><a href="#vue2-3响应式原理" class="headerlink" title="vue2/3响应式原理"></a>vue2/3响应式原理</h3><p>Vue在初始化数据时，会使用<code>Object.defineProperty</code>重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的<code>watcher</code>)如果属性发生变化会通知相关依赖进行更新操作(<code>发布订阅</code>)。</p>
<p>Vue3.x改用<code>Proxy</code>替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p>
<blockquote>
<p>❝</p>
<p>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</p>
<p>❞</p>
</blockquote>
<p>（很简单啊）</p>
<p>判断当前Reflect.get的返回值是否为Object，如果是则再通过<code>reactive</code>方法做代理， 这样就实现了深度观测。</p>
<blockquote>
<p>❝</p>
<p>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</p>
<p>❞</p>
</blockquote>
<p>我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p>
<h3 id="vue3和vue2的区别"><a href="#vue3和vue2的区别" class="headerlink" title="vue3和vue2的区别"></a>vue3和vue2的区别</h3><ul>
<li>源码组织方式变化：使用 TS 重写</li>
<li>支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li>
<li>响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li>
<li>编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</li>
<li>打包体积优化：移除了一些不常用的api（inline-template、filter）</li>
<li>生命周期的变化：使用setup代替了之前的beforeCreate和created</li>
<li>Vue3 的 template 模板支持多个根标签</li>
<li>Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore</li>
<li>Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例</li>
<li>Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</li>
<li>父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</li>
</ul>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVVM是`Model-View-ViewModel`缩写，也就是把`MVC`中的`Controller`演变成`ViewModel`。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</span><br></pre></td></tr></table></figure>
<h3 id="5-在-Vue2-x-中如何检测数组的变化？"><a href="#5-在-Vue2-x-中如何检测数组的变化？" class="headerlink" title="5.在 Vue2.x 中如何检测数组的变化？"></a>5.在 Vue2.x 中如何检测数组的变化？</h3><p>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p>
<h3 id="6-v-model-双向绑定的原理是什么？"><a href="#6-v-model-双向绑定的原理是什么？" class="headerlink" title="6.v-model 双向绑定的原理是什么？"></a>6.v-model 双向绑定的原理是什么？</h3><p><code>v-model</code>本质就是一个语法糖，可以看成是<code>value + input</code>方法的语法糖。 可以通过model属性的<code>prop</code>和<code>event</code>属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。</p>
<h3 id="7-vue2-x-和-vuex3-x-渲染器的-diff-算法分别说一下？"><a href="#7-vue2-x-和-vuex3-x-渲染器的-diff-算法分别说一下？" class="headerlink" title="7.vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？"></a>7.vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？</h3><p>简单来说，diff算法有以下过程</p>
<ul>
<li>同级比较，再比较子节点</li>
<li>先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li>
<li>比较都有子节点的情况(核心diff)</li>
<li>递归比较子节点</li>
</ul>
<p>正常Diff两个树的时间复杂度是<code>O(n^3)</code>，但实际情况下我们很少会进行<code>跨层级的移动DOM</code>，所以Vue将Diff进行了优化，从<code>O(n^3) -&gt; O(n)</code>，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p>
<p>Vue2的核心Diff算法采用了<code>双端比较</code>的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p>
<p>Vue3.x借鉴了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flocalvoid%2Fivi">ivi</a>算法和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfernojs%2Finferno">inferno</a>算法</p>
<p>在创建VNode时就确定其类型，以及在<code>mount/patch</code>的过程中采用<code>位运算</code>来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)</p>
<p>该算法中还运用了<code>动态规划</code>的思想求解最长递归子序列。</p>
<h3 id="8-vue组件通信方式有哪些及原理"><a href="#8-vue组件通信方式有哪些及原理" class="headerlink" title="8.vue组件通信方式有哪些及原理"></a>8.vue组件通信方式有哪些及原理</h3><p>父子组件通信</p>
<p>父-&gt;子<code>props</code>，子-&gt;父 <code>$on、$emit</code></p>
<p>获取父子组件实例 <code>$parent、$children</code></p>
<p><code>Ref</code> 获取实例的方式调用组件的属性或者方法</p>
<p><code>Provide、inject</code> 官方不推荐使用，但是写组件库时很常用</p>
<p>兄弟组件通信</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript 代码解读复制代码<span class="title class_">Event</span> <span class="title class_">Bus</span><span class="string">` 实现跨组件通信 `</span><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span></span><br><span class="line"><span class="title class_">Vuex</span></span><br></pre></td></tr></table></figure>
<p>跨级组件通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash 代码解读复制代码Vuex</span><br><span class="line"><span class="variable">$attrs</span>、<span class="variable">$listeners</span></span><br></pre></td></tr></table></figure>
<h3 id="9-Vue的路由实现-hash路由和history路由实现原理说一下"><a href="#9-Vue的路由实现-hash路由和history路由实现原理说一下" class="headerlink" title="9.  Vue的路由实现, hash路由和history路由实现原理说一下"></a>9.  Vue的路由实现, hash路由和history路由实现原理说一下</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"> 代码解读</span><br><span class="line">复制代码<span class="string">`location.hash`</span>的值实际就是URL中<span class="string">`#`</span>后面的东西。</span><br></pre></td></tr></table></figure>
<p>history实际采用了HTML5中提供的API来实现，主要有<code>history.pushState()</code>和<code>history.replaceState()</code>。</p>
<h3 id="v-if-与-v-show-的区别"><a href="#v-if-与-v-show-的区别" class="headerlink" title="v-if 与 v-show 的区别"></a>v-if 与 v-show 的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当条件不成立时，`v-if`不会渲染DOM元素，`v-show`操作的是样式(display)，切换当前DOM的显示和隐藏。</span><br></pre></td></tr></table></figure>
<h3 id="11-keep-alive的常用属性有哪些及实现原理"><a href="#11-keep-alive的常用属性有哪些及实现原理" class="headerlink" title="11. keep-alive的常用属性有哪些及实现原理"></a>11. keep-alive的常用属性有哪些及实现原理</h3><p><code>keep-alive</code>可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p>
<p>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存。</p>
<p>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态。</p>
<p>keep-alive的中还运用了<code>LRU(Least Recently Used)</code>算法。</p>
<h3 id="12-nextTick-的作用是什么？他的实现原理是什么？"><a href="#12-nextTick-的作用是什么？他的实现原理是什么？" class="headerlink" title="12. nextTick 的作用是什么？他的实现原理是什么？"></a>12. nextTick 的作用是什么？他的实现原理是什么？</h3><p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li>Promise</li>
<li>MutationObserver</li>
<li>setImmediate</li>
<li>如果以上都不行则采用setTimeout</li>
</ul>
<p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>
<h3 id="13-说一下-Vue-SSR-的实现原理"><a href="#13-说一下-Vue-SSR-的实现原理" class="headerlink" title="13.说一下 Vue SSR 的实现原理"></a>13.说一下 Vue SSR 的实现原理</h3><p>SSR也就是服务端渲染，<code>也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</code>。</p>
<p>SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持<code>beforeCreate</code>和<code>created</code>两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。</p>
<h3 id="14-Vue-组件的-data-为什么必须是函数"><a href="#14-Vue-组件的-data-为什么必须是函数" class="headerlink" title="14.Vue 组件的 data 为什么必须是函数"></a>14.Vue 组件的 data 为什么必须是函数</h3><p>一个组件被复用多次的话，也就会创建多个实例。本质上，<code>这些实例用的都是同一个构造函数</code>。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</p>
<h3 id="15-说一下-Vue-的-computed-的实现原理"><a href="#15-说一下-Vue-的-computed-的实现原理" class="headerlink" title="15.说一下 Vue 的 computed 的实现原理"></a>15.说一下 Vue 的 computed 的实现原理</h3><p>当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。</p>
<p>它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖</p>
<p>但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。</p>
<p>收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty</p>
<p>value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined</p>
<p>dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true</p>
<p>Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中</p>
<p>当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。</p>
<p>如果 dirty 为 false，则直接返回 watcher 的 value</p>
<p>巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher</p>
<p>当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。</p>
<p>由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算</p>
<p>而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。</p>
<h3 id="16-说一下-Vue-complier-的实现原理是什么样的？"><a href="#16-说一下-Vue-complier-的实现原理是什么样的？" class="headerlink" title="16.说一下 Vue complier 的实现原理是什么样的？"></a>16.说一下 Vue complier 的实现原理是什么样的？</h3><p>在使用 vue 的时候，我们有两种方式来创建我们的 HTML 页面，第一种情况，也是大多情况下，我们会使用模板 template 的方式，因为这更易读易懂也是官方推荐的方法；第二种情况是使用 render 函数来生成 HTML，它比 template 更接近最终结果。</p>
<p>complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode</p>
<p>complier 主要分为 3 大块：</p>
<ul>
<li>parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast</li>
<li>optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能</li>
<li>generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数</li>
</ul>
<h3 id="Vue-与-React-区别"><a href="#Vue-与-React-区别" class="headerlink" title="Vue 与  React 区别"></a>Vue 与  React 区别</h3><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fv2.cn.vuejs.org%2Fv2%2Fguide%2Fcomparison.html%23React">React</a></p>
<p>React 和 Vue 有许多相似之处，它们都有：</p>
<ul>
<li>使用 Virtual DOM</li>
<li>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</li>
<li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li>
</ul>
<p>由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要承认 React 比 Vue 更好的地方，比如更丰富的生态系统。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fv2.cn.vuejs.org%2Fv2%2Fguide%2Fcomparison.html%23AngularJS-Angular-1">AngularJS (Angular 1)</a></p>
<p>Vue 的一些语法和 AngularJS 的很相似 (例如 <code>v-if</code> vs <code>ng-if</code>)。因为 AngularJS 是 Vue 早期开发的灵感来源。然而，AngularJS 中存在的许多问题，在 Vue 中已经得到解决。</p>
<p>详细可以参阅：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomparison.html">cn.vuejs.org/v2/guide/co…</a></p>
<p>建议面试前通读一遍该篇文档，然后进行适当的总结。</p>
<h3 id="18-说一下-watch-与-computed-的区别是什么？以及他们的使用场景分别是什么？"><a href="#18-说一下-watch-与-computed-的区别是什么？以及他们的使用场景分别是什么？" class="headerlink" title="18.说一下 watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？"></a>18.说一下 watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？</h3><p>区别：</p>
<ul>
<li>都是观察数据变化的（相同）</li>
<li>计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化；</li>
<li>computed 有缓存，它依赖的值变了才会重新计算，watch 没有；</li>
<li>watch 支持异步，computed 不支持；</li>
<li>watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）</li>
<li>watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；</li>
<li>computed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）</li>
</ul>
<p>watch 的 参数：</p>
<ul>
<li>deep：深度监听</li>
<li>immediate ：组件加载立即触发回调函数执行</li>
</ul>
<p>computed 缓存原理：</p>
<p>conputed本质是一个惰性的观察者；当计算数据存在于 data 或者 props里时会被警告；</p>
<p>vue 初次运行会对 computed 属性做初始化处理（initComputed），初始化的时候会对每一个 computed 属性用 watcher 包装起来 ，这里面会生成一个 dirty 属性值为 true；然后执行 defineComputed 函数来计算，计算之后会将 dirty 值变为 false，这里会根据 dirty 值来判断是否需要重新计算；如果属性依赖的数据发生变化，computed 的 watcher 会把 dirty 变为 true，这样就会重新计算 computed 属性的值。</p>
<h3 id="19-说一下你知道的-vue-修饰符都有哪些？"><a href="#19-说一下你知道的-vue-修饰符都有哪些？" class="headerlink" title="19.说一下你知道的 vue 修饰符都有哪些？"></a>19.说一下你知道的 vue 修饰符都有哪些？</h3><p>在 <em>vue</em> 中修饰符可以分为 <em>3</em> 类：</p>
<ul>
<li>事件修饰符</li>
<li>按键修饰符</li>
<li>表单修饰符</li>
</ul>
<p><strong>事件修饰符</strong></p>
<p>在事件处理程序中调用 <em>event.preventDefault</em> 或 <em>event.stopPropagation</em> 方法是非常常见的需求。尽管可以在 <em>methods</em> 中轻松实现这点，但更好的方式是：<em>methods</em> 只有纯粹的数据逻辑，而不是去处理 <em>DOM</em> 事件细节。</p>
<p>为了解决这个问题，<em>vue</em> 为 <em>v-on</em> 提供了事件修饰符。通过由点 <em>.</em> 表示的指令后缀来调用修饰符。</p>
<p>常见的事件修饰符如下：</p>
<ul>
<li><em>.stop</em>：阻止冒泡。</li>
<li><em>.prevent</em>：阻止默认事件。</li>
<li><em>.capture</em>：使用事件捕获模式。</li>
<li><em>.self</em>：只在当前元素本身触发。</li>
<li><em>.once</em>：只触发一次。</li>
<li><em>.passive</em>：默认行为将会立即触发。</li>
</ul>
<p><strong>按键修饰符</strong></p>
<p>除了事件修饰符以外，在 <em>vue</em> 中还提供了有鼠标修饰符，键值修饰符，系统修饰符等功能。</p>
<ul>
<li>.<em>left</em>：左键</li>
<li>.<em>right</em>：右键</li>
<li>.<em>middle</em>：滚轮</li>
<li>.<em>enter</em>：回车</li>
<li>.<em>tab</em>：制表键</li>
<li>.<em>delete</em>：捕获 “删除” 和 “退格” 键</li>
<li>.<em>esc</em>：返回</li>
<li>.<em>space</em>：空格</li>
<li>.<em>up</em>：上</li>
<li>.<em>down</em>：下</li>
<li>.<em>left</em>：左</li>
<li>.<em>right</em>：右</li>
<li>.<em>ctrl</em>：<em>ctrl</em> 键</li>
<li>.<em>alt</em>：<em>alt</em> 键</li>
<li>.<em>shift</em>：<em>shift</em> 键</li>
<li>.<em>meta</em>：<em>meta</em> 键</li>
</ul>
<p><strong>表单修饰符</strong></p>
<p><em>vue</em> 同样也为表单控件也提供了修饰符，常见的有 <em>.lazy</em>、 <em>.number</em> 和 <em>.trim</em>。</p>
<ul>
<li>.<em>lazy</em>：在文本框失去焦点时才会渲染</li>
<li>.<em>number</em>：将文本框中所输入的内容转换为number类型</li>
<li>.<em>trim</em>：可以自动过滤输入首尾的空格</li>
</ul>
<h3 id="实现-vue-项目中的性能优化"><a href="#实现-vue-项目中的性能优化" class="headerlink" title="实现 vue 项目中的性能优化"></a>实现 vue 项目中的性能优化</h3><p><strong>编码阶段</strong></p>
<ul>
<li>尽量减少 <em>data</em> 中的数据，<em>data</em> 中的数据都会增加 <em>getter</em> 和 <em>setter</em>，会收集对应的 <em>watcher</em></li>
<li><em>v-if</em> 和 <em>v-for</em> 不能连用</li>
<li>如果需要使用 <em>v-for</em> 给每项元素绑定事件时使用事件代理</li>
<li><em>SPA</em> 页面采用 <em>keep-alive</em> 缓存组件</li>
<li>在更多的情况下，使用 <em>v-if</em> 替代 <em>v-show</em></li>
<li><em>key</em> 保证唯一</li>
<li>使用路由懒加载、异步组件</li>
<li>防抖、节流</li>
<li>第三方模块按需导入</li>
<li>长列表滚动到可视区域动态加载</li>
<li>图片懒加载</li>
</ul>
<p><strong><em>SEO\</em> 优化</strong></p>
<ul>
<li>预渲染</li>
<li>服务端渲染 <em>SSR</em></li>
</ul>
<p><strong>打包优化</strong></p>
<ul>
<li>压缩代码</li>
<li><em>Tree Shaking/Scope Hoisting</em></li>
<li>使用 <em>cdn</em> 加载第三方模块</li>
<li>多线程打包 <em>happypack</em></li>
<li><em>splitChunks</em> 抽离公共文件</li>
<li><em>sourceMap</em> 优化</li>
</ul>
<p><strong>用户体验</strong></p>
<ul>
<li>骨架屏</li>
<li><em>PWA</em></li>
</ul>
<p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 <em>gzip</em> 压缩等。</p>
<h3 id="21-vue-中的-spa-应用如何优化首屏加载速度"><a href="#21-vue-中的-spa-应用如何优化首屏加载速度" class="headerlink" title="21.vue 中的 spa 应用如何优化首屏加载速度?"></a>21.vue 中的 spa 应用如何优化首屏加载速度?</h3><p>优化首屏加载可以从这几个方面开始：</p>
<ul>
<li>请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</li>
<li>缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验</li>
<li>gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。</li>
<li>http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。</li>
<li>懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件</li>
<li>预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化</li>
<li>合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积</li>
<li>使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化</li>
<li>提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程</li>
<li>封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化</li>
<li>图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验</li>
<li>使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求</li>
<li>压缩图片：可以使用 image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图片</li>
</ul>
<h3 id="22-Vue-中的-Key-的作用是什么？"><a href="#22-Vue-中的-Key-的作用是什么？" class="headerlink" title="22.Vue 中的 Key 的作用是什么？"></a>22.Vue 中的 Key 的作用是什么？</h3><p><strong><em>key\</em> 的作用主要是为了高效的更新虚拟 *DOM*</strong> 。另外 <em>vue</em> 中在使用相同标签名元素的过渡切换时，也会使用到 <em>key</em> 属性，其目的也是为了让 <em>vue</em> 可以区分它们，否则 <em>vue</em> 只会替换其内部属性而不会触发过渡效果。</p>
<p>其实不只是 <em>vue</em>，<em>react</em> 中在执行列表渲染时也会要求给每个组件添加上 <em>key</em> 这个属性。</p>
<p>要解释 <em>key</em> 的作用，不得不先介绍一下虚拟 <em>DOM</em> 的 <em>Diff</em> 算法了。</p>
<p>我们知道，<em>vue</em> 和 <em>react</em> 都实现了一套虚拟 <em>DOM</em>，使我们可以不直接操作 <em>DOM</em> 元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的 <em>Diff</em> 算法。</p>
<p><em>vue</em> 和 <em>react</em> 的虚拟 <em>DOM</em> 的 <em>Diff</em> 算法大致相同，其核心有以下两点：</p>
<ul>
<li>两个相同的组件产生类似的 <em>DOM</em> 结构，不同的组件产生不同的 <em>DOM</em> 结构。</li>
<li>同一层级的一组节点，他们可以通过唯一的 <em>id</em> 进行区分。</li>
</ul>
<p>基于以上这两点，使得虚拟 <em>DOM</em> 的 <em>Diff</em> 算法的复杂度从 <em>O(n^3)</em> 降到了 <em>O(n)</em> 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f7a791600264ef7b71c322ca1a70245~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=838&amp;h=442&amp;s=20166&amp;e=webp&amp;b=fefdfd" alt="image-20210821142057777"></p>
<p>当页面的数据发生变化时，<em>Diff</em> 算法只会比较同一层级的节点：</p>
<ul>
<li>如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。</li>
<li>如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。</li>
</ul>
<p>当某一层有很多相同的节点时，也就是列表节点时，<em>Diff</em> 算法的更新过程默认情况下也是遵循以上原则。</p>
<p>比如一下这个情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d795dacc50f94f8bbe213246061607da~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=477&amp;h=191&amp;s=4074&amp;e=webp&amp;b=fefefe" alt="img"></p>
<p>我们希望可以在 <em>B</em> 和 <em>C</em> 之间加一个 <em>F</em>，<em>Diff</em> 算法默认执行起来是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f82060bef8d34625aaf00f00be7b902e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=572&amp;h=215&amp;s=7854&amp;e=webp&amp;b=fefefe" alt="img"></p>
<p>即把 <em>C</em> 更新成 <em>F</em>，<em>D</em> 更新成 <em>C</em>，<em>E</em> 更新成 <em>D</em>，最后再插入 <em>E</em></p>
<p>是不是很没有效率？</p>
<p>所以我们需要使用 <em>key</em> 来给每个节点做一个唯一标识，<em>Diff</em> 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a881df19c394606b2204041ac380667~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=452&amp;h=130&amp;s=7512&amp;e=webp&amp;b=fdfdfd" alt="img"></p>
<h3 id="23-组件中写-name-选项有哪些好处"><a href="#23-组件中写-name-选项有哪些好处" class="headerlink" title="23.组件中写 name 选项有哪些好处"></a>23.组件中写 name 选项有哪些好处</h3><ul>
<li>可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）</li>
<li>可以通过 <em>name</em> 属性实现缓存功能（<em>keep-alive</em>）</li>
<li>可以通过 <em>name</em> 来识别组件（跨级组件通信时非常重要）</li>
<li>使用 <em>vue-devtools</em> 调试工具里显示的组见名称是由 <em>vue</em> 中组件 <em>name</em> 决定的</li>
</ul>
<h3 id="ref-的作用"><a href="#ref-的作用" class="headerlink" title="ref 的作用"></a>ref 的作用</h3><p><em>ref</em> 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <em>$refs</em> 对象上。其特点是：</p>
<ul>
<li>如果在普通的 <em>DOM</em> 元素上使用，引用指向的就是 <em>DOM</em> 元素</li>
<li>如果用在子组件上，引用就指向组件实例</li>
</ul>
<p>所以常见的使用场景有：</p>
<ol>
<li>基本用法，本页面获取 <em>DOM</em> 元素</li>
<li>获取子组件中的 <em>data</em></li>
<li>调用子组件中的方法</li>
</ol>
<h3 id="25-你的接口请求一般放在哪个生命周期中？为什么要这样做？"><a href="#25-你的接口请求一般放在哪个生命周期中？为什么要这样做？" class="headerlink" title="25.你的接口请求一般放在哪个生命周期中？为什么要这样做？"></a>25.你的接口请求一般放在哪个生命周期中？为什么要这样做？</h3><p>接口请求可以放在钩子函数 <em>created、beforeMount、mounted</em> 中进行调用，因为在这三个钩子函数中，<em>data</em> 已经创建，可以将服务端端返回的数据进行赋值。</p>
<p>但是推荐在 <em>created</em> 钩子函数中调用异步请求，因为在 <em>created</em> 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 <em>loading</em> 时间</li>
<li><em>SSR</em> 不支持 <em>beforeMount 、mounted</em> 钩子函数，所以放在 <em>created</em> 中有助于代码的一致性</li>
<li><em>created</em> 是在模板渲染成 <em>html</em> 前调用，即通常初始化某些属性值，然后再渲染成视图。如果在 <em>mounted</em> 钩子函数中请求数据可能导致页面闪屏问题</li>
</ul>
<h3 id="如何封装组件"><a href="#如何封装组件" class="headerlink" title="如何封装组件"></a>如何封装组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先进行需求分析，确定组件功能和实现方式。再定义组件 <span class="variable constant_">API</span>，包括传入的 props 和事件。</span><br><span class="line">最后编写组件测试用例，确保组件功能正确。</span><br><span class="line"></span><br><span class="line">封装组件时要注意组件的可复用性、易维护性和可测试性。在编写组件时，应该遵循单一职责原则，</span><br><span class="line">尽量避免组件之间的耦合，提供清晰简洁的 <span class="variable constant_">API</span>，确保组件功能正确，并编写充分的测试用例，</span><br><span class="line">以便于其他开发者和用户使用和维护组件。</span><br></pre></td></tr></table></figure>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="css-权重"><a href="#css-权重" class="headerlink" title="css 权重"></a>css 权重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="number">1000</span> 内联样式：&lt;div style=<span class="string">&quot;color: red;&quot;</span>&gt;<span class="title class_">Hello</span>&lt;/div&gt;</span><br><span class="line"><span class="number">2.</span> <span class="number">100</span> id选择器：#header &#123; <span class="attr">color</span>: blue; &#125;</span><br><span class="line"><span class="number">3.</span> <span class="number">10</span> 类选择器【.<span class="property">button</span> &#123;&#125;】、属性选择器【[type=<span class="string">&quot;text&quot;</span>] &#123; &#125;】、伪类选择器【<span class="attr">a</span>:hover &#123; &#125;】</span><br><span class="line"><span class="number">4.</span> <span class="number">1</span> 元素选择器【div &#123; <span class="attr">color</span>: black; &#125;】、伪元素选择器【::before &#123; &#125;】</span><br></pre></td></tr></table></figure>
<h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">行内元素：span a</span><br><span class="line"><span class="number">1</span>、line-height 设置为与父容器的 height 一致 和 text-align：center</span><br><span class="line"><span class="number">2</span>、justify-<span class="attr">content</span>: center 水平居中，align-<span class="attr">items</span>: center 垂直居中。</span><br><span class="line"></span><br><span class="line">块元素：div</span><br><span class="line"><span class="number">1</span>、flex+margin</span><br><span class="line">  父元素：<span class="attr">display</span>: flex;</span><br><span class="line">         justify-<span class="attr">content</span>: center;</span><br><span class="line">         align-<span class="attr">items</span>: center</span><br><span class="line"><span class="number">2</span>、定位+tranform</span><br><span class="line">  父元素：<span class="attr">position</span>: relative</span><br><span class="line">  子元素：<span class="attr">position</span>: absolute;  使元素的左上角移动到父容器的正中央</span><br><span class="line">         <span class="attr">top</span>: <span class="number">50</span>%; <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">         <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">50</span>%)  使元素的中心点对齐</span><br><span class="line"><span class="number">3</span>、grid网格布局</span><br><span class="line">  父元素：<span class="attr">display</span>: grid;</span><br><span class="line">         place-<span class="attr">items</span>: center 让子元素在 <span class="title class_">Grid</span> 容器中水平和垂直方向居中</span><br></pre></td></tr></table></figure>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从内到外由四个部分构成：内容区域（content）、内边距（padding，内边距的颜色与内容区域相同，不能设置透明）、边框（border，会影响盒子占据的总空间）、外边距（margin）</span><br><span class="line"></span><br><span class="line">标准和模型<span class="title class_">Content</span>-box：</span><br><span class="line">	width只包含内容宽度，不包含border和padding。</span><br><span class="line">	offsetWidth = (width + padding + border),不算margin</span><br><span class="line"><span class="variable constant_">IE</span>盒模型border-box：怪异盒模型</span><br><span class="line">	width/height包括内容区、padding、border</span><br></pre></td></tr></table></figure>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">static</span>（默认值）：元素处于正常的文档流中。</span><br><span class="line"><span class="number">2</span>、relative：相对定位。元素在正常文档流中的位置不变，但可以通过设置top等属性来相对于其正常位置进行偏移。发生偏移时可能会覆盖其他元素，但不会影响其他元素的布局。</span><br><span class="line"><span class="number">3</span>、absolute：绝对定位。元素脱离正常文档流，并相对于最近的已定位祖先元素或 &lt;body&gt; 元素进行定位。如果没有已定位的祖先元素，则相对于视口进行定位。</span><br><span class="line"><span class="number">4</span>、fixed：固定定位。元素脱离正常文档流，并相对于视口进行定位。</span><br><span class="line"><span class="number">5</span>、sticky：粘性定位。元素根据正常文档流进行定位，然后相对于离它最近的具有滚动机制的祖先元素或视口进行定位。当用户滚动页面时，元素的定位会发生变化。</span><br></pre></td></tr></table></figure>
<h3 id="vw、vh、rem、em-区别"><a href="#vw、vh、rem、em-区别" class="headerlink" title="vw、vh、rem、em 区别"></a>vw、vh、rem、em 区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、vw：viewpoint width，视口宽度的百分比单位。100vw = <span class="number">100</span>% 视图窗口宽度。</span><br><span class="line"><span class="number">2</span>、vh：viewpoint height，视口高度的百分比单位。100vh = <span class="number">100</span>% 视图窗口高度。</span><br><span class="line"><span class="number">3</span>、rem（<span class="title class_">Root</span> <span class="variable constant_">EM</span>）：相对于根元素的字体大小的单位。默认情况下，根元素的字体大小等于浏览器的默认字体大小（16px）。如果根元素设置了字体大小为 16px，那么 1rem 相当于 16px。通过在根元素设置合适的字体大小，可以方便地进行整体的比例调整。</span><br><span class="line"><span class="number">4</span>、em（<span class="title class_">Emphasis</span>）：相对于父元素字体大小的单位。em 单位具有继承性，子元素的字体大小也会受到父元素字体大小的影响。</span><br><span class="line"></span><br><span class="line">主要区别如下：</span><br><span class="line">vw 和 vh 是相对于视口宽度和高度的单位，而 rem 和 em 是相对于字体大小的单位。</span><br><span class="line">vw 和 vh 单位可以直接根据屏幕尺寸进行调整，而 rem 和 em 单位则需要依赖于父元素的字体大小。</span><br><span class="line">rem 单位更适合用于整体的比例调整，而 em 单位更适合用于相对布局中的局部调整。</span><br></pre></td></tr></table></figure>
<h3 id="display：none和visibility-hidden区别"><a href="#display：none和visibility-hidden区别" class="headerlink" title="display：none和visibility: hidden区别"></a><code>display：none</code>和<code>visibility: hidden</code>区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">这两个属性都是让元素隐藏，不可见。两者的区别：</span><br><span class="line"><span class="number">1</span>、<span class="string">`display: none`</span>：让元素从文档流中移除，不占据任何空间；且是非继承属性，所有子元素都不可见，对页面的渲染性能影响较小。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="string">`visibility: hidden`</span>：元素仍占据空间，但内容不可见。只是将元素的可见性设置为隐藏，其他元素的布局不受影响。子元素也会被隐藏，但可以通过单独设置子元素的 <span class="attr">visibility</span>: visible 来让子元素显示，而父元素仍然保持隐藏状态。</span><br><span class="line"></span><br><span class="line">类似于v-<span class="keyword">if</span>和v-show</span><br><span class="line"></span><br><span class="line">渲染的时候，dom树和渲染树是一一对应的么</span><br><span class="line"><span class="variable constant_">DOM</span> 树和渲染树并不是一一对应的，<span class="variable constant_">DOM</span> 树是由浏览器解析 <span class="variable constant_">HTML</span> 文档而生成的，它表示了整个文档的结构和内容，包括<span class="variable constant_">HTML</span> 元素、文本节点和属性等。</span><br><span class="line">渲染树是在 <span class="variable constant_">DOM</span> 树和 <span class="variable constant_">CSSOM</span> 树结合之后生成的，用于表示页面上【需要渲染的元素及样式信息】。渲染树中的节点称为渲染对象(<span class="title class_">Render</span> <span class="title class_">Object</span>)，它们与 <span class="variable constant_">DOM</span> 树中的节点相对应，但不是一一对应的关系。</span><br><span class="line">在构建渲染树时，一些不需要显示的节点(如&lt;script&gt;、&lt;head&gt;、<span class="attr">display</span>:none 和一些不可见的元素)会被省略，而只有需要显示的元素才会被包含在渲染树中。</span><br></pre></td></tr></table></figure>
<h3 id="transform相较于margin的好处"><a href="#transform相较于margin的好处" class="headerlink" title="transform相较于margin的好处"></a><code>transform</code>相较于<code>margin</code>的好处</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、不影响文档流：使用 margin 属性实现元素的移动会影响到元素所在的文档流，可能会导致其他元素位置发生变化。而使用 transform 属性可将元素的位置进行调整，但不会影响到其他元素的布局和位置。</span><br><span class="line"><span class="number">2</span>、性能更好：使用 transform 属性来实现元素的移动、旋转等操作，浏览器不需要重新计算元素的布局和绘制，而是仅对元素进行单纯的变换。这样可以减少浏览器的重排（reflow）和重绘（repaint）操作，从而提高页面的渲染性能。</span><br><span class="line"><span class="number">3</span>、可以使用硬件加速：一些浏览器支持使用 <span class="variable constant_">GPU</span> 进行硬件加速来执行 transform 变换，这样可以进一步提高页面的渲染性能。</span><br></pre></td></tr></table></figure>
<h2 id="浏览器和网络"><a href="#浏览器和网络" class="headerlink" title="浏览器和网络"></a>浏览器和网络</h2><h3 id="xss-攻击"><a href="#xss-攻击" class="headerlink" title="xss 攻击"></a>xss 攻击</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">XSS</span>（跨站脚本攻击）是一种常见的网络安全漏洞，攻击者通过在网页中注入恶意脚本代码，使得用户在浏览网页时执行该恶意脚本，从而达到攻击的目的。<span class="variable constant_">XSS</span> 攻击可以分为三种类型：</span><br><span class="line"><span class="number">1</span>、存储型 <span class="variable constant_">XSS</span>：将恶意脚本存储在服务端，当用户访问包含这些脚本的页面时，恶意脚本会被执行。</span><br><span class="line"><span class="number">2</span>、反射型 <span class="variable constant_">XSS</span>：将恶意脚本作为参数或路径的一部分发送给受害者，当受害者点击特定的链接时，恶意脚本会被执行。</span><br><span class="line"><span class="number">3</span>、<span class="variable constant_">DOM</span> 型 <span class="variable constant_">XSS</span>：攻击者通过修改页面的 <span class="variable constant_">DOM</span> 结构来执行恶意脚本，通常通过修改 <span class="variable constant_">URL</span> 参数、表单提交或者修改 <span class="variable constant_">JS</span> 脚本等方式实现。</span><br><span class="line"></span><br><span class="line">为了防止 <span class="variable constant_">XSS</span> 攻击，可以采取以下措施：</span><br><span class="line"><span class="number">1</span>、输入验证和过滤：对用户输入的数据进行验证和过滤，确保只接受合法的数据。可以使用白名单过滤器或转义特殊字符等方式来防止恶意脚本的注入。</span><br><span class="line"><span class="number">2</span>、输出编码：对输出到页面的数据进行编码，确保恶意脚本不能被执行。可以使用适当的编码函数，如 <span class="variable constant_">HTML</span> 编码、<span class="variable constant_">URL</span> 编码等。</span><br><span class="line"><span class="number">3</span>、设置 <span class="variable constant_">HTTP</span> 头部：通过设置 <span class="title class_">Content</span>-<span class="title class_">Security</span>-<span class="title class_">Policy</span>（<span class="variable constant_">CSP</span>）头部来限制页面中可以加载的资源和执行的脚本，减少攻击者的可操作空间。</span><br><span class="line"><span class="number">4</span>、使用安全的框架和库：使用经过安全验证的框架和库，这些框架和库通常提供了对 <span class="variable constant_">XSS</span> 攻击的防护机制。</span><br><span class="line"><span class="number">5</span>、定期更新和修补：保持软件系统和相关组件的更新，及时修补已知的漏洞。</span><br></pre></td></tr></table></figure>
<h3 id="csrf？localstorage存了token，怎么解决"><a href="#csrf？localstorage存了token，怎么解决" class="headerlink" title="csrf？localstorage存了token，怎么解决?"></a><code>csrf</code>？<code>localstorage</code>存了<code>token</code>，怎么解决?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">CSRF</span>（跨站请求伪造）是一种利用受信任用户的身份执行非意愿操作的攻击方式。</span><br><span class="line">在 <span class="variable constant_">CSRF</span> 攻击中，攻击者通过诱使受害者在登录状态下访问恶意网站或点击恶意链接，来执行受害者在其他网站上的非意愿操作，如修改密码、发表言论等。</span><br><span class="line"></span><br><span class="line">对于使用 <span class="variable language_">localStorage</span> 存储 token 的情况，可以采取以下措施来防止 <span class="variable constant_">CSRF</span> 攻击：</span><br><span class="line"><span class="number">1</span>、同源检测：在服务器端对请求进行同源检测，确保请求来自合法的源站点。可以通过检查请求头中的 <span class="title class_">Referer</span> 字段或 <span class="title class_">Origin</span> 字段来实现。</span><br><span class="line"><span class="number">2</span>、随机化 token：在生成 token 时使用随机数和时间戳等信息，使得每个 token 的值都是唯一的，并将 token 存储在 session 或 http-only 的 cookie 中，而不是 <span class="variable language_">localStorage</span> 中。</span><br><span class="line"><span class="number">3</span>、添加 <span class="variable constant_">CSRF</span> <span class="title class_">Token</span>：在每个需要进行敏感操作的请求中，添加一个 <span class="variable constant_">CSRF</span> <span class="title class_">Token</span> 参数。该参数的值由服务器生成，并在服务器端进行验证。攻击者无法获取到合法的 <span class="variable constant_">CSRF</span> <span class="title class_">Token</span> 值，从而无法成功执行 <span class="variable constant_">CSRF</span> 攻击。</span><br><span class="line"><span class="number">4</span>、设置 <span class="title class_">SameSite</span> 属性：对于支持 <span class="title class_">SameSite</span> 属性的浏览器，可以将 cookie 的 <span class="title class_">SameSite</span> 属性设置为 <span class="title class_">Strict</span> 或 <span class="title class_">Lax</span>，以限制跨站点的 cookie 发送，进一步减少 <span class="variable constant_">CSRF</span> 攻击的风险。</span><br><span class="line"><span class="number">5</span>、使用验证码：对于特别敏感的操作，如修改密码、删除账户等，可以要求用户输入验证码，增加安全性。</span><br></pre></td></tr></table></figure>
<h3 id="如何提高前端页面性能"><a href="#如何提高前端页面性能" class="headerlink" title="如何提高前端页面性能"></a>如何提高前端页面性能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 减少 <span class="variable constant_">HTTP</span> 请求：减少静态资源的请求次数，可通过使用 <span class="variable constant_">CSS</span> <span class="title class_">Sprites</span>、合并<span class="variable constant_">JS</span>和 <span class="variable constant_">CSS</span> 文件等手段实现。</span><br><span class="line"><span class="number">2.</span> 压缩文件大小：压缩 <span class="title class_">JavaScript</span>、<span class="variable constant_">CSS</span> 和图片等文件，可有效减小文件大小，加快下载速度。</span><br><span class="line"><span class="number">3.</span> 避免重复加载：避免重复加载相同的文件或资源，可以通过浏览器缓存、<span class="variable constant_">HTTP</span> 缓存和服务端缓存等手段来实现。</span><br><span class="line"><span class="number">4.</span> 异步加载资源：延迟加载非关键资源，可以通过懒加载和异步加载等手段来实现。</span><br><span class="line"><span class="number">5.</span> 减少 <span class="variable constant_">DOM</span> 操作：减少不必要的 <span class="variable constant_">DOM</span> 操作，可通过避免多次查询 <span class="variable constant_">DOM</span> 元素、使用文档片段、事件委托等手段来实现。</span><br><span class="line"><span class="number">6.</span> 优化 <span class="variable constant_">CSS</span> 选择器：避免使用过于复杂的 <span class="variable constant_">CSS</span> 选择器，可以通过简化选择器、使用 <span class="variable constant_">ID</span> 选择器、避免使用通配符等手段来实现。</span><br><span class="line"><span class="number">7.</span> 使用 <span class="title class_">Web</span> <span class="title class_">Workers</span> 和 <span class="title class_">Service</span> <span class="title class_">Workers</span>：使用 <span class="title class_">Web</span> <span class="title class_">Workers</span> 和 <span class="title class_">Service</span> <span class="title class_">Workers</span> 可以将一些耗时的计算和 I/O 操作转移到后台线程中，避免阻塞主线程，提高页面响应速度。</span><br><span class="line"><span class="number">8.</span> 移动端优化：移动端页面的性能优化可以通过图片压缩、使用 <span class="title class_">CSS3</span> 动画代替 <span class="variable constant_">JS</span> 动画、避免使用 fixed 定位等手段来实现。</span><br></pre></td></tr></table></figure>
<h2 id="Webpack-与-vite"><a href="#Webpack-与-vite" class="headerlink" title="Webpack 与 vite"></a>Webpack 与 vite</h2><p>了解 webpack、vite 打包工具、依赖包管理器 npm，了解基本配置</p>
<h3 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><h3 id="instanceof-方法"><a href="#instanceof-方法" class="headerlink" title="instanceof 方法"></a>instanceof 方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left); <span class="comment">// 获取对象left原型</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 获取目标构造函数right原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 到达原型链顶端仍未找到目标原型，则返回 false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) &#123;</span><br><span class="line">      <span class="comment">// 找到目标原型，则返回 true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto); <span class="comment">// 继续查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(p, <span class="title class_">Person</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖：处理频繁触发的事件。函数被连续调用时，只执行最后一次调用。（输入框搜索、窗口调整、按钮点击）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer); <span class="comment">//每一次时间清空，重新计时</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流：限制事件的触发频率，规定时间间隔只执行一次相应操作。（页面滚动、鼠标移动）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浅拷贝和浅拷贝"><a href="#浅拷贝和浅拷贝" class="headerlink" title="浅拷贝和浅拷贝"></a>浅拷贝和浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      newObj[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">//查看要拷贝的对象是数组还是对象，如果数组创建空数组，是对象创建空对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// K属性名  obj[k]值</span></span><br><span class="line">    <span class="comment">//判断当前每个元素是否是对象或者数组，若是对象，继续递归拷贝</span></span><br><span class="line">    <span class="comment">//若是值，直接添加到新创建的对象或者数组里</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[k] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      newObj[k] = <span class="title function_">deepClone</span>(obj[k]); <span class="comment">// 递归拷贝完 放入到新对象的属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则是值， 直接添加到新建的 newObj中</span></span><br><span class="line">      newObj[k] = obj[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj; <span class="comment">//返回新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  caches = &#123;&#125;; <span class="comment">// 事件中心</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// eventName事件名-独一无二, fn订阅后执行的自定义行为</span></span><br><span class="line">  on (eventName, fn)&#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">caches</span>[eventName] = <span class="variable language_">this</span>.<span class="property">caches</span>[eventName] || [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">caches</span>[eventName].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发布 =&gt; 将订阅的事件进行统一执行</span></span><br><span class="line">  emit (eventName, data) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">caches</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">caches</span>[eventName]</span><br><span class="line">      .<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消订阅 =&gt; 若fn不传, 直接取消该事件所有订阅信息</span></span><br><span class="line">  off (eventName, fn) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">caches</span>[eventName]) &#123;</span><br><span class="line">      <span class="keyword">const</span> newCaches = fn </span><br><span class="line">        ? <span class="variable language_">this</span>.<span class="property">caches</span>[eventName].<span class="title function_">filter</span>(<span class="function"><span class="params">e</span> =&gt;</span> e !== fn) </span><br><span class="line">        : [];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">caches</span>[eventName] = newCaches;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一面：有几轮面试、HC headcount多吗、培养机制</span><br><span class="line">日常职责、技术栈 </span><br><span class="line">主要工作地点</span><br><span class="line">一般多久出结果</span><br><span class="line">有什么给我的建议吗</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>项目总结</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/">http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>IZDLOYL</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-08-27</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-09-25</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A7%8B%E6%8B%9B/">秋招</a></div><div class="post_share"><div class="social-share" data-image="/gallery/wallpaper1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端八股</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/23/frontEnd-nodejs/" title="node"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">node</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">IZDLOYL</div><div class="author-info__description">🎬𝙏𝙪𝙧𝙣 𝙤𝙛𝙛 𝙬𝙤𝙧𝙧𝙮✨</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/IZDLOYL-G"><i class="fab fa-github"></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/IZDLOYL-G" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1215472755@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #dfc600;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1174008660" target="_blank" title="Weixin"><i class="fab fa-weixin" style="color: #48b700;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">welcome to my blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E4%BA%AB%E6%B1%87"><span class="toc-text">图享汇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C"><span class="toc-text">1、登录注册</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8slideCaptcha%E5%AE%8C%E6%88%90%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81"><span class="toc-text">使用slideCaptcha完成滑动验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E6%96%B9QQ%E3%80%81%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E3%80%82"><span class="toc-text">实现第三方QQ、微信扫码登录。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85"><span class="toc-text">2、axios二次封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85"><span class="toc-text">3、组件封装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%B5%81%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="toc-text">瀑布流组件：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%EF%BC%9A"><span class="toc-text">上拉加载：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%87%92%E5%8A%A0%E8%A3%81"><span class="toc-text">4、懒加裁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">图片懒加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">组件懒加载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E9%98%B2%E6%8A%96%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96"><span class="toc-text">5、防抖搜索优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">移动端适配 - 响应式布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE"><span class="toc-text">人力资源后台项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%9D%83%E9%99%90"><span class="toc-text">1、权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81vuex%E7%AE%A1%E7%90%86"><span class="toc-text">2、vuex管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="toc-text">3、excel导入导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%80%92%E5%BD%92%E5%88%97%E8%A1%A8%E8%BD%AC%E6%A0%91"><span class="toc-text">4、递归列表转树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">js 数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-text">判断数据类型的方法及区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型和原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">闭包和内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">async&#x2F;await 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">ES6新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88-%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-text">事件循环（ 调用堆栈和任务队列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let%E3%80%81const%E3%80%81var%E5%8C%BA%E5%88%AB"><span class="toc-text">let、const、var区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C"><span class="toc-text">&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-text">数组原生方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">遍历数组对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E4%B8%AD%E7%9A%84this"><span class="toc-text">JS中的this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">new操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue"><span class="toc-text">vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">vue生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2-3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">vue2&#x2F;3响应式原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3%E5%92%8Cvue2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">vue3和vue2的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9C%A8-Vue2-x-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-text">5.在 Vue2.x 中如何检测数组的变化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-v-model-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">6.v-model 双向绑定的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-vue2-x-%E5%92%8C-vuex3-x-%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84-diff-%E7%AE%97%E6%B3%95%E5%88%86%E5%88%AB%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-text">7.vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-text">8.vue组件通信方式有哪些及原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0-hash%E8%B7%AF%E7%94%B1%E5%92%8Chistory%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-text">9.  Vue的路由实现, hash路由和history路由实现原理说一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if-%E4%B8%8E-v-show-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">v-if 与 v-show 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-keep-alive%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">11. keep-alive的常用属性有哪些及实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-nextTick-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">12. nextTick 的作用是什么？他的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%AF%B4%E4%B8%80%E4%B8%8B-Vue-SSR-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">13.说一下 Vue SSR 的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Vue-%E7%BB%84%E4%BB%B6%E7%9A%84-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-text">14.Vue 组件的 data 为什么必须是函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E8%AF%B4%E4%B8%80%E4%B8%8B-Vue-%E7%9A%84-computed-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">15.说一下 Vue 的 computed 的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%AF%B4%E4%B8%80%E4%B8%8B-Vue-complier-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">16.说一下 Vue complier 的实现原理是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E4%B8%8E-React-%E5%8C%BA%E5%88%AB"><span class="toc-text">Vue 与  React 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%AF%B4%E4%B8%80%E4%B8%8B-watch-%E4%B8%8E-computed-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">18.说一下 watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84-vue-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">19.说一下你知道的 vue 修饰符都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-vue-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">实现 vue 项目中的性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-vue-%E4%B8%AD%E7%9A%84-spa-%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6"><span class="toc-text">21.vue 中的 spa 应用如何优化首屏加载速度?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-Vue-%E4%B8%AD%E7%9A%84-Key-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">22.Vue 中的 Key 的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99-name-%E9%80%89%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84"><span class="toc-text">23.组件中写 name 选项有哪些好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">ref 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%BD%A0%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E4%B8%80%E8%88%AC%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E5%81%9A%EF%BC%9F"><span class="toc-text">25.你的接口请求一般放在哪个生命周期中？为什么要这样做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6"><span class="toc-text">如何封装组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css-%E6%9D%83%E9%87%8D"><span class="toc-text">css 权重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">水平垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D"><span class="toc-text">定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vw%E3%80%81vh%E3%80%81rem%E3%80%81em-%E5%8C%BA%E5%88%AB"><span class="toc-text">vw、vh、rem、em 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#display%EF%BC%9Anone%E5%92%8Cvisibility-hidden%E5%8C%BA%E5%88%AB"><span class="toc-text">display：none和visibility: hidden区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transform%E7%9B%B8%E8%BE%83%E4%BA%8Emargin%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">transform相较于margin的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C"><span class="toc-text">浏览器和网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xss-%E6%94%BB%E5%87%BB"><span class="toc-text">xss 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csrf%EF%BC%9Flocalstorage%E5%AD%98%E4%BA%86token%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-text">csrf？localstorage存了token，怎么解决?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD"><span class="toc-text">如何提高前端页面性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack-%E4%B8%8E-vite"><span class="toc-text">Webpack 与 vite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">webpack 构建流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node"><span class="toc-text">node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-text">HTML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-text">手写代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-%E6%96%B9%E6%B3%95"><span class="toc-text">instanceof 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-text">防抖节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">浅拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-text">发布订阅</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E9%97%AE"><span class="toc-text">反问</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端八股"/></a><div class="content"><a class="title" href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股">前端八股</a><time datetime="2024-08-29T13:06:26.092Z" title="发表于 2024-08-29 21:06:26">2024-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/27/interview-%E6%80%BB%E7%BB%93/" title="项目总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目总结"/></a><div class="content"><a class="title" href="/2024/08/27/interview-%E6%80%BB%E7%BB%93/" title="项目总结">项目总结</a><time datetime="2024-08-27T12:58:34.417Z" title="发表于 2024-08-27 20:58:34">2024-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-nodejs/" title="node"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="node"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-nodejs/" title="node">node</a><time datetime="2024-08-23T08:14:35.116Z" title="发表于 2024-08-23 16:14:35">2024-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-JavaScript/" title="JS基本语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_4.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS基本语法"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-JavaScript/" title="JS基本语法">JS基本语法</a><time datetime="2024-08-23T08:06:33.574Z" title="发表于 2024-08-23 16:06:33">2024-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-TypeScript/" title="TypeScript"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-TypeScript/" title="TypeScript">TypeScript</a><time datetime="2024-08-23T08:06:10.608Z" title="发表于 2024-08-23 16:06:10">2024-08-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By IZDLOYL</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hope you have a nice day!🍭🍭🍭</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 IZDLOYLの前端笔记 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/项目/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 IZDLOYLの项目 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 IZDLOYLの算法笔记 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/面试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 IZDLOYLの面试总结 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://www.izdloyl.cn/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-JavaScript/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-JavaScript/" alt="">JS基本语法</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-JavaScript/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-TypeScript/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-TypeScript/" alt="">TypeScript</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-TypeScript/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/01/frontEnd-vue3/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" href="2024/08/01/frontEnd-vue3/" alt="">vue3</a><div class="blog-slider__text">vue3学习笔记</div><a class="blog-slider__button" href="2024/08/01/frontEnd-vue3/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-nodejs/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-nodejs/" alt="">node</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-nodejs/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/01/frontEnd-vue2/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" href="2024/08/01/frontEnd-vue2/" alt="">vue2</a><div class="blog-slider__text">vue2学习笔记</div><a class="blog-slider__button" href="2024/08/01/frontEnd-vue2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-数组/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-数组/" alt="">数组篇</a><div class="blog-slider__text">代码随想录 - 数组篇</div><a class="blog-slider__button" href="2024/08/02/algorithm-数组/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-hot100/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-hot100/" alt="">hot100</a><div class="blog-slider__text">LeetCode - hot100</div><a class="blog-slider__button" href="2024/08/02/algorithm-hot100/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-字符串/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-字符串/" alt="">字符串篇</a><div class="blog-slider__text">代码随想录 - 字符串篇</div><a class="blog-slider__button" href="2024/08/02/algorithm-字符串/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>IZDLOYL's Blog | IZDLOYL's Blog</title><meta name="author" content="IZDLOYL"><meta name="copyright" content="IZDLOYL"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="面试官你好，很高兴能有这次的面试机会，我叫朱晓霞，目前是杭州电子科技大学 通信工程专业研三的学生，今天我应聘的岗位是前端开发工程师。 研一的时候由于导师的横向课题，我接触了前端开发这个职业，并产生浓厚的兴趣。之后也系统学习了前端开发的相关知识，在技术上，我熟练掌握HTML、CSS、JavaScript等基础语言，且在Vue开发方面也积累了一定的实践经验。 目前，也做过几个前端开源项目。最近的一">
<meta property="og:type" content="article">
<meta property="og:title" content="IZDLOYL&#39;s Blog">
<meta property="og:url" content="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="IZDLOYL&#39;s Blog">
<meta property="og:description" content="面试官你好，很高兴能有这次的面试机会，我叫朱晓霞，目前是杭州电子科技大学 通信工程专业研三的学生，今天我应聘的岗位是前端开发工程师。 研一的时候由于导师的横向课题，我接触了前端开发这个职业，并产生浓厚的兴趣。之后也系统学习了前端开发的相关知识，在技术上，我熟练掌握HTML、CSS、JavaScript等基础语言，且在Vue开发方面也积累了一定的实践经验。 目前，也做过几个前端开源项目。最近的一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.izdloyl.cn/gallery/wallpaper4.jpg">
<meta property="article:published_time" content="2024-08-27T12:58:34.417Z">
<meta property="article:modified_time" content="2024-11-08T09:00:40.460Z">
<meta property="article:author" content="IZDLOYL">
<meta property="article:tag" content="Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.izdloyl.cn/gallery/wallpaper4.jpg"><link rel="shortcut icon" href="/gallery/favicon.jpg"><link rel="canonical" href="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'IZDLOYL\'s Blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-08 17:00:40'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/gallery/wallpaper4.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="IZDLOYL's Blog"><span class="site-name">IZDLOYL's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-27T12:58:34.417Z" title="发表于 2024-08-27 20:58:34">2024-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-08T09:00:40.460Z" title="更新于 2024-11-08 17:00:40">2024-11-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>92分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<hr>
<p>面试官你好，很高兴能有这次的面试机会，我叫朱晓霞，目前是杭州电子科技大学</p>
<p>通信工程专业研三的学生，今天我应聘的岗位是前端开发工程师。</p>
<p>研一的时候由于导师的横向课题，我接触了前端开发这个职业，并产生浓厚的兴趣。之后也系统学习了前端开发的相关知识，在技术上，我熟练掌握HTML、CSS、JavaScript等基础语言，且在Vue开发方面也积累了一定的实践经验。</p>
<p>目前，也做过几个前端开源项目。最近的一个是简历上的基于响应式设计的图片分享平台。通过这些项目实践，我掌握了组件化开发、状态管理以及前后端接口联调等核心技能。同时呢，为了整理和分享自己的所学知识，我基于hexo 搭建了自己的个人博客网站，主要记录自己学习前端的心得体会和开发中遇到的问题。</p>
<p>以上是我的一些基本情况，谢谢</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="图享汇"><a href="#图享汇" class="headerlink" title="图享汇"></a>图享汇</h3><h4 id="介绍（难点、解决）"><a href="#介绍（难点、解决）" class="headerlink" title="介绍（难点、解决）"></a>介绍（难点、解决）</h4><p>图享汇是一个图片下载平台，用户可在该平台自由浏览、搜索、下载和分享网站上的图片。平台采用响应式设计，确保用户在PC端和移动端都能获得流畅的使用体验。</p>
<p>项目的主要技术栈是Vue3 + vite + Tailwind CSS</p>
<p>项目的难点：</p>
<p>首先，由于项目需要兼容PC端和移动端，如何在不同设备上保持一致的用户体验。当时知道了一个CSS框架Tailwind CSS，它提供了简便的响应式类（它只需在类名前加上响应式前缀sm、md、lg），并且遵循移动端优先的原则，可以支持在不同屏幕尺寸下使用不同的样式。再通过flex + rem 移动端适配方案，设置屏幕基准值（屏宽/10，最大基准值为40），使布局文字大小可随屏幕大小进行缩放，适应不同的设备。</p>
<p>然后，由于项目首页主要由大量图片构成，采取了瀑布流布局。但之前没有封装这样的通用组件，对我来说比较困难。我首先通过<code>props</code>传递关键数据，比如<code>`数据源、唯一标识、渲染的列数、是否需要图片预渲染。然后通过</code>absolute<code>配合</code>relative<code>完成瀑布流布局，让**每个**</code>item<code>**应该横向排列，第二行的**</code>item<code>**顺序连接到当前最短的列中。最后**通过 **作用域插槽** 将每个</code>item<code>中涉及到的数据，传递到</code>item`视图中。</p>
<p>最后，使用瀑布流布局的时候初次加载时间较长，导致页面加载慢的问题。我使用了长列表（上拉加载组件）优化，通过vueuse提供的useIntersectionObserver方法，监听列表是否滚动到底部，再去加载数据。这样 减少了 DOM 操作。并且，使用了图片懒加载技术，监听图片的可见状态，加载图片。提升了用户体验</p>
<p>以上是我 项目的具体介绍。</p>
<p>难点：瀑布流组件的封装</p>
<h4 id="登录注册模块"><a href="#登录注册模块" class="headerlink" title="登录注册模块"></a>登录注册模块</h4><h5 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h5><p>在项目中，登录逻辑分为两部分：用户名密码登录 和 第三方登录（如 QQ 和 WeChat）<br>1、<strong>用户名密码登录</strong><br>用户输入用户名和密码后，点击登录按钮。  用户输入<br>前端通过 Axios 发送 POST 请求，将用户名和密码传递给服务器。<br>后端校验用户名和密码是否匹配，如果成功，则生成 JWT Token 或 Session Token。<br>登录成功时，会收到包含 Token 的响应，将其保存在 localStorage 中，并添加到后续请求头中：<br>登录成功后，用户会被重定向到首页。如果 Token 失效（如过期），会触发 退出登录逻辑，清空 Token，并跳转到登录页。</p>
<p>2、<strong>第三方登录（如 QQ、WeChat 登录）</strong><br>前端引导用户跳转第三方授权页面：用户点击 QQ/WeChat 登录按钮时，前端会跳转到相应的授权页面，传递应用的 Client ID 和 回调 URL。<br>第三方认证成功后回调：用户在第三方页面完成授权后，第三方会重定向回应用的回调 URL，并携带 Authorization Code。<br>获取用户 Token：前端将获取到的 Authorization Code 发给后端，由后端请求第三方接口获取 Access Token 和用户信息。<br>后端生成 Token：后端将第三方用户信息与系统账户绑定，并生成本地的 JWT Token。<br>处理登录状态：前端收到 Token 后，存储在 localStorage 或 cookie 中，确保后续请求中携带 Token 完成用户授权验证。</p>
<p>Token 过期：使用 Axios 拦截器检测 401 状态码，触发退出登录逻辑：<br>错误提示：如果用户名或密码错误，系统会给出提示（如“用户名或密码不正确”）。</p>
<p><strong>【用户名密码登录时 用户登录成功后，怎么保存用户信息】</strong><br>【存储方式：<br>localStorage：数据持久存在，即使刷新页面或关闭浏览器后重新打开也会保留。<br>sessionStorage：仅在当前标签页或窗口有效，关闭页面即失效。<br>cookie（可选）：可以设置失效时间，支持与服务器端 Session 管理结合，适合跨页面状态保持。<br>存储用户基本信息<br>除了 Token，还会存储用户的基本信息（如用户名、角色、头像等），以便个性化展示。】</p>
<p>回答：</p>
<p>登录成功后，服务器会返回一个 Token，将它放在状态管理器中，并使用 localStorage 存储持久化信息，通过在axios请求拦截器中将token注入请求头中，使后续的API请求自动携带token， 方便服务器验证用户身份  。</p>
<p>token处理步骤：</p>
<ol>
<li>存储位置：使用 Vuex/Pinia 或 React 的 Context 存储在状态管理中，方便组件之间共享。也可以使用 localStorage 存储持久化信息。</li>
<li>请求拦截器注入 Token：<br>为了在后续的 API 请求中自动携带 Token，使用 Axios 请求拦截器将 Token 注入请求头。</li>
<li>登录状态的维护（页面刷新或重启时）：<br>在应用初始化时（如 App.vue 的 created 生命周期内），从 localStorage 或 cookie 中读取 Token 和用户信息，恢复登录状态。</li>
<li>Token 过期处理：服务端返回 401 Unauthorized 状态，触发退出逻辑。</li>
</ol>
<h5 id="滑动验证"><a href="#滑动验证" class="headerlink" title="滑动验证"></a>滑动验证</h5><p>原理：将用户拖动行为的时间、精度，滑动轨迹等信息到服务器，然后进行后台算法验证。（区分人机行为）</p>
<p>输入用户名密码 <code>-&gt;</code> 点击登录按钮 <code>-&gt;</code> 显示滑动验证码 <code>-&gt;</code> 用户拼图成功 <code>-&gt;</code> 登陆成功</p>
<p><strong>实现逻辑：</strong></p>
<p>采用gitee上开源的slideCaptcha第三方的包。</p>
<p>首先在人类行为验证组件完成对应UI样式，</p>
<p>然后创建captcha实例，在组件挂载onMounted时初始化，</p>
<p>指定滑动验证码的渲染位置，再处理成功、失败的回调函数，</p>
<p>在用户成功完成拼图的回调中，通过调用 getCaptcha （异步）接口传递用户的行为数据给后端进行进一步的验证，进行人类行为判定。</p>
<p>【const res = await getCaptcha({ behavior: arr })】</p>
<p>在用户拼图失败的回调中，显示“验证失败”提示信息。</p>
<h5 id="第三方扫码登录"><a href="#第三方扫码登录" class="headerlink" title="第三方扫码登录"></a>第三方扫码登录</h5><p>前提: app和网站都上线了—&gt; 追加扫码登录的功能，1.0 没有扫码登录功能<br>申请二维码: 网站已经做好 —&gt; 在QQ、微信开放平台创建网站应用，需和网站一一对应<br>后台 会传输前端一个包含二维码的页面<br>扫码：请求头信息，相关配置信息 —&gt; 传给后台校验<br>校验之后：成功 —&gt; 后台会有一个成功地址</p>
<p>微信：</p>
<ol>
<li><p>在微信开放平台创建应用：网站域名和回调地址，获得对应的appid与appkey。</p>
</li>
<li><p>用户点击 微信登录 触发事件，通过 接口 获取微信登录前置数据（比如appid、appSecret）</p>
</li>
<li>根据获取到的数据，拼接得到 open url 地址</li>
<li>打开该地址window.open，展示微信登录二维码，用户扫码确定登录</li>
<li>从用户确认登录的回调窗口中解析 window.location.search ，使用正则表达式得到用户的 code 数据window.location.search 返回当前 URL 的查询字符串，URL 中问号 ? 后面的部分，包括？</li>
<li>根据 appId、appSecret、code 通过【接口】获取用户的 access_token、openid</li>
<li>根据access_token、openid通过【接口】获取用户信息，并执行登录操作 oauthLogin()</li>
</ol>
<p>QQ： 【扫码登录之后，进入的地址为 线上的回调地址 ，调试必须在线上进行】</p>
<ol>
<li><p>在qq开放平台创建应用：网站域名和回调地址，获得对应的appid与appkey。</p>
</li>
<li><p>展示二维码：用户点击 QQ登录 按钮触发事件，进入第三方登录页（window.open）展示 QQ 登录二维码</p>
</li>
<li>获取用户信息：<br>在执行 QQ 登录挂起操作onMounted(()=&gt;{QC.Login()})时，登录成功的回调中(data, opts)中由于 QQ 登录存在缓存【登录成功一次之后，下次进入会自动重新登录】，为防止下次进入时自动重新登录，在离开登录页面时，注销登录QC.Login.signOut()；<br>在用户扫码登录成功的回调地址window.location.hash中，使用正则表达式获取当前用户唯一标识access_token，以此作为判断用户是否已注册过的依据；<br>将获得的用户信息（nickname、头像、access_token）进行跨页面传输。</li>
<li>完成【跨页面数据传输】：BroadcastChannel + localStorage  QQ登录小窗口 -&gt; 主窗口<br>BroadcastChannel 允许不同浏览器多个标签页或窗口之间进行通信。如果 BroadcastChannel 不可用，代码则回退使用 localStorage 作为替代方案，通过监听 storage 事件来实现类似效果<br>broadcast.send(oauthObj) -&gt; 关闭第三方窗口window.close()</li>
<li>认证是否已注册</li>
</ol>
<ul>
<li>用户通过第三方登录，调用 Vuex 的 login 动作，向后台发送登录请求，并获取响应状态码。</li>
<li>如果用户未注册（即返回特定状态码 LOGIN_TYPE_OAUTH_NO_REGISTER_CODE），<br>系统提示用户创建账号，并跳转到注册页面router.push()。</li>
<li>如果用户已注册，直接跳转到系统首页router.push(‘/‘)。</li>
</ul>
<ol>
<li>完成 QQ 对接：移动端 -&gt; 问题：用户授权登录成功后，没有直接进入首页或注册页<br>在执行登录挂起操作里，进行挂页面传输之后，继续执行登录操作 oauthLogin(LOGIN_TYPE_QQ, oauthObj)</li>
</ol>
<p><code>OAuth</code> 的思路：<code>OAuth</code>是一个关于授权（<code>authorization</code>）的开放网络标准。应用通过引导用户在第三方平台的授权层进行登录授权，获得一个限制权限和有效时间的令牌（token），在令牌有效期内即可从第三方平台换取用户授权使用的信息。</p>
<p>客户端授权模式：授权码模式、简化模式、密码模式、客户端模式。</p>
<p>授权码模式 ：最完整、流程最严密。基于授权码模式的第三方登录流程如下：</p>
<ol>
<li>点击第三方登录按钮：执行 window.open 方法，打开一个第三方指定的 URL 窗口，该地址会指向第三方登录的 URL ，并且由第三方提供一个对应的二维码</li>
<li>弹出一个小窗口，展示对应二维码：此处展示的二维码，为上一步中第三方提供的二维码</li>
<li>手机打开对应的 APP 进行扫码之后，会跳转到【同意页面】，同时浏览器端也会显示扫码成功：在第三方中会一直对该页面进行【轮询】，配合第三方 APP 来判断是否扫码成功</li>
<li>手机端操作同意登录之后，会出现两种情况：在 APP 中同意之后，第三方会进行对应的跳转，跳转地址为你指定的地址，在该地址中可以获取到【第三方的用户信息】，该信息即为第三方登录时要获取到的关键数据。</li>
<li><p>至此，第三方操作完成。接下来需要进行本平台的登录判定。</p>
</li>
<li><p>该注册指的是【第三方用户】是否在本平台中进行了注册。</p>
</li>
<li>因为在之前的所有操作中，拿到的是【第三方的用户信息】</li>
<li>该信息可以帮助直接显示对用的用户名（nickname）和头像，但是因为不包含关键信息（手机号、用户名（username）、密码）所以无法使用该信息帮助用户直接登录</li>
<li>所以需要判断当前用户是否在咱们自己的平台中完成了注册</li>
</ol>
<ul>
<li>1.当前用户已注册：直接登录</li>
<li>2.当前用户未注册：执行注册功能</li>
</ul>
<h4 id="axios二次封装"><a href="#axios二次封装" class="headerlink" title="axios二次封装"></a><code>axios</code>二次封装</h4><p>在请求拦截器中设置接口基础地址、超时时间、登录成功后请求头携带<code>token</code>，响应拦截器做异常处理。</p>
<p>axios 的使用 ：请求方式：<code>axios.get()</code>、<code>axios.post()</code>、<code>axios(&#123;&#125;)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get 请求：</span><br><span class="line">axios.get(&quot;url?参数1=值&amp;参数2=值&quot;);// 给后端传递的参数 ==&gt; 参数1=值&amp;参数2=值</span><br><span class="line"></span><br><span class="line">post 请求：</span><br><span class="line">axios.post(&quot;url&quot;, &#123; 参数1: 值, 参数2: 值 &#125;);</span><br></pre></td></tr></table></figure>
<p>axios 二次封装 ：</p>
<ol>
<li>提高代码复用性，减少代码量，减低维护难度。</li>
<li>统一处理一些常规的问题一劳永逸，如 http 错误。</li>
<li>拦截请求和响应，提前对数据进行处理，如获取 token，修改配置项。</li>
</ol>
<p>实现逻辑：</p>
<p>1、创建axios实例axios.create({})，设置请求的基础地址baseURL和超出时间timeout</p>
<p>2、请求拦截器：在每个请求发送之前执行的逻辑，允许在请求头中添加额外的配置信息</p>
<p>如果用户已经登录且有 token（vuex store），就把这个 token 加入到请求头的 Authorization 字段里，用于身份认证。</p>
<p>成功则返回配置，继续发送请求。遇到错误，就通过 Promise.reject 返回错误。</p>
<p>3、响应拦截器：在每次接收到服务器的响应后进行处理</p>
<p>成功处理：如果 response.data 中的 success 为真，返回数据 data。否则，通过 Promise.reject 抛出错误，并将错误信息封装进 Error 对象。</p>
<p>错误处理：</p>
<p>如果响应中的错误码为 401（表示 Token 过期），则触发用户退出逻辑（store.dispatch(‘user/logout’)）</p>
<p>弹出错误提示信息（$message 显示服务器返回的错误信息）。</p>
<p>返回错误信息给调用方，确保错误能够被捕获。</p>
<h4 id="瀑布流和长列表"><a href="#瀑布流和长列表" class="headerlink" title="瀑布流和长列表"></a>瀑布流和长列表</h4><h5 id="瀑布流组件"><a href="#瀑布流组件" class="headerlink" title="瀑布流组件"></a>瀑布流组件</h5><ol>
<li>核心：通过<code>relative</code> 和<code>absolute</code>定位的方式，来控制每个 <code>item</code> 的位置</li>
<li>需要分别处理服务端是否会返回 关键<code>img</code>的高度 ：</li>
</ol>
<ul>
<li>当服务端【不返回】高度时：需要等待 <code>img</code> 加载完成之后(预加载)，再来计算高度，然后通过得到的高度计算定位。否则会出现高度计算不准确导致定位计算不准确的问题。</li>
<li>当服务端【返回】高度时：开发者则必须利用此高度为 <code>item</code> 进行高度设定。一旦 <code>item</code>具备指定高度，那么就不需要等待 <code>img</code>加载的过程，这样效率更高，并且可以业务的逻辑会变得更加简单。</li>
</ul>
<ol>
<li>当进行响应式切换时，同样需要区分对应场景：</li>
</ol>
<ul>
<li>当服务端【不返回】高度时：需要 重新执行整个渲染流程 ，虽然会耗费一些性能，但可以最大可能的避免出现逻辑错误。让组件拥有更强的普适性。</li>
<li>当服务端【返回】高度时：同样需要重新计算 列宽 和 定位 ，但因为 <code>item</code>具备明确的高度，所以可以直接拿到具体的高度，而无需重复整个渲染流程，从而可以实现更多的交互逻辑。比如：位移动画、将来的图片懒加载占位…</li>
</ul>
<p>瀑布流布局的核心实现思想：</p>
<ol>
<li>控制容器内每一列卡片的宽度相同（不同图片尺寸等比例缩放）</li>
<li>第一行卡片紧挨着排列， 第二行开始采取贪心思想，每张卡片摆放到当前所有列中高度最小的一列下面<br>每个卡片<code>item</code>必须使用<code>absolute</code>绝对布局，并通过<code>top</code>和<code>left</code>来手动控制位置<br>通过<code>props</code>传递关键数据：数据源、唯一标识<code>key</code>、列数、列间距、行间距、是否需要预加载<br>计算容器宽度【<code>offsetWidth -</code>左右边距】和列宽【（容器的宽度 - 所有的列间距宽度）/ 列数】<br>想要计算每列的<code>left</code>、<code>top</code>，必须要拿到每个<code>item</code>的高度，才可以判断下一列的第一个<code>item</code>的位置。根据<code>pitturePreReading</code>可以分为两种情况：① 需要图片预加载时：图片高度未知 ② 不需要图片预加载时：图片高度已知<br>计算下一个<code>item</code>位置：<code>left =</code>最小高度所在的列 <em> (列宽 + 间距) <code>top =</code>最小高度所在列高+列间距<br>适配移动端：自定义列数变化<code>:column = &quot;isMobileTerminal ? 2 : 5&quot;</code>，在<em>*列宽发生变化</em></em>时，重新执行计算列宽</li>
</ol>
<p>难点：当设置<code>:picturePreReading=&quot;false&quot;</code>，不进行图片预加载时，在切换 PC 端和移动端时会出现图片重叠现象（图片高度计算出现错误）。出现原因：不进行图片预加载时，会直接获取当前<code>item</code>的高度，因为没有等待图片加载完成，此时的高度是不包含图片的高度，从而使整个<code>item</code>高度计算错误。</p>
<p>根据服务端返回的图片接口数据使用作用域插槽返回图片宽度，进而计算等比例缩放后的图片高度【计算后的图片高度 = （计算得到宽度/图片真实宽度）* 图片真实高度】。重新监听列数变换，增加图片不进行预加载的情况</p>
<h5 id="长列表"><a href="#长列表" class="headerlink" title="长列表"></a>长列表</h5><p>分页展示数据的功能     核心需求：监听列表滚动到底部</p>
<p>监听到列表滚动到底部，可利用 IntersectionObserver ，该接口可以判断： 目标元素与其祖先元素或顶级文档视窗( viewport )的交叉状态（是否可见）。</p>
<p>因为需要监测到列表是否滚动到底部，再去加载数据，可以把一个元素（包裹加载更多的图标和”没有数据了”的div）置于列表底部，利用 vueuse 提供的 useIntersectionObserver方法，监听元素可见行为，用于判断列表滚动到底部。对于组件传入参数，设置了两个参数：一个用于控制是否处于加载状态modelValue，一个标记是否所有数据已经加载完毕isFinished。当被监听的元素进入了视口、当前也不在加载状态，且数据也为加载完毕的时候，触发加载逻辑【显示 加载更多 的图标（loading.value = true），并通知父组件加载更多数据（触发 onLoad 事件：emits(‘onLoad’) ）。】</p>
<p>useIntersectionObserver(laodingTarget, ([{ isIntersecting }]) =&gt; {</p>
<p>  // 当加载更多的视图可见时， loading 为 false， 数据尚未全部加载完</p>
<p>  if(isIntersecting &amp;&amp; !loading.value &amp;&amp; !props.isFinished){</p>
<p>​     loading.value = true // 修改加载数据标记</p>
<p>​     emits(‘onLoad’) // 触发加载更多行为</p>
<p>  }</p>
<p>})</p>
<p><strong>【当更改数据请求 size，首次数据请求加载无法铺满全屏时，且鼠标滚动也无法触发下一页请求】</strong></p>
<p>当首次加载数据无法铺满全屏的时候，虽然检测是否可见的变量可见的 ，但它只会被触发一次，也就是 useIntersectionObserver 里的回调只会触发一次，不会再一次触发对应的 loading ，从而出现上述问题。</p>
<p>判断 isIntersecting 方法在 loading 发生变化后重新进行一次判断，通过 watch 监听loading：watch(loading, emitLoad()})。确保页面首屏或新加载的数据能再次触发滚动检测，避免未铺满页面的情况。还可以使用 setTimeout 做短暂延迟防抖处理，避免重复触发。</p>
<p>优点：该组件实现了自动加载更多数据的功能，避免一次性渲染大量数据造成的性能问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span> /&gt;</span> // 内容 </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;laodingTarget&quot;</span> <span class="attr">class</span>=<span class="string">&quot;h-6 py-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      // 加载更多</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">m-svg-icon</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">v-show</span>=<span class="string">&quot;loading&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">class</span>=<span class="string">&quot;w-4 h-4 mx-auto animate-spin&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">name</span>=<span class="string">&quot;infinite-load&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span><span class="tag">&lt;/<span class="name">m-svg-icon</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      // 没有更多数据了 </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;isFinished&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-center text-base text-zinc-400&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        已经没有更多数据了!</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useVModel, useIntersectionObserver &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;...&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&#x27;onLoad&#x27;</span>, <span class="string">&#x27;update:modelValue&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> loading = <span class="title function_">useVModel</span>(props) <span class="comment">// 处理 loading 状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> laodingTarget = <span class="title function_">ref</span>(<span class="literal">null</span>) <span class="comment">// 滚动的元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> targetIsIntersecting = <span class="title function_">ref</span>(<span class="literal">false</span>) <span class="comment">// 记录当前是否在底部（是否交叉）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">useIntersectionObserver</span>(laodingTarget, <span class="function">(<span class="params">[&#123; isIntersecting &#125;]</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  targetIsIntersecting.<span class="property">value</span> = isIntersecting <span class="comment">// 获取当前交叉状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">emitLoad</span>() <span class="comment">// 触发 load</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                       )</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 触发 load</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> <span class="title function_">emitLoad</span> = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 当加载更多的视图可见时，加载更多数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">if</span> (targetIsIntersecting.<span class="property">value</span> &amp;&amp; !loading.<span class="property">value</span> &amp;&amp; !props.<span class="property">isFinished</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    loading.<span class="property">value</span> = <span class="literal">true</span> <span class="comment">// 修改加载数据标记</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">emits</span>(<span class="string">&#x27;onLoad&#x27;</span>) <span class="comment">// 触发加载更多行为</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 监听 loading 的变化，解决数据加载完成后，首屏未铺满的问题</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">watch</span>(loading, <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">emitLoad</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;, <span class="number">100</span>)<span class="comment">// 触发 load，延迟处理，等待 渲染和 useIntersectionObserver 的再次触发</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="懒加裁"><a href="#懒加裁" class="headerlink" title="懒加裁"></a>懒加裁</h4><h5 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h5><p><strong>监听图片是否可见，在图片可见时，再去加载图片。</strong></p>
<p>vueuse提供的useIntersectionObserver方法：监听DOM元素是否进入视口</p>
<p>const {stop} = useIntersectionObserver(target, fn, options)</p>
<ol>
<li><p>stop 是useIntersectionObserver方法</p>
</li>
<li><p>参数 1 target表示被监听的DOM元素</p>
</li>
<li>参数 2 fn是回调函数，用于通知监听的动作（回调函数的第一个形参isIntersecting表示被监听的元素已经进入了可视区）</li>
<li>参数 3 options表示配置选项</li>
</ol>
<p><strong>实现逻辑：</strong><br>1、在元素挂载到页面中的钩子函数中 mounted(el){}，保存img的src：const imgSrc = el.src，<br>2、将img的src属性置为 空 或者置位默认图片（el.src = “”）<br>3、使用vueuse提供的useIntersectionObserver方法监听图片是否在可视范围内，如果在，则将img的src属性设置为原始图片的URL（el.src = imgSrc），并停止监听stop()</p>
<h5 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h5><p>defineAsyncComponent 方法：创建一个按需加载的异步组件</p>
<p>接收一个返回Promise的加载函数。这个Promise的 resolve 回调方法应该在从服务器获得组件定义时调用。也可以调用 reject(reason) 表明加载失败。</p>
<p><strong>【通用组件 -&gt; 自动化注册】</strong>：</p>
<p>1、通过install()将组件注册到Vue应用上，使得可以用app.use()在全局范围内注册组件</p>
<p>2、在方法内获取所有文件夹中以index.vue结尾的文件import.meta.glob(vite提供的特性)</p>
<p>const components = import.meta.glob(“./*/index.vue”)</p>
<p>3、遍历获取到的组件模块：for (const [path, fn] of Object.entries(components)) {}</p>
<p>利用path生成组件名称：</p>
<p>const componentName = “m-“ + path.replace(“./“, “”).split(“/“)[0]</p>
<p>4、利用 app.component() 将生成的组件名称和对应的异步组件注册到 Vue 应用上。使用 defineAsyncComponent() 包装每个组件，使组件在第一次被使用时才加载，实现组件的懒加载</p>
<p>app.component(componentName, defineAsyncComponent(fn))</p>
<h4 id="防抖搜索优化"><a href="#防抖搜索优化" class="headerlink" title="防抖搜索优化"></a>防抖搜索优化</h4><p>首页输入框搜索 防抖  -  合并多次快速触发的事件，减少不必要的网络请求。</p>
<p>核心思想：当触发一个事件时，不去立刻执行，而是延迟一段时间，使该事件变为等待执行事件。如果在这段时间之内，该事件被再次触发，则上次等待执行的事件取消，本次触发的事件变为等待执行事件。循环往复，直到某一个等待事件被执行为止</p>
<p>搜索提示 是通过 watch 监听输入内容的变化，所以当输入内容发生变化时，就会立刻触发 获取搜索提示数据 事件（getHintData）。此时需要做防抖处理，</p>
<p>文本搜索防抖逻辑：</p>
<p>使用 vueuse 提供的 watchDebounced方法 ，监听输入内容props.searchText的变化，当输入内容发生变化时，立刻触发 获取搜索提示数据 事件（getHintData）</p>
<p>设置immediate：true表示立即执行回调</p>
<p>debounce: 500 启用防抖机制，表示在 输入 改变后延迟 500 毫秒才执行回调</p>
<p>// 监听搜索文本的变化，并获取对应提示数据</p>
<p>watchDebounced(() =&gt; props.searchText, getHintData, {</p>
<p>  immediate: true,</p>
<p>  debounce: 500 // 每次事件触发时，延迟的时间</p>
<p>})</p>
<h4 id="移动端适配-响应式布局"><a href="#移动端适配-响应式布局" class="headerlink" title="移动端适配 - 响应式布局"></a>移动端适配 - 响应式布局</h4><p>1.百分比布局：通过百分比单位使浏览器中的组件的宽和高随着浏览器的变化而变化</p>
<ul>
<li>height、width属性的百分比依托于父标签的宽高。但是padding、border、margin等属性的情况又不一样</li>
<li>1、子元素的 top 和 bottom 如果设置百分比，则相对于直接非 static 定位（默认定位）的父元素的高度，同样，子元素的 left 和 right 如果设置百分比，则相对于直接非 static 定位（默认定位的）父元素的宽度。<br>2、子元素的 padding 和 margin 如果设置百分比，不论是垂直方向或者是水平方向都相对于直接父亲元素的 width ，而与父元素的 height 无关。</li>
<li>border-radius 为百分比，则是相对于自身的宽度</li>
<li>缺点：计算困难，如果要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位</li>
</ul>
<ol>
<li>媒体查询布局：通过 @media 媒体查询，给不同屏幕的大小编写不同的样式来实现。</li>
</ol>
<ul>
<li>缺点：如果浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。</li>
</ul>
<ol>
<li>rem 布局： rem 是 CSS3 新增的一个相对单位，1rem = 16px</li>
</ol>
<ul>
<li>rem 是相对于 html 根元素的字体大小的单位。</li>
<li>通过修改html中 font-size 的字体大小来控制 rem 的大小。</li>
</ul>
<ol>
<li>vw、vh 响应式布局：vw 和 vh 分别相对的是视图窗口的宽度和高度。</li>
</ol>
<ul>
<li>100vw = 100% 视图窗口宽度 ，100vh = 100% 视图窗口高度</li>
</ul>
<ol>
<li><p>flex 弹性布局：只需要依赖于 CSS 样式的实现响应式布局的方式</p>
</li>
<li><p>父元素：常用的弹性布局的属性</p>
</li>
</ol>
<ul>
<li>flex-direction ：水平方向对齐方式（wrap\wrap-reverse\colume\colume）</li>
<li>flex-wrap ：是否换行</li>
<li>justify-content ： 水平方向对齐方式</li>
<li>align-items ：控制子元素在垂直方向上的对齐方式</li>
<li>align-content ：垂直方向的对齐方式</li>
</ul>
<ol>
<li>子元素：常用的弹性布局的属性</li>
</ol>
<ul>
<li>order ：排序，给元素指定不同数值，数值越大越靠后</li>
<li>flex-grow ： 对容器剩余空间，按指定比例放大元素填充容器</li>
<li>flex-shrink ：对超出容器空间按数值比例收缩填充</li>
<li>flex-basis ：指定元素在主轴（水平）方向上的初始大小</li>
<li>align-self ：控制单个元素在交叉轴（垂直）上的对齐</li>
</ul>
<p>项目中 移动端 使用的是<code>flex + rem</code>响应式布局的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次加载成功时设置html跟标签的fontSize属性值；最大基准值为40px</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useREM</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">MAX_FONT_SIZE</span> = <span class="number">40</span>; <span class="comment">// 最大基准值</span></span><br><span class="line">  <span class="comment">// 当文档被解析成功时调用</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;html&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置屏幕基准值的标准为 屏幕的宽度 / 10</span></span><br><span class="line">    <span class="keyword">const</span> fontSize = <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="number">10</span>;</span><br><span class="line">    html.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="title class_">Math</span>.<span class="title function_">min</span>(fontSize, <span class="variable constant_">MAX_FONT_SIZE</span>) + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="人力资源后台项目"><a href="#人力资源后台项目" class="headerlink" title="人力资源后台项目"></a>人力资源后台项目</h3><h4 id="介绍（难点解决）"><a href="#介绍（难点解决）" class="headerlink" title="介绍（难点解决）"></a>介绍（难点解决）</h4><p>这是一个企业人力资源管理后台系统，包含了组织管理、角色管理、员工管理和权限管理等核心模块，主要为了帮助企业实现高效的员工管理和角色权限分配。</p>
<p>主要的技术栈是：Vue2、ElementUI、ECharts</p>
<p>1、在系统中，不同用户角色（如管理员、HR、普通员工）需要访问不同的页面和功能。使用 RBAC 进行权限管理时，需要根据用户登录后的角色动态加载对应的路由。</p>
<p>使用 vue-router 动态添加路由，在用户登录后根据角色权限生成菜单。</p>
<p>登录时，后端返回用户的角色和权限数据，并根据这些权限调用 Vue-Router 的 addRoute() 方法动态加载路由。</p>
<p>2、后端返回的组织架构数据是列表形式的，需要转换为树形结构，以便在前端的树形组件中展示。</p>
<p>使用 递归算法 将列表数据转换为树形结构，并在 ElementUI 的 el-tree 组件中进行展示。</p>
<p>3、在处理大量员工数据时，需要实现 Excel 文件的导入导出，并确保数据格式正确、性能高效。</p>
<p>使用 FileSaver.js 进行文件导出，将员工数据导出为 Excel 文件。</p>
<p>同时使用 xlsx 库解析 Excel 文件，实现数据的导入和验证。</p>
<h4 id="权限RBAC"><a href="#权限RBAC" class="headerlink" title="权限RBAC"></a>权限RBAC</h4><p>使用<code>vue-router</code>配置路由切换视图，在权限模块中基于<code>RBAC</code>权限模型实现动态添加路由规则，完成不同角色的权限分配。（员工 - 角色 - 权限）</p>
<p><strong>RBAC权限：</strong></p>
<p>   <strong>1、核心概念</strong>：</p>
<ul>
<li><strong>用户</strong>：使用系统的人员。</li>
<li><strong>角色</strong>：权限集合，一个角色可以对应多种权限。</li>
<li><strong>权限</strong>：操作资源的能力，例如读、写、删除等。</li>
<li><p><strong>资源</strong>：系统中的数据或功能。</p>
<p> <strong>2、工作流程</strong>：</p>
</li>
<li><p>首先将<strong>用户</strong>赋予一个或多个<strong>角色</strong>，每个角色关联一组特定的<strong>权限</strong>。</p>
</li>
<li>用户通过自己的角色获得相应的权限，进而访问资源。</li>
<li>这样，权限管理变得简单灵活：<strong>只需更改角色的权限，所有拥有该角色的用户权限也会相应更新</strong>。</li>
</ul>
<p>RBAC权限控制和<strong>Token认证</strong>的使用，流程大致如下:</p>
<ol>
<li>用户登录时，客户端向服务端发送登录请求，服务端验证用户名密码是否正确，如果正确则返回一个Token值给客户端。</li>
<li>客户端在后续的请求中，在Header中携带这个Token值，服务端根据Token值来识别用户身份。</li>
<li>服务端根据用户的身份和角色信息，对请求的API接口或页面元素进行权限判断，如果有权限则返回数据，否则返回403或401等错误码。</li>
</ol>
<p>权限管理就是让不同的用户只能访问自己权限内的资源，有以下几种</p>
<ul>
<li>路由权限，用户登录后只能看到自己权限内的导航菜单，且只能访问自己权限内的路由地址</li>
<li>视图权限，用户只能看到自己权限内的内容和按钮</li>
<li>请求权限，越权请求将其拦截</li>
</ul>
<p>权限管理：接口权限、按钮权限、菜单权限、路由权限</p>
<p><strong>接口权限</strong></p>
<p>用户登录成功拿到<code>token</code>，将<code>token</code>存起来（cookie中），通过<code>axios</code>请求拦截器进行拦截，让请求头携带<code>token</code></p>
<p><strong>路由权限</strong></p>
<p> 将路由配置分为静态路由和动态路由，</p>
<p><strong>静态路由</strong> 是所有用户都可以访问的公共页面  ，比如登录页，404 页。</p>
<p><strong>动态路由</strong> 定义了需要权限的页面，通常基于用户角色动态添加到路由表中，用于管理部门、角色、员工等内容。</p>
<p>项目实现步骤：</p>
<p>   初始化的时候先挂载静态路由。</p>
<p>   如果用户通过 URL 进行强制访问，会直接进入 404。</p>
<p>   在前置路由守卫中，判断token是否存在，存在则跳转到首页，</p>
<p>   再判断是否获取过用户信息，【通过<code>store.dispatch</code>获取用户信息】。</p>
<p>   获取到当前对应的权限，筛选出动态路由， 并通过 <code>router.addRoutes</code> 动态添加到路由表。    </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2024/png/47685228/1730463914920-40e49588-5d7a-46e5-afa7-0f8ffc656525.png" alt="img"></p>
<p><strong>菜单权限</strong></p>
<p>用户登录之后服务端返回一个数据，这个数据有菜单列表和<code>token</code>，我们把这个数据放入到<code>vuex</code>中，<strong>在 Vuex 中管理用户的路由信息</strong>，并将<strong>路由数据传递给左侧菜单进行渲染</strong>。  </p>
<p><strong>按钮权限</strong></p>
<p>通过 自定义指令 进行按钮权限的判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装自定义指令 用来控制操作权</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;permission&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 会在指令作用的元素插入到页面完成以后触发</span></span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(el) <span class="comment">// el 指令作用的元素的dom对象</span></span><br><span class="line">    <span class="keyword">const</span> points = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>?.<span class="property">roles</span>?.<span class="property">points</span> || [] <span class="comment">// 当前用户信息的操作权</span></span><br><span class="line">    <span class="keyword">if</span> (!points.<span class="title function_">includes</span>(binding.<span class="property">value</span>))&#123; <span class="comment">// 不存在就要删除或者禁用</span></span><br><span class="line">      el.<span class="title function_">remove</span>() <span class="comment">// 删除元素</span></span><br><span class="line">      <span class="comment">// el.disabled = true</span></span><br><span class="line">      <span class="comment">// 线上的权限数据和线下的代码进行对应</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 应用自定义指令</span></span><br><span class="line">  &lt;el-button v-permission=<span class="string">&quot;&#x27;add-employee&#x27;&quot;</span> size=<span class="string">&quot;mini&quot;</span> type=<span class="string">&quot;primary&quot;</span> @click=<span class="string">&quot;$router.push(&#x27;/employee/detail&#x27;)&quot;</span>&gt;</span><br><span class="line">  添加员工</span><br><span class="line">  &lt;/el-button&gt;</span><br></pre></td></tr></table></figure>
<h4 id="vuex管理"><a href="#vuex管理" class="headerlink" title="vuex管理"></a><code>vuex</code>管理</h4><p>​    用于管理用户的<strong>登录状态和基本信息</strong>。将用户的<code>token</code>状态共享，实现后续高效目方便的读取。</p>
<p>项目登录流程：</p>
<p>   1、表单校验通过 </p>
<p>   2、调用Vuex提供的登录的action</p>
<p>   3、登录的action中会调用登录接口，如果成功执行，会返回token</p>
<p>   4、利用Vuex特性，将token共享的到Vuex中，这样直接通过 Vuex 就可以登录接口会调用单独封装的请求模块(api)</p>
<p>   5、请求模块中又会使用用到 axios 封装的请求工具</p>
<p>   6、而请求工具又要考虑区分 开发环境和生产环境的问题</p>
<p>   7、请求时还要考虑前后分离项目产生的跨域问题，要使用代理解决跨域</p>
<p>Vuex中声明用户信息状态state，修改用户信息的mutations， 和获取用户信息的action</p>
<p>实现token的Vue数据持久化</p>
<p>用户信息不同于token，token是当前用户的唯一标识，在几个小时内都是有效的，但是用户信息可能会进行修改或者发生变化，所以用户信息在一般的项目或者业务中不进行缓存。</p>
<h4 id="excel导入导出"><a href="#excel导入导出" class="headerlink" title="excel导入导出"></a><code>excel</code>导入导出</h4><p>使用 FileSaver.js 第三方库实现员工信息 excel 文件的导入导出。</p>
<ul>
<li>员工管理 - excel 导出</li>
</ul>
<p>1、导出员工接口返回的是二进制流，所以封装接口api时，需要 改变接收数据的类型，将responseType 配置为 为 Blob 格式。</p>
<p>2、在响应拦截器内判断是不是blob类型，如果是直接返回数据，不再进行解构</p>
<p>3、点击按钮调用接口，使用file-saver将blob转化成文件下载</p>
<p>FileSaver.saveAs(result, ‘员工信息表.xlsx’) // 下载文件</p>
<ul>
<li>员工管理 - excel 导入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建组件 --&gt; 点击按钮弹出组件 --&gt; 下载模板、上传excel、拖拽上传 --&gt; 导入成功、取消 --&gt; 关闭并重新加载、关闭</span><br></pre></td></tr></table></figure>
<p>下载模板：调用 下载员工导入模版 接口  FileSaver.saveAs(getExportTemplate(), ‘员工导入模版.xlsx’)</p>
<p>上传excel：弹出文件选择框 —&gt; 文件选择 —&gt; 调用上传接口 —&gt; 成功 —&gt; 重新加载数据-关闭弹窗 —&gt; 清空文件选择器</p>
<p>触发文件选择框input，监听文件改变@change =“uploadChange”事件，</p>
<ul>
<li><strong>文件获取</strong>：通过 <code>event.target.files</code> 获取用户选择的文件列表，确保至少选择了一个文件（<code>files.length &gt; 0</code>）。</li>
<li><strong>构建上传数据</strong>：使用 <code>FormData</code> 对象创建 <code>data</code>，并将文件（<code>files[0]</code>）添加为 <code>file</code> 参数，以符合上传接口 <code>uploadExcel()</code> 的要求。</li>
<li><strong>上传文件</strong>：通过 <code>await uploadExcel(data)</code> 调用上传接口，上传成功后：</li>
<li>触发 <code>uploadSuccess</code> 事件通知父组件上传成功，并重新加载数据。</li>
<li>触发 <code>update:showExcelDialog</code> 事件并设置为 <code>false</code>，关闭上传弹窗。</li>
<li><strong>异常处理</strong>：在 <code>catch</code> 块中捕获上传失败的异常，可在此进行错误处理或提示用户上传失败。</li>
<li><strong>清理文件选择器</strong>：在 <code>finally</code> 块中重置文件选择框（<code>this.$refs[&#39;excel-upload-input&#39;].value = &#39;&#39;</code>），保证上传完成后文件选择器的状态被清空，不论上传成功或失败。</li>
</ul>
<p>父组件需要监听上传成功的事件</p>
<h4 id="递归列表转树"><a href="#递归列表转树" class="headerlink" title="递归列表转树"></a>递归列表转树</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2024/png/47685228/1730463914940-1fc0e287-11ae-4059-8baf-5e555aa98202.png" alt="img"></p>
<ol>
<li>首先分析数据的关联关系（部门 id 是子部门的 pid）</li>
<li>封装递归函数根据关联关系转化层级结构</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2024/png/47685228/1730463915095-89ea26d2-ab2f-4a3e-bb23-e56e994dc47c.png" alt="img"></p>
<p>实现过程：</p>
<ol>
<li>首先分析数据的关联关系（部门 id 是子部门的 pid）</li>
<li>遍历列表数据，找到 <strong>当前节点的id 和 当前节点的子节点的pid</strong> 相等</li>
<li>对每个匹配节点递归调用，查找其子节点。将子节点数组赋给当前节点的 <code>children</code> 属性</li>
<li>将结果逐层返回，最终形成完整的树形结构。</li>
<li>在 <code>created</code> 生命周期钩子中调用获取数据方法并转换为树形结构赋值。</li>
</ol>
<p>递归特点：① 一般用来处理未知层级的数据 ② 递归要有跳出条件 ③ 自身调用自身时参数不能重复</p>
<h2 id="主观题"><a href="#主观题" class="headerlink" title="主观题"></a>主观题</h2><p>为什么选择做前端</p>
<p>你是如何学习前端的，平时都关注哪些新技术</p>
<p>你未来的职业规划是什么</p>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><p>Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</p>
<p>1、【beforeCreate/onBeforeCreate】<br>在实例初始化之后触发，当前阶段data、methods都不可用。<br>2、【created】 实例创建完成后发生，当前阶段完成了数据观测，data、methods已经可用。<br>但模板还没有编译，DOM 还未挂载，如果非要想，可以通过vm.$nextTick来访问Dom。</p>
<p>3、【beforeMount/onBeforeMount】<br>发生在挂载前，在这之前template模板已导入渲染render函数编译。<br>当前阶段虚拟Dom已经创建完成，但尚未挂载到真实的 DOM。此时对数据进行更改不会触发updated。<br>4、【mounted/onMounted】<br>实例已被挂载，DOM渲染完成，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</p>
<p>5、【beforeUpdate/onBeforeUpdate】<br>发生在更新前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。<br>6、【updated/onCreated】<br>发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p>
<p>7、【beforeDestroy/onBeforeUnmounted】<br>发生在实例销毁前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。<br>8、【destroyed/onUnmounted】<br>发生在实例销毁后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p>
<p>① 第一次页面加载会触发哪几个钩子？ beforeCreate、created、beforeMount、mounted<br>② 你的接口请求一般放在哪个生命周期中？<br>  一般放在mounted中，但需要注意的是服务端渲染时不支持mounted，需要放到created中<br>③ DOM 渲染在哪个周期中就已经完成？ 在mounted中，</p>
<ul>
<li>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果需要等整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</li>
</ul>
<h3 id="vue2-3响应式原理"><a href="#vue2-3响应式原理" class="headerlink" title="vue2/3响应式原理"></a>vue2/3响应式原理</h3><p>【vue2】：</p>
<p>Object.defineProperty() 实现对数据的劫持，将数据对象属性转换成 getter 和 setter</p>
<p>getter：访问数据时触发，Vue 会对依赖进行收集，也就是把依赖这个数据的组件记录下来</p>
<p>setter：数据发生变化时触发，Vue 会通知所有依赖这个数据的地方进行更新，重新渲染。</p>
<p>● 组件data数据一旦变化，立刻触发视图的更新</p>
<p>● 缺点：■ 深度监听，需要递归到底，一次计算量大</p>
<p>​             ■ 无法监听新增属性、删除属性（使用Vue.set、Vue.delete可以）</p>
<p>​             ■ 无法监听原生数组，需要重写数组原型</p>
<p>​    </p>
<p>【vue3】：</p>
<p>使用 Proxy 来代替 Object.defineProperty() ——- 给对象架设一层拦截器</p>
<p>Proxy 劫持：Vue3 使用 Proxy 来劫持整个对象，而不仅仅是对象的属性。通过 Proxy，Vue 可以直接监听到数组的变化、对象属性的新增或删除等情况，解决了 Vue 2 的一些局限性。</p>
<p>依赖收集与触发更新：在 Proxy 的 get 方法中，会进行依赖收集，把依赖这个属性的地方记录下来；而在 set 方法中，会触发依赖更新，让相应的视图重新渲染。</p>
<h3 id="vue3和vue2的区别"><a href="#vue3和vue2的区别" class="headerlink" title="vue3和vue2的区别"></a>vue3和vue2的区别</h3><ul>
<li>源码组织方式变化：使用 TS 重写</li>
<li>支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li>
<li>响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li>
<li>编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容 </li>
<li>打包体积优化：移除了一些不常用的api（inline-template、filter）</li>
<li>生命周期的变化：使用setup代替了之前的beforeCreate和created</li>
<li>Vue3 的 template 模板支持多个根标签</li>
<li>Vuex状态管理：创建实例的方式改变，Vue2为new Store , Vue3为createStore</li>
<li>Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例</li>
<li>Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</li>
<li>父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</li>
</ul>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM是 Model-View-ViewModel 缩写，也就是把 MVC 中的 Controller 演变成 ViewModel 。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p>
<p>用户行为更改数据，数据主动触发视图更新 - 双向绑定ViewModel进行交互 - Model和View不直接进行交互</p>
<h3 id="v-model-双向绑定原理"><a href="#v-model-双向绑定原理" class="headerlink" title="v-model 双向绑定原理"></a>v-model 双向绑定原理</h3><p>Vue2 中，v-model 主要用于表单元素的双向数据绑定，本质上是对 value 和 @input 的语法糖</p>
<p>把输入框的值绑定到你的数据变量上。当用户输入时，自动更新这个数据变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;message&quot;</span> /&gt; <span class="comment">//等价于：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;message = $event.target.value&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="title class_">Vue2</span> 中，v-model 主要用于表单元素的双向数据绑定，本质上是对 value 和 @input 的语法糖</span><br><span class="line">把输入框的值绑定到你的数据变量上。当用户输入时，自动更新这个数据变量。</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">CustomInput</span> v-model=<span class="string">&quot;message&quot;</span> /&gt; <span class="comment">// 自定义组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">modelValue</span>: <span class="title class_">String</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue3</span> 中，v-model 默认绑定的是 modelValue，同时监听的事件是 <span class="attr">update</span>:modelValue。</span><br><span class="line">意思是，在自定义组件里要处理的数据属性叫 modelValue，事件名叫 <span class="attr">update</span>:modelValue。</span><br></pre></td></tr></table></figure>
<p>Vue3 中，v-model 默认绑定的是 modelValue，同时监听的事件是 update:modelValue。</p>
<p>意思是，在自定义组件里要处理的数据属性叫 modelValue，事件名叫 update:modelValue。</p>
<h3 id="vue组件通信方式"><a href="#vue组件通信方式" class="headerlink" title="vue组件通信方式"></a>vue组件通信方式</h3><p>父子、隔代、兄弟组件通信</p>
<p>1、props / $emit - 父子</p>
<p>  父 -&gt; 子  props  -    子组件用 props 声明接收的属性，父组件用 v-bind 动态绑定</p>
<p>  子 -&gt; 父 $emit -       子组件通过$emit函数触发自定义事件，传参。父组件通过 v-on @监听函数并接收参数</p>
<p>  <strong>prop 只可以从上一级组件传递到下一级组件（父子组件）- 单向数据流。且 prop 只读，不可被修改。</strong></p>
<p>2、$ref  父子组件通信</p>
<p>  ref：在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；在子组件上，指向组件实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ChildComponent</span> ref=<span class="string">&quot;child&quot;</span> /&gt; <span class="comment">// 父组件中通过 ref 访问子组件</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">child</span>.<span class="title function_">someMethod</span>(); <span class="comment">// 访问子组件实例</span></span><br></pre></td></tr></table></figure>
<p>3、事件总线EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信，多用于vue2兄弟</p>
<p>  该方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件</p>
<p>5、Vuex - 父子、隔代、兄弟组件通信    状态存储器</p>
<p>  - 组件通过 store.dispatch 来触发全局状态的更新；其他组件通过 store.state 来访问</p>
<p>  - 是响应式的。当组件从 store 中读取状态时，若状态发生变化，那么相应组件也会更新</p>
<p>  - 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。</p>
<p>state - 状态     储存store内数据，可在组件中进行调用this.$store.state.name</p>
<p>mutation         更改 store 中的状态的方法，更改数据 state状态</p>
<p>action - 动作    处理异步场景，成功后把数据提交给mutations，进而更新state，使用dispatch触发</p>
<p>getter               对state中的数据进行加工处理后再提供给组件</p>
<p>module - 模块</p>
<h3 id="组合式-选项式API"><a href="#组合式-选项式API" class="headerlink" title="组合式/选项式API"></a>组合式/选项式API</h3><p> 1、Composition API：更好的代码组织，更好的逻辑复用，更好的类型推导</p>
<p> 2、如何选择：</p>
<p>​    ○ 不建议共用，会引起混乱</p>
<p>​    ○ 小型项目、业务逻辑简单，用Option API成本更小一些</p>
<p>​    ○ 中大型项目、逻辑复杂，用Composition API</p>
<p>setup中如何获取组件实例</p>
<p>● 在setup和其他composition API中没有this</p>
<p>● 通过getCurrentInstance获取当前实例</p>
<p>● 若使用options API可以照常使用this</p>
<h3 id="hash和history路由"><a href="#hash和history路由" class="headerlink" title="hash和history路由"></a>hash和history路由</h3><p>【hash】 路由基于 URL 的哈希部分（即 # 后面的部分）来管理页面切换。浏览器中的哈希变化<br>不会触发页面刷新，因此可用来在不重新加载页面的情况下切换视图。【兼容性好、SEO不友好】</p>
<p>【history】 路由使用 HTML5 的 history.pushState 和 history.replaceState API 来管<br>理浏览器历史记录，直接操作 URL 的路径部分来实现路由导航，而不需要 #。</p>
<ul>
<li>用户体验更好、SEO友好、需要服务器配置</li>
</ul>
<h3 id="v-if-与-v-show-区别"><a href="#v-if-与-v-show-区别" class="headerlink" title="v-if 与 v-show 区别"></a>v-if 与 v-show 区别</h3><p>v-if ：根据条件动态地添加或移除 DOM 元素。</p>
<p>v-show ：始终渲染元素，但通过设置 display: none 来控制其显示和隐藏。</p>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>nextTick  - 下一次执行前延迟回调</p>
<p>原理：利用微任务（如 <code>Promise.then</code>）或宏任务（如 <code>setTimeout</code>）来推迟执行代码，确保在 DOM 更新后再运行回调。它把回调推到当前执行栈末尾执行，从而等待 Vue 完成数据变化后的 DOM 更新。  </p>
<p>作用：在数据更新后，等到浏览器更新了DOM 之后再执行某段代码。</p>
<h3 id="Vue-与-React-区别"><a href="#Vue-与-React-区别" class="headerlink" title="Vue 与 React 区别"></a>Vue 与 React 区别</h3><ol>
<li>设计理念</li>
</ol>
<p>​    Vue：更注重易用性和灵活性，适合快速上手。</p>
<p>​    React：强调组件化和可复用性，更适合构建复杂的用户界面。</p>
<ol>
<li>数据绑定</li>
</ol>
<p>​    Vue：使用双向数据绑定，数据变化会自动更新视图，适合快速开发。</p>
<p>​    React：采用单向数据流，数据从父组件传递到子组件，变化需要手动更新。</p>
<ol>
<li>模板 vs JSX</li>
</ol>
<p>​    Vue：使用 HTML 模板，直观易懂，可以使用指令（如 v-if、v-for）。</p>
<p>​    React：使用 JSX，将 HTML 和 JavaScript 结合在一起，灵活但需要学习成本。</p>
<ol>
<li>生态系统</li>
</ol>
<p>​    Vue：生态较小，官方提供了更多的工具（如 Vue Router、Vuex）以便整合。</p>
<p>​    React：生态较大，有丰富的社区支持和第三方库，但整合需要更多配置。</p>
<h3 id="vue-项目的性能优化"><a href="#vue-项目的性能优化" class="headerlink" title="vue 项目的性能优化"></a>vue 项目的性能优化</h3><p>【编码阶段】</p>
<p>​     - 尽量减少 data 中的数据，会增加 getter 和 setter，会收集对应的 watcher</p>
<p>​     - v-if 和 v-for 不能连用</p>
<p>​     - 如果需要使用 v-for 给每项元素绑定事件时使用事件代理</p>
<p>​     - SPA 页面采用 keep-alive 缓存组件</p>
<p>​     - 在更多的情况下，使用 v-if 替代 v-show</p>
<p>​     - key 保证唯一</p>
<p>​     - 使用路由懒加载、异步组件、图片懒加载</p>
<p>​     - 防抖、节流</p>
<p>​     - 第三方模块按需导入</p>
<p>​     - 长列表滚动到可视区域动态加载</p>
<p>【SEO 优化】：预渲染、服务端渲染 SSR</p>
<p>【打包优化】</p>
<p>​     - 压缩代码</p>
<p>​     - Tree Shaking/Scope Hoisting</p>
<p>​     - 使用 cdn 加载第三方模块</p>
<p>​     - 多线程打包 happypack</p>
<p>​     - splitChunks 抽离公共文件</p>
<p>​     - sourceMap 优化</p>
<p>【用户体验】：骨架屏、PWA、还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 gzip 压缩等。</p>
<h3 id="状态管理vuex-pinia"><a href="#状态管理vuex-pinia" class="headerlink" title="状态管理vuex/pinia"></a>状态管理vuex/pinia</h3><p>适合 存储 不同组件之间共享和管理的数据</p>
<p>例如：</p>
<ol>
<li>用户登录状态：需要在应用程序多个组件之间共享和管理，以便验证权限</li>
<li>全局配置信息：主题、语言、权限</li>
<li>缓存数据：个人信息、常用数据</li>
<li>购物车数据：不同页面保持购物车一致</li>
</ol>
<h3 id="ref-toRef-toRefs"><a href="#ref-toRef-toRefs" class="headerlink" title="ref /toRef/toRefs"></a>ref /toRef/toRefs</h3><p>ref 生成值类型的响应式数据，可用于模板和reactive，通过.value修改值</p>
<p>toRef：</p>
<p>​    针对一个响应式对象（reactive封装的）的一个属性，创建一个ref，具有响应式</p>
<p>​    两者保持引用关系</p>
<p>toRefs：将响应式对象（reactive封装的）转化为普通对象</p>
<p>​    对象的每个属性都是对象的ref</p>
<p>​    两者保持引用关系  例：const state = reactive({x: 1})  return toRefs(state)</p>
<p>最佳使用方式：</p>
<p>   1、用reactive做对象的响应式，用ref做值类型响应式（基本类型）</p>
<p>   2、setup中返回toRefs(state)，或者toRef(state, ‘prop’)</p>
<p>   3、ref的变量命名都用xxRef</p>
<p>   4、合成函数返回响应式对象时，使用toRefs，有助于使用方对数据进行解构时，不丢失响应式</p>
<p>为什么需要用 ref：</p>
<p>   1、返回值类型，会丢失响应式</p>
<p>   2、如在setup、computed、合成函数，都有可能返回值类型</p>
<p>   3、Vue如不定义ref，用户将制造ref，反而更混乱</p>
<p>为何ref需要.value属性：</p>
<p>   1、ref是一个对象（不丢失响应式），value存储值</p>
<p>   2、通过.value属性的get和set实现响应式</p>
<p>   3、用于模板、reactive时，不需要.value，其他情况都要</p>
<p>为什么需要toRef和toRefs：</p>
<p>   1、初衷：不丢失响应式的情况下，把对象数据 分解/扩散</p>
<p>   2、前端：针对的是响应式对象（reactive封装的）非普通对象</p>
<p>   3、注意：不创造响应式，而是延续响应式</p>
<h3 id="如何封装组件"><a href="#如何封装组件" class="headerlink" title="如何封装组件"></a>如何封装组件</h3><p>首先进行需求分析，确定组件功能和实现方式。再定义组件 API，包括传入的 props 和事件。</p>
<p>最后编写组件测试用例，确保组件功能正确。</p>
<p>封装组件时要注意组件的可复用性、易维护性和可测试性。在编写组件时，应该遵循单一职责原则，</p>
<p>尽量避免组件之间的耦合，提供清晰简洁的 API，确保组件功能正确，并编写充分的测试用例，</p>
<p>以便于其他开发者和用户使用和维护组件。</p>
<p>【Vue 组件的渲染过程】：组件初始化 -&gt; 模板编译为虚拟 DOM -&gt; 虚拟 DOM 渲染为真实 DOM </p>
<p>  -&gt; 数据更新时 diff 虚拟 DOM -&gt; 更新真实 DOM。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="css-权重"><a href="#css-权重" class="headerlink" title="css 权重"></a>css 权重</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">属性后面加 !important 会覆盖页面内任何位置定义的元素样式</span><br><span class="line">1. 1000 内联样式：&lt;div style=&quot;color: red;&quot;&gt;Hello&lt;/div&gt;</span><br><span class="line">2. 100 id选择器：#header &#123; color: blue; &#125;</span><br><span class="line">3. 10 类选择器【.button &#123;&#125;】、属性选择器【[type=&quot;text&quot;] &#123; &#125;】、伪类选择器【a:hover &#123; &#125;】</span><br><span class="line">4. 1 元素选择器【div &#123; color: black; &#125;】、伪元素选择器【::before &#123; &#125;】</span><br><span class="line"></span><br><span class="line">【css初始化的作用】：解决不同浏览器之间的默认样式差异，确保网页在不同浏览器中显示一致</span><br></pre></td></tr></table></figure>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">从内到外由四个部分构成：content + padding + border + margin</span><br><span class="line">内容区（content）、内边距（padding，颜色与内容区相同，不能设置透明）、边框（border，会影响盒子占据的总空间）、外边距（margin）</span><br><span class="line"></span><br><span class="line">标准和模型Content-box：</span><br><span class="line">  width/height = content，不包含border边框和padding内边距。</span><br><span class="line">  offsetWidth = (width + padding + border),不算margin</span><br><span class="line">IE盒模型border-box：怪异盒模型 (IE8及其以下版本浏览器，未声明 DOCTYPE)</span><br><span class="line">  width/height = content + padding + border</span><br><span class="line">css中通过box-sizing改变元素盒模型：①content-box - 标准盒模型、②border-box - IE盒模型、③inherit(继承父元素box-sizing属性值)</span><br></pre></td></tr></table></figure>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">块级格式化上下文，是一个独立的渲染区域</span><br><span class="line">【触发条件】：</span><br><span class="line">1、根元素HTML，本身就形成BFC</span><br><span class="line">2、元素的 position 属性值为 absolute 或 fixed。</span><br><span class="line">3、display的值为inline-block、table-cell、inline-flex、grid、inline-grid</span><br><span class="line">4、浮动元素：float值为left、right</span><br><span class="line">5、overflow值为 auto、scroll、hidden</span><br><span class="line">【作用】：</span><br><span class="line">1、清除浮动：子元素设置浮动 -&gt; 父元素可能会出现高度塌陷 -&gt; 父：overflow: hidden</span><br><span class="line">2、防止外边距折叠：两个块级元素垂直相邻时，上下边距可能会合并成两个中较大的边距</span><br><span class="line">3、自适应多栏布局：两栏</span><br><span class="line">   两兄弟块级元素一个设置左浮动，可能会覆盖另一个部分空间，给另一个元素设置overflow: hidden，开启BFC，会使另一个元素靠左浮动元素排列，不再重叠，达成自适应两栏布局。</span><br><span class="line">   </span><br><span class="line">【清除浮动】：</span><br><span class="line">1、在浮动元素后面添加 clear:both的空 div 元素</span><br><span class="line">2、给父元素添加 overflow:hidden 或者 auto 样式，触发BFC</span><br><span class="line">3、使用伪元素，在元素末尾 :after 添加一个 点 并带有 clear: both 属性的元素实现的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IFC 内联格式化上下文  --  内联元素的布局规则（文本、链接）</span><br><span class="line">特点：</span><br><span class="line">1. 从左到右水平排列</span><br><span class="line">2. 默认基线对齐，可用vertical-align调整</span><br><span class="line">3. 行高由字体大小和line-height决定</span><br><span class="line">4. 元素宽度取决于内容</span><br><span class="line">5. 垂直方向上margin不会重叠</span><br><span class="line">触发方法：display：inline/inline-block</span><br></pre></td></tr></table></figure>
<h3 id="水平垂直居中1"><a href="#水平垂直居中1" class="headerlink" title="水平垂直居中1"></a>水平垂直居中1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">行内元素：span a</span><br><span class="line">1、line-height 设置为与父容器的 height 一致 和 text-align：center</span><br><span class="line">2、justify-content: center 水平居中，align-items: center 垂直居中。</span><br><span class="line">○ 水平居中：text-align: center/父元素：display: flex; justify-content: center</span><br><span class="line">○ 垂直居中：</span><br><span class="line">   单行文本：height === line-height</span><br><span class="line">   多行文本父元素确认高度：display: table-cell; vertical-align: middle</span><br><span class="line"></span><br><span class="line">块元素：div</span><br><span class="line">1、flex+margin</span><br><span class="line">  父元素：display: flex;</span><br><span class="line">         justify-content: center;</span><br><span class="line">         align-items: center</span><br><span class="line">2、定位+tranform</span><br><span class="line">  父元素：position: relative</span><br><span class="line">  子元素：position: absolute;  使元素的左上角移动到父容器的正中央</span><br><span class="line">         top: 50%; left: 50%;</span><br><span class="line">         transform: translate(-50%, -50%)  使元素的中心点对齐</span><br><span class="line">3、grid网格布局</span><br><span class="line">  父元素：display: grid;</span><br><span class="line">         place-items: center 让子元素在 Grid 容器中水平和垂直方向居中</span><br></pre></td></tr></table></figure>
<h3 id="em-px-rem-vh-vw-区别"><a href="#em-px-rem-vh-vw-区别" class="headerlink" title="em/px/rem/vh/vw 区别"></a>em/px/rem/vh/vw 区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、vw：viewpoint width，视口宽度的百分比单位。100vw = 100% 视图窗口宽度。</span><br><span class="line">2、vh：viewpoint height，视口高度的百分比单位。100vh = 100% 视图窗口高度。</span><br><span class="line">3、rem：相对根节点html的字体大小的单位。默认情况下，根元素的字体大小等于浏览器的默认字体大小（16px, 1 rem = 16px）。通过设置根元素的字体大小，可进行整体的比例调整</span><br><span class="line">4、em：相对于父元素字体大小的单位。em 单位具有继承性，子元素会受到父元素字体大小的影响。如果自身定义了font-size按自身来计算（浏览器默认字体是16px）</span><br><span class="line">5、px 绝对单位，页面精准按像素展示； % 相对于父元素的宽度比例</span><br><span class="line"></span><br><span class="line">主要区别如下：</span><br><span class="line">vw 和 vh 是相对于视口宽度和高度的单位，而 rem 和 em 是相对于字体大小的单位。</span><br><span class="line">vw 和 vh 单位可直接根据屏幕尺寸进行调整，而 rem 和 em 单位则需依赖于父元素的字体大小。</span><br><span class="line">rem 单位更适合用于整体的比例调整，而 em 单位更适合用于相对布局中的局部调整。</span><br></pre></td></tr></table></figure>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器（使用flex布局的元素）和项目（子元素），采用主轴和交叉轴来定义布局方向</span><br><span class="line">项目属性中很多时候会用到 flex: 1 ，它具体包含了以下的意思</span><br><span class="line">● flex-grow: 1 ：默认为 0 ，若存在剩余空间，元素也不放大。若设为 1 项目会平分剩余空间</span><br><span class="line">● flex-shrink: 1 ：默认为 1 ，如果空间不足，元素会缩小。（若值为 0，项目不会缩小）</span><br><span class="line">● flex-basis: 0% ：表示项目的初始大小为 0，即在分配多余空间之前，它不占据任何空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0% 之后，因为有 flex-grow 和 flex-shrink 的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis 设为auto 的话，其本身大小将会是 0</span><br></pre></td></tr></table></figure>
<h3 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、新增选择器，如</span><br><span class="line">2、边框属性： border-radius圆角边框 box-shadow阴影 border-image用图片绘制边框</span><br><span class="line">3、盒模型： 弹性布局flex 栅格布局grid</span><br><span class="line">4、渐变：线性渐变:linear-gradient(red, green, blue);</span><br><span class="line">        径向渐变:radial-gradient (red, green, blue)</span><br><span class="line">5、阴影：box-shadow: 3px 3px 3px rgba(0, 64, 128, 0.3)</span><br><span class="line">6、背景：background-clip背景画区、background-origin图片对齐、</span><br><span class="line">        background-size和background-break</span><br><span class="line">7、文字：text-overflow：clip/ellipsis，溢出时修剪/用...表示</span><br><span class="line">8、transform：translate(120px, 50%)：位移</span><br><span class="line">              scale(2, 0.5)：缩放</span><br><span class="line">              rotate(0.5turn)：旋转</span><br><span class="line">              skew(30deg, 20deg)：倾斜</span><br><span class="line">9、animation动画：animation-name：动画名称</span><br><span class="line">                 animation-duration：动画持续时间</span><br><span class="line">                 animation-timing-function：动画时间函数</span><br><span class="line">                 animation-delay：动画延迟时间</span><br><span class="line">                 animation-iteration-count：动画执行次数</span><br><span class="line">                 animation-direction：动画执行方向</span><br><span class="line">                 animation-paly-state：动画播放状态</span><br><span class="line">                 animation-fill-mode：动画填充模式</span><br></pre></td></tr></table></figure>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、static（默认值）：元素处于正常的文档流中。</span><br><span class="line">2、relative：相对定位。元素在正常文档流中的位置不变，但可以通过设置top等属性来相对于其正常位置进行偏移。发生偏移时可能会覆盖其他元素，但不会影响其他元素的布局。</span><br><span class="line">3、absolute：绝对定位。元素脱离正常文档流，并相对于最近的已定位祖先元素或 &lt;body&gt; 元素进行定位。如果没有已定位的祖先元素，则相对于视口进行定位。</span><br><span class="line">4、fixed：固定定位。元素脱离正常文档流，并相对于视口进行定位。</span><br><span class="line">5、sticky：粘性定位。元素根据正常文档流进行定位，然后相对于离它最近的具有滚动机制的祖先元素或视口进行定位。当用户滚动页面时，元素的定位会发生变化。</span><br></pre></td></tr></table></figure>
<h3 id="隐藏页面元素"><a href="#隐藏页面元素" class="headerlink" title="隐藏页面元素"></a>隐藏页面元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、display:none: 彻底隐藏元素，元素从文档流中消失，不占据空间不能交互，也不影响布局</span><br><span class="line">2、visibility:hidden: 隐藏元素，仍占据空间，但不可以交互</span><br><span class="line">3、opacity: 0：将元素的透明度将为0。看起来隐藏了，但依然占据空间，可以交互</span><br><span class="line">4、overflow:hidden: 只隐藏元素溢出部分，占据空间且不可交互</span><br><span class="line">5、z-index:-9999: 原理是将层级放到底部，被覆盖，看起来隐藏了</span><br><span class="line">6、transform:scale(0,0): 平面变换，将元素缩放为0，但依然占据空间，不可交互</span><br><span class="line"></span><br><span class="line">display: none 与 visibility: hidden 这两个属性都是让元素隐藏，不可见。区别：</span><br><span class="line">1、display: none：让元素从文档流中移除，不占据任何空间；是非继承属性，所有子元素都不可见，对页面的渲染性能影响较小。</span><br><span class="line">2、visibility: hidden：元素仍占据空间，但内容不可见。只是将元素的可见性设置为隐藏，其他元素的布局不受影响。子元素也会被隐藏，但可以通过单独设置子元素的 visibility: visible 来让子元素显示，而父元素仍然保持隐藏状态。</span><br></pre></td></tr></table></figure>
<h3 id="CSS动画和过渡"><a href="#CSS动画和过渡" class="headerlink" title="CSS动画和过渡"></a>CSS动画和过渡</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">css动画：transition -渐变动画  transform - 转变动画  animation - 自定义动画</span><br><span class="line">1、transition属性：</span><br><span class="line">  transition-property: 填写需要变化的css属性</span><br><span class="line">  transition-duration: 完成过渡效果需要的时间单位(s或者ms)默认是 0</span><br><span class="line">  transition-timing-function: 完成效果的速度曲线</span><br><span class="line">  transition-delay: （规定过渡效果何时开始。默认是0）</span><br><span class="line">  一般情况下，都是写一起的，比如：transition：width 2s ease 1s</span><br><span class="line">2、transform 转变动画。包含四个常用的功能：</span><br><span class="line">  translate(x,y)：位移      scale：缩放</span><br><span class="line">  rotate：旋转              skew：倾斜</span><br><span class="line">一般配合transition过渡使用。注意：transform不支持inline元素，使用前把它变成block</span><br><span class="line">3、animation   @keyframes定义关键帧</span><br><span class="line">  CSS 动画只需要定义一些关键的帧，而其余帧，浏览器会根据计时函数插值计算出来，</span><br><span class="line">  可以是from-&gt;to（等同于0%和100%），from 表示最开始的那一帧，to 表示结束时的那一帧</span><br></pre></td></tr></table></figure>
<h3 id="css提高性能的方法"><a href="#css提高性能的方法" class="headerlink" title="css提高性能的方法"></a>css提高性能的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、内联首屏关键CSS：通过内联css关键代码能够使浏览器在下载完html后就能立刻渲染</span><br><span class="line">2、异步加载CSS：</span><br><span class="line">   对于不需要立即加载的 CSS 文件，可以使用 media 属性或动态加载 CSS 来推迟它的加载</span><br><span class="line">3、资源压缩：利用webpack、gulp等模块化工具，将css文件进行压缩，降低浏览器的加载时间</span><br><span class="line">4、合理使用选择器：</span><br><span class="line">    避免过度嵌套(会增加浏览器解析的成本),使用 ID 和类选择器,避免使用复杂选择器</span><br><span class="line">5、不要使用@important：会覆盖其他样式，增加渲染时间</span><br><span class="line">6、其他：</span><br><span class="line">   使用CSS预处理器</span><br><span class="line">   减少重排操作，以及减少不必要的重绘</span><br><span class="line">   了解哪些属性可以继承而来，避免对这些属性重复编写</span><br><span class="line">   css Sprite，用宽高加上backgroud-position的背景图方式显现icon图，减少http请求</span><br><span class="line">   把小的icon图片转成base64编码</span><br><span class="line">   CSS3动画或者过渡尽量使用transform和opacity来实现动画，不要使用left和top属性</span><br></pre></td></tr></table></figure>
<h3 id="两栏：左定宽右自适应1"><a href="#两栏：左定宽右自适应1" class="headerlink" title="两栏：左定宽右自适应1"></a>两栏：左定宽右自适应1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;box-left&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box-right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">【解决方案】：</span><br><span class="line">① 利用flexbox实现：</span><br><span class="line">首先给最外层的div的display属性设为flex，再给左侧div设置一个宽度200px,</span><br><span class="line">最后给右侧div的 flex-grow属性设为1，使其占据剩余的空间，达到自适应效果。</span><br><span class="line"></span><br><span class="line">② 利用grid网格布局实现：</span><br><span class="line">给最外层的div：display：grid，grid-template-columns：200px auto</span><br><span class="line">左边栏定宽 200px，右边栏使用 auto 占据剩余空间，实现自适应布局。</span><br><span class="line"></span><br><span class="line">③ 利用float 浮动实现：</span><br><span class="line">给左侧div设置一个宽度200px,并向左浮动，并给右侧div的margin-left值设为左侧div的宽度，</span><br><span class="line">使其避开左边的定宽栏，达到自适应效果。</span><br><span class="line"></span><br><span class="line">④ 利用position定位实现：</span><br><span class="line">最外层div的position属性设为相对定位，左侧div的position属性设为绝对定位，给定一个宽度，并将left\top\bottom值设为0，最后右侧div的margin-left值设为左侧div的宽度。</span><br></pre></td></tr></table></figure>
<h3 id="画一条0-5px的线"><a href="#画一条0-5px的线" class="headerlink" title="画一条0.5px的线"></a>画一条0.5px的线</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、通过 transform 进行缩放：</span><br><span class="line">height: 1px // 设置线的初始高度为 1px。</span><br><span class="line">transform: scaleY(0.5) // 将线条沿 Y 轴缩小 50%，达到 0.5px 的效果。</span><br><span class="line"></span><br><span class="line">2、采用 border 的方式：border-top: 0.5px solid black; /* 设置0.5px的顶部边框 */</span><br><span class="line"></span><br><span class="line">3、采用 meta viewport 的方式：</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可以利用 【边框】 属性来实现的：将一个元素的宽高设为 0，然后只设置四个边框中的一个为有颜色（向下的三角形，给top设颜色），其他边框设置为透明。</span><br><span class="line">div &#123;</span><br><span class="line">  width:0px;</span><br><span class="line">  height:0px;</span><br><span class="line">  border-top:10px solid red; // 向上的三角形</span><br><span class="line">  border-right:10px solid transparent; </span><br><span class="line">  border-left:10px solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表单中常见标签"><a href="#表单中常见标签" class="headerlink" title="表单中常见标签"></a>表单中常见标签</h3><p>input、select、textarea多行文本、button、label标签</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h3><p>基本数据类型（栈）：直接存储在内存中的数据，值不可变</p>
<p>  Number、String、Boolean、Null-空值、Undefined-未定义、Symbol(ES6)、BigInt(ES2020)</p>
<p>  - Number特殊值：Infinity-正无穷大、-Infinity-负无穷大、NaN-非数值</p>
<p>  - 当使用 var或 let声明了变量但没有初始化时，就相当于给变量赋予了 undefined值</p>
<p>  - Symbol：表示一个独一无二的值，通常用于对象属性的唯一标识符。</p>
<p>  - BigInt：表示任意大的整数，用来处理超过Number类型能表示的安全整数范围2^53-1</p>
<p>引用数据类型（堆）：存储的是对象的地址或引用，变量保存的是指向内存中某个对象的引用，而不是实际的值。</p>
<p>  - Object、Array、Function、Date、RegExp(正则表达式)、Map和Set(ES6)</p>
<p>  - Map 是一个键值对的集合，键可以是任意类型;Set 是一个值的集合，值都是唯一的。</p>
<h3 id="typeof类型判断"><a href="#typeof类型判断" class="headerlink" title="typeof类型判断"></a>typeof类型判断</h3><p>1、typeof - 主要用于检测基本数据类型</p>
<p>​    对基本数据类型，除了 null （null返回object）都可以显示正确的类型；</p>
<p>​    引用类型除了函数返回的都是 object， 因为所有的对象的原型最终都是 Object。</p>
<p>2、instanceof - 用于检查某个对象是否是某个类或构造函数的实例。  内部机制：原型链</p>
<p>​      主要用于判断复杂的引用类型。原理就是查找目标对象的原型链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">//true  </span></span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>3、Object.prototype.toString.call() - 更精确，适用于判断所有类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/regex/</span>) <span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="comment">// 手写：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>)); <span class="comment">// &quot;[object Number]&quot;</span></span><br></pre></td></tr></table></figure>
<p>4、constructor 属性 - 每个JS对象都有，用于指向创建该对象的构造函数。可通过该属性判断类型。</p>
<p>​     ① null 和 undefined是无效的对象，不会有 constructor 存在，无法据此属性判断。</p>
<p>​     ② JS对象的 constructor 是不稳定的，主要体现在自定义对象上，当开发者重写</p>
<p>​         prototype 后，原有的 constructor会丢失，constructor 会默认为Object。</p>
<p>​     ③ 类继承的也会出错，因为 Object 被覆盖了，检测结果就不对了。</p>
<p>5、Array.isArray() - 专门用于判断某个值是否为数组，返回true/false</p>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>【作用域】：全局作用域、函数作用域、块级作用域（在大括号中使用let和const声明的变量）</p>
<p>【作用域链的作用】是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</p>
<p>【原型】：每个构造函数都有prototype属性，称之为原型 | 原型对象。</p>
<p>  原型可以放一些属性和方法，共享给实例对象使用，可以继承</p>
<p>  // ● 每个class都有显示原型prototype</p>
<p>  // ● 每个实例都有隐式原型<strong>proto</strong></p>
<p>  // ● 实例的<strong>proto</strong>指向class的prototype</p>
<p>【原型链】：当访问一个对象的属性时，如果这个对象内部不存在这个属性，</p>
<p>那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，</p>
<p>于是就这样一直找下去，也就是原型链的概念。（ 对象都有<strong>proto</strong> 属性，</p>
<p>这个属性指向它的原型对象，而原型对象也是对象，也有 <strong>proto</strong> 属性，</p>
<p>指向原型对象的原型对象,这样一层一层形成的链式结构称为原型链，最顶层找不到则返回 null ）</p>
<p>由于Object是构造函数，原型链终点是Object.prototype.<strong>proto</strong>，而</p>
<p>Object.prototype.<strong>proto</strong>=== null // true，所以，原型链的终点是null</p>
<p>【访问一个对象的原型对象】：</p>
<ol>
<li>对象.<strong>proto</strong>  指向构造函数的prototype</li>
<li>Object.getPrototypeof(对象)         更安全！！</li>
</ol>
<p>【与作用域链区别】：作用域链是找【变量】的链，找不到会报错；原型链</p>
<p>是找【属性】的链，找不到会返回 undefined 。</p>
<p>【原型的作用】：原型就相当于是一个公共的区域，可以被所有该类实例访问，</p>
<p>可以将一个该类实例中，所有的公共属性（方法）统一存储到原型中，</p>
<p>这样只需要创建一个属性，即可被所有实例访问。</p>
<p>// JS 中继承就是通过原型来实现的，当继承时，子类的原型就是一个父类的实例</p>
<p>instanceof 检查的是对象的原型链上是否有该类实例。返回 true / false 。    </p>
<p>Object 是所有对象的原型，任何和对象和 Object 进行 instanceof 运算都会返回 true</p>
<p>【大部分情况下是不需要修改原型对象】</p>
<p>- 注意：千万不要通过类的实例去修改原型</p>
<p>- 处了通过 <strong>proto</strong> 能访问对象的原型外，还可以通过类的 prototype 属性，</p>
<p>来访问实例的原型修改原型时，最好通过通过类去修改。</p>
<p>- 好处：① 一修改就是修改所有实例的原型  ②无需创建实例即可完成对类的修改</p>
<h3 id="闭包和内存泄露"><a href="#闭包和内存泄露" class="headerlink" title="闭包和内存泄露"></a>闭包和内存泄露</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">【闭包】：函数 A 内部有一个函数 B， B 可以访问到 A 中的变量，函数 B 就是闭包</span><br><span class="line">形成闭包的原因：内部的函数存在外部作用域的引用就会导致闭包。</span><br><span class="line">闭包特性：函数嵌套函数、函数内部可以引用函数外部的参数和变量、</span><br><span class="line">        参数和变量不会被垃圾回收机制回收。</span><br><span class="line"></span><br><span class="line">// 闭包的作用：</span><br><span class="line">1、用于封装私有变量，保护函数私有变量不受外部的访问和修改。</span><br><span class="line">2、通常情况下，函数执行完毕后，函数内部的局部变量就会被销毁。</span><br><span class="line">但闭包可使局部变量在函数执行结束后依然存在，进而实现数据的持久化。</span><br><span class="line">3、防抖节流、柯里化</span><br><span class="line"></span><br><span class="line">// 闭包导致内存泄漏：</span><br><span class="line">1.代码中存在不再需要的函数引用，导致函数关联的词法环境无法销毁；</span><br><span class="line">2.当多个函数共享词法环境时，会导致出现无法触达也无法回收的内存空间</span><br><span class="line">- 如何避免：</span><br><span class="line">在退出函数之前，将不使用的局部变量全部删除，或赋值为null;</span><br><span class="line">避免变量的循环引用和赋值</span><br><span class="line"></span><br><span class="line">// 闭包与异步执行函数：（for循环中 + setTimeOut）</span><br><span class="line">1.ES6中let，for循环变块级作用域（原先i是全局）</span><br><span class="line">2.立即执行函数（函数作用域可以保存变量）</span><br><span class="line">【经典面试题：循环中使用闭包解决var定义函数的问题】</span><br><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;, i * 1000)</span><br><span class="line">&#125;</span><br><span class="line">// setTimeout 是个异步函数，会先把循环全部执行完毕，这时候 i就是 6 ，所以会输出一堆 6</span><br><span class="line">// 解决方法：</span><br><span class="line">1、使用 立即执行函数 将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j</span><br><span class="line">2、使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入</span><br><span class="line">3、使用 let 定义 i</span><br><span class="line"></span><br><span class="line">// 以下四种情况会造成内存泄漏：</span><br><span class="line">1、意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class="line">2、被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</span><br><span class="line">3、脱离 DOM 的引用： 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</span><br><span class="line">4、闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用于复制对象和数组</span><br><span class="line">1、浅拷贝</span><br><span class="line">  只复制对象的第一层属性。如果属性是基本类型，拷贝的就是基本类型的值；</span><br><span class="line">  如果属性是引用类型（如对象或数组），浅拷贝将引用地址赋给新的对象。</span><br><span class="line">  因此，如果修改嵌套对象或数组，浅拷贝和原对象都会受到影响。</span><br><span class="line">  浅拷贝的方式：Object.assign()、Array.slice(), Array.concat()、扩展运算符（...）</span><br><span class="line">2、深拷贝</span><br><span class="line">  会递归地复制对象中的所有属性，无论是基本类型还是引用类型。</span><br><span class="line">  改变拷贝后新对象的值，不会影响原对象的值。</span><br><span class="line">  深拷贝的方式：JSON.parse(JSON.stringify())</span><br><span class="line">  </span><br><span class="line">深拷贝时如何解决循环依赖的问题：</span><br><span class="line">【缓存对象】：用于存储已经拷贝过的对象的引用。</span><br><span class="line">每次深拷贝 -&gt; 检查缓存中是否已经存在该对象的拷贝（已存在，则退出循环）</span><br><span class="line">-&gt; return 拷贝后的对象</span><br></pre></td></tr></table></figure>
<h3 id="async-await-的理解"><a href="#async-await-的理解" class="headerlink" title="async/await 的理解"></a>async/await 的理解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【async 关键字】：async 用于定义一个异步函数。</span><br><span class="line">async 函数会自动返回一个 Promise 对象。若函数有返回值，那这个值会被 Promise.resolve() 包装成一个 Promise 返回。无返回值则，Promise.resolve(undefined)</span><br><span class="line">【await 关键字】：用于等待Promise完成，只能在 async 函数中使用。</span><br><span class="line">当遇到 await 时，函数执行会暂停，直到 Promise 状态变为 resolved（成功），并返回 Promise 的结果。await 后面跟着的是一个 Promise，它会暂停代码执行直到 Promise 完成。</span><br><span class="line">● 执行 async 函数，返回的是promise</span><br><span class="line">● await 相当于 promise 的 then</span><br><span class="line">● try...catch 可捕获异常，代替了 promise 的 catch</span><br><span class="line">● await 后面跟 Promise 对象：会阻断后续代码，等待状态变为 fulfilled ，才获取结果并继续执行</span><br><span class="line">● await 后续跟非 Promise 对象：会直接返回</span><br></pre></td></tr></table></figure>
<h3 id="promise异步总结"><a href="#promise异步总结" class="headerlink" title="promise异步总结"></a>promise异步总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、三种状态</span><br><span class="line">  ● pending、fulfilled(通过resolve触发)、rejected(通过reject触发)</span><br><span class="line">  ● pending =&gt; fulfilled 或者 pending =&gt; rejected</span><br><span class="line">  ● 状态变化不可逆</span><br><span class="line">2、状态的表现和变化</span><br><span class="line">  ● pending状态，不会触发then和catch</span><br><span class="line">  ● fulfilled状态会触发后续的then回调</span><br><span class="line">  ● rejected状态会触发后续的catch回调</span><br><span class="line">3、then和catch对状态的影响（重要）</span><br><span class="line">  ● then 正常返回 fulfilled，里面有报错返回 rejected</span><br><span class="line">  ● catch 正常返回 fulfilled，里面有报错返回 rejected</span><br></pre></td></tr></table></figure>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">模块化好处：解决命名冲突、提供复用性、提高代码可维护性</span><br><span class="line">1、立即执行函数</span><br><span class="line">  早期，用此实现模块化比较常见，通过函数作用域解决了命名冲突、污染全局作用域的问题</span><br><span class="line">2、AMD 和 CMD</span><br><span class="line">  AMD 允许在浏览器端异步加载模块，以避免阻塞页面渲染。</span><br><span class="line">  使用 define 来定义模块，模块的依赖项会作为参数传递。 使用 require 来加载模块。</span><br><span class="line">3、CommonJS</span><br><span class="line">是 Node.js 使用的模块系统。核心思想是使用 require 函数引入模块，使用 module.exports</span><br><span class="line">导出模块。CommonJS 是同步的，因为在服务器端，文件可以直接从本地磁盘加载。</span><br><span class="line">4、ES Module</span><br><span class="line">  ESM 是 ECMAScript 规范中的官方模块化标准，支持浏览器和 Node.js。</span><br><span class="line">  在 ESM 中，模块是静态的，即模块加载时会提前解析，导入的模块在编译时已经确定。</span><br><span class="line">  </span><br><span class="line">【ESM vs CommonJS 对比】：</span><br><span class="line">// 1、导入导出机制:</span><br><span class="line">CommonJS: 动态导入，导出的是一个对象，模块在运行时加载。</span><br><span class="line">ESM: 静态导入，导入的模块在编译时就确定，并且可以使用 tree-shaking 优化未使用的代码。</span><br><span class="line">// 2、同步 vs 异步:</span><br><span class="line">CommonJS: 同步加载模块，适用于服务器端环境。</span><br><span class="line">ESM: 支持异步加载，适用于浏览器环境，特别是需要从网络异步加载资源时。</span><br></pre></td></tr></table></figure>
<h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.箭头函数、解构赋值、模板字符串、promise</span><br><span class="line">5.Symbol - 基本数据类型，表示一个独一无二的值，不能与其他数据类型进行运算</span><br><span class="line">6.let和const - 变量声明方式</span><br><span class="line">7.模块化 - 根据功能封装模块，import导入，export导出，也可以使用export default导出</span><br><span class="line">8.for…of 循环 - 用于遍历可迭代对象(如数组、Map 和 Set)中的元素</span><br><span class="line">9.展开运算符 - 用...表示，将数组或者对象进行展开</span><br><span class="line">10.Map 和 Set - 数据结构，分别用于存储 键值对 和 唯一值</span><br><span class="line">11.Proxy - 允许在对象和函数调用等操作前后添加自定义的行为</span><br><span class="line">12.类（Class） - 引入了面向对象编程中类的概念</span><br><span class="line">13.默认参数（Default Parameter） - 在定义函数时可以给参数设置默认值</span><br><span class="line"></span><br><span class="line">新数组方法：</span><br><span class="line">Array.from()、Array.of()、find、findIndex、fill、keys、values</span><br></pre></td></tr></table></figure>
<h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. 事件触发三阶段：</span><br><span class="line">● 事件从最顶层元素（window）开始向目标元素的路径传播 // 捕获阶段：事件从父元素向子元素传播</span><br><span class="line">● 事件到达目标元素，事件的目标是用户实际操作的元素 // 目标阶段</span><br><span class="line">● 事件从目标元素向上传播，直到最顶层元素 // 冒泡阶段：事件从子元素冒泡回到父元素</span><br><span class="line"></span><br><span class="line">2. 注册事件</span><br><span class="line">JS 中使用 addEventListener() 来为元素添加事件监听器。该方法允许指定事件处理的阶段：捕获阶段或冒泡阶段。</span><br><span class="line">// element.addEventListener(type, listener, options);</span><br><span class="line">type: 事件类型，比如 click、keyup 等。</span><br><span class="line">listener: 事件触发时执行的回调函数。</span><br><span class="line">options:</span><br><span class="line">  capture: 如果为 true，事件在捕获阶段触发；为 false（默认），在冒泡阶段触发。</span><br><span class="line">  once: 如果为 true，事件处理器在调用后自动移除。</span><br><span class="line">  passive: 如果为 true，表示不会调用 preventDefault() 阻止默认行为。</span><br><span class="line">- 若希望事件只触发在目标上，可使用 event.stopPropagation() 来阻止事件冒泡阶段的传播</span><br><span class="line">- 防止默认行为（如阻止表单提交、链接跳转）：event.preventDefault()</span><br><span class="line"></span><br><span class="line">3. 事件代理(委托)</span><br><span class="line">若一个节点中的子节点是动态生成的（例如ul中的li），把子节点的事件注册在父节点上。</span><br><span class="line">它利用事件冒泡机制，只在一个父元素上添加事件监听器，而不是为每个子元素都添加事件监听器。</span><br><span class="line">优点：减少内存消耗和事件绑定操作</span><br><span class="line"></span><br><span class="line">【target和currentTarget区别】：</span><br><span class="line">1、target 是事件的实际触发目标，即用户最初点击或触发事件的那个 DOM 元素。无论事件冒泡</span><br><span class="line">到哪里，target 始终指向最初发生事件的那个元素。// 事件的最初触发元素（用户操作的元素）</span><br><span class="line">2、currentTarget 是事件当前正在处理的元素，即事件监听器所绑定的那个元素。在事件的冒泡</span><br><span class="line">或捕获阶段，事件会经过多个元素，而 currentTarget 会指向当前正在处理事件的那个元素。</span><br><span class="line">// 绑定事件处理器的元素</span><br><span class="line"></span><br><span class="line">事件循环event</span><br><span class="line">执行全局代码 --&gt; 异步任务（定时器、网络请求） --&gt; 异步回调放入消息队列</span><br><span class="line">异步任务放入调用栈   定时器、网络请求放入Web API</span><br><span class="line"></span><br><span class="line">单线程：同一时间只能执行一个任务 -&gt; 一个任务时间过长--阻塞后续 -- promise/async、await</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">● 箭头函数中没有 arguments，可以使用 ...args 代替</span><br><span class="line">● 箭头函数没有 prototype 属性，不能进行 new 实例化</span><br><span class="line">● 箭头函数不能通过 call、apply 等绑定 this，因为箭头函数底层是使用bind永久绑定this</span><br><span class="line">了，bind绑定过的this不能修改</span><br><span class="line">● 箭头函数的this指向创建时父级的this</span><br><span class="line">● 箭头函数不能使用yield关键字，不能作为Generator函数</span><br><span class="line">不适用的场景：对象方法、对象原型、构造函数、动态上下文的回调函数、vue的生命周期和method</span><br></pre></td></tr></table></figure>
<h3 id="let、const、var区别"><a href="#let、const、var区别" class="headerlink" title="let、const、var区别"></a>let、const、var区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1）块级作用域： let和const具有块级作用域，var不存在块级作用域。</span><br><span class="line">2）变量提升： var存在变量提升，let和const不存在变量提升（变量只能在声明之后使用）。</span><br><span class="line">3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。</span><br><span class="line">var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但let和const不会。</span><br><span class="line">4）重复声明： var声明变量时，可以重复声明，后声明的同名变量会覆盖之前声明的。</span><br><span class="line">const和let不允许。</span><br><span class="line">5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。</span><br><span class="line">这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。</span><br><span class="line">6）初始值设置： 变量声明时，var 和 let 可不用设置初始值。而const必须设置。</span><br><span class="line">7）指针指向： let创建的变量是可以更改指针指向（重新赋值）。但const是不允许的。</span><br></pre></td></tr></table></figure>
<h3 id="和"><a href="#和" class="headerlink" title="==和==="></a><code>==</code>和<code>===</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">等于操作符（==）：</span><br><span class="line">  在比较中会先进行类型转换，再确定操作数是否相等。如果操作数相等，则会返回 true。</span><br><span class="line">  1、两个都为简单类型，字符串和布尔值都会转换成数值，再比较</span><br><span class="line">  2、简单类型与引用类型比较，对象转化成其原始类型的值，再比较</span><br><span class="line">  3、两个都为引用类型，则比较它们是否指向同一个对象</span><br><span class="line">  4、null 和 undefined 相等</span><br><span class="line">  5、存在 NaN 则返回 false</span><br><span class="line">全等操作符（===）：</span><br><span class="line">  只有两个操作数在不转换的前提下相等才返回 true。即类型相同，值也需相同</span><br><span class="line">【区别】：</span><br><span class="line">  相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换</span><br><span class="line">  null 和 undefined 比较，相等操作符（==）为true，全等为false</span><br></pre></td></tr></table></figure>
<h3 id="数组原生方法"><a href="#数组原生方法" class="headerlink" title="数组原生方法"></a>数组原生方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、数组和【字符串】的转换方法：toString()、toLocalString()、join() </span><br><span class="line">其中 join() 方法可以指定转换为字符串时的分隔符。</span><br><span class="line">2、数组【尾部】操作的方法 pop() 和 push()，push 方法可以传入多个参数。</span><br><span class="line">3、数组【首部】操作的方法 shift() 和 unshift() </span><br><span class="line">重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</span><br><span class="line">4、数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</span><br><span class="line">5、数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</span><br><span class="line">6、数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</span><br><span class="line">7、数组归并方法 reduce() 和 reduceRight() 方法</span><br><span class="line"></span><br><span class="line">【js数组去重】</span><br><span class="line">1、Set</span><br><span class="line">2、filter</span><br><span class="line">3、reduce</span><br><span class="line">4、for循环+indexOf方法</span><br><span class="line">5、Map</span><br></pre></td></tr></table></figure>
<h3 id="遍历数组对象"><a href="#遍历数组对象" class="headerlink" title="遍历数组对象"></a>遍历数组对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【for in和for of的区别】：for…in 会遍历对象的整个原型链</span><br><span class="line">for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</span><br><span class="line"></span><br><span class="line">【forEach和map的区别】：都是用来遍历数组的</span><br><span class="line">forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，没有返回值；</span><br><span class="line">map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</span><br></pre></td></tr></table></figure>
<h3 id="JS中的this"><a href="#JS中的this" class="headerlink" title="JS中的this"></a>JS中的this</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。</span><br><span class="line"></span><br><span class="line">1、以函数形式调用时， this 指向的是 window全局作用域（优先级最低）</span><br><span class="line">2、以方法的形式调用时，this 指向的是调用方法的对象（优先级再次）</span><br><span class="line">3、构造器形式调用时，如果一个函数用 new 调用时，函数执行前会新创建一个对象，</span><br><span class="line">this 指向这个新创建的对象。（优先级最高）</span><br><span class="line">4、 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。</span><br><span class="line">其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。</span><br><span class="line">call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。</span><br><span class="line">bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。（优先级其次）</span><br><span class="line"></span><br><span class="line">箭头函数没有自己的 this ，它只会在自己作用域的上一层继承 this 。</span><br><span class="line">箭头函数的 this 和它的调用方式无关</span><br></pre></td></tr></table></figure>
<h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new操作符的执行过程：</span><br><span class="line">（1）首先创建了一个新的空对象</span><br><span class="line">（2）设置原型，将对象的原型设置为函数的 prototype 对象。</span><br><span class="line">（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span><br><span class="line">（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</span><br></pre></td></tr></table></figure>
<h3 id="微任务宏任务"><a href="#微任务宏任务" class="headerlink" title="微任务宏任务"></a>微任务宏任务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">○ 宏任务：setTimeout 、setInterval 、DOM事件、Ajax </span><br><span class="line">  ○ 微任务：Promise.then、async/await</span><br><span class="line">  ○ 微任务比宏任务执行的更早：宏任务：DOM 渲染后再触发，微任务：DOM 渲染前会触发</span><br></pre></td></tr></table></figure>
<h3 id="请求接口作用"><a href="#请求接口作用" class="headerlink" title="请求接口作用"></a>请求接口作用</h3><p>获取 和 更新 服务器上的数据</p>
<p>例如：</p>
<ol>
<li>获取列表数据</li>
<li>创建、更新、删除数据</li>
<li>文件上传和下载（上传头像、下载附件）</li>
<li>需要实时数据的场景（在线聊天、股票详情）</li>
</ol>
<h3 id="BOM和DOM"><a href="#BOM和DOM" class="headerlink" title="BOM和DOM"></a>BOM和DOM</h3><p>【区别】：BOM 用于与浏览器环境交互，而 DOM 用于操作文档内容。</p>
<p><strong>DOM</strong>：文档对象模型。将 文档 转化为 树状结构</p>
<p>   每一个节点都是一个对象 -&gt; 可通过js脚本操作和修改这些对象</p>
<p><strong>BOM</strong>：浏览器对象模型。用于 与浏览器窗口进行交互，控制浏览器窗口和进行浏览器相关操作</p>
<p>   包含：window、navigator、location、history、screen</p>
<p>   获取和设置：浏览器窗口大小、位置、打开新窗口、导航历史记录</p>
<p>【DOM渲染 —- <strong>阻塞渲染原因</strong>】</p>
<p>   1、脚本执行 - 浏览器遇到script停止渲染、执行脚本</p>
<p>   2、样式计算和布局 - 复杂的css选择器有大量样式计算</p>
<p>   3、资源加载 - 需要下载的头部资源（图片、样式表、脚本）</p>
<p>   4、JavaScript执行 - 会修改DOM结构和样式</p>
<p>   5、渲染树的构建 - DOM树 + css样式表</p>
<p><strong>优化策略</strong>：异步加载脚本、压缩合并css和js文件、使用defer和async属性，延迟脚本执行、css动画代替js动画、图片懒加载/按需加载</p>
<p><strong>【从URL到页面渲染的完整过程】：</strong></p>
<ul>
<li><strong>DNS解析</strong>：将URL转换成IP地址。</li>
<li><strong>TCP连接</strong>：浏览器与服务器建立连接（三次握手）。</li>
<li><strong>发送请求</strong>：浏览器向服务器发送HTTP请求。</li>
<li><strong>服务器响应</strong>：服务器返回HTML、CSS、JS等资源。</li>
<li><strong>解析并构建DOM树</strong>：浏览器解析HTML生成DOM树。</li>
<li><strong>解析CSS并生成CSSOM树</strong>：CSS被解析为样式树。</li>
<li><strong>构建渲染树</strong>：DOM树与CSSOM树合并生成渲染树。</li>
<li><strong>布局</strong>：计算渲染树中每个节点的位置和大小。</li>
<li><strong>绘制与显示</strong>：将布局好的内容绘制到屏幕上。</li>
</ul>
<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h3><p>  伪类： <strong>:</strong> 开头，选择文档中的【特定状态、特定元素】   例，:hover、:active、:focus</p>
<p>  伪元素： <strong>::</strong> 开头，元素的【特定部分】   例，::before、::first-line</p>
<h2 id="HTTP和浏览器"><a href="#HTTP和浏览器" class="headerlink" title="HTTP和浏览器"></a>HTTP和浏览器</h2><h3 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1XX：信息状态码 2XX：成功状态码 3XX：重定向 4XX：客户端错误 5XX: 服务器错误</span><br><span class="line">200 OK：请求成功，服务器返回所请求的数据。</span><br><span class="line">301 Moved Permanently：资源永久重定向，新的 URL 在响应中给出。</span><br><span class="line">302 Found：资源临时重定向，客户端应使用新的 URL 继续请求。</span><br><span class="line">400 Bad Request：请求无效，服务器无法理解请求内容。</span><br><span class="line">401 Unauthorized：未授权，需要提供认证信息。</span><br><span class="line">403 Forbidden：服务器拒绝请求，客户端无权限访问资源。</span><br><span class="line">404 Not Found：资源未找到，服务器上不存在请求的资源。</span><br><span class="line">500 Internal Server Error 服务器内部错误，无法处理请求。</span><br><span class="line">502 Bad Gateway</span><br><span class="line">503 Service Unavailable 服务器暂时不可用，可能是因为过载或维护。</span><br><span class="line">504 Gateway Timeout网关超时</span><br></pre></td></tr></table></figure>
<h3 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【三次握手】：建立tcp连接的过程,可以进行数据的传输</span><br><span class="line">1、客户端向服务器发送一个SYN包 SYN=1,ACK=0，这个包中包含客户端的初始序列号ISN(c)。</span><br><span class="line">此步骤目的：向服务器请求建立连接。</span><br><span class="line">2、服务器收到SYN包后，回复一个SYN+ACK包。标记为SYN=1,ACK=1。</span><br><span class="line">包中包含了服务器的初始序列号ISN(c)，并对客户端的SYN进行确认，确认号：ACK=ISN(c)+1。</span><br><span class="line">3、客户端收到SYN+ACK包后，回复一个ACK包作最后确认。标记为SYN=0,ACK=1</span><br><span class="line">这个ACK包中包含了对服务器SYN的确认。确认号：ACK=ISN(c)+1</span><br><span class="line"> </span><br><span class="line">【四次挥手】：断开连接的过程</span><br><span class="line">1、客户端发送一个FIN包给服务器，标记为FIN=1,ACK=0。</span><br><span class="line">表示已完成数据的发送，并希望关闭连接。</span><br><span class="line">2、服务器收到客户端的FIN包后，回复一个ACK包作为确认。标记为ACK=1 确认号ACK=客户端序号+1。</span><br><span class="line">此时客户端不再发送数据，但服务器仍可发送数据（连接处于半关闭状态）。</span><br><span class="line">3、服务器继续发送一个FIN包给客户端。标记为FIN=1,ACK=0。</span><br><span class="line">4、客户端收到FIN包回复一个ACK包，作为最后的确认。标记为ACK=1 确认号ACK=客户端序号+1。</span><br><span class="line">至此，TCP连接被完全关闭。</span><br><span class="line"></span><br><span class="line">【需要四次挥手原因】</span><br><span class="line">服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手</span><br></pre></td></tr></table></figure>
<h3 id="TCP请求头报文头"><a href="#TCP请求头报文头" class="headerlink" title="TCP请求头报文头"></a>TCP请求头报文头</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">请求头：</span><br><span class="line">1、源端口号：发送端口号</span><br><span class="line">2、目的端口号：接收端口号</span><br><span class="line">3、序列号：本次传输的数据段序号</span><br><span class="line">4、确认号：期待接收的下一个数据段序号</span><br><span class="line">5、数据偏移量：TCP头部长度</span><br><span class="line">6、保留位：保留为0</span><br><span class="line">7、控制位：标识TCP的连接状态</span><br><span class="line">8、窗口大小：接收方可接收的数据量</span><br><span class="line">9、校验位：校验TCP头部和数据的完整性</span><br><span class="line">10、紧急指针：紧急数据的位置</span><br><span class="line">11、用于控制和管理TCP连接的建立、数据传输和断开，提供一些可选的功能和优化选项</span><br><span class="line"></span><br><span class="line">报文头：</span><br><span class="line">1、源IP地址：发送方IP地址</span><br><span class="line">2、目的IP地址：接收方IP地址</span><br><span class="line">3、协议类型：上层协议类型，TCP为6</span><br><span class="line">4、IP头部长度：</span><br><span class="line">5、服务类型</span><br><span class="line">6、标识：数据包唯一标识</span><br><span class="line">7、标志：数据包状态</span><br><span class="line">8、偏移：数据包在原始数据中的位置</span><br><span class="line">9、生存时间</span><br><span class="line">10、协议校验和：校验IP头部和数据的完整性</span><br></pre></td></tr></table></figure>
<h3 id="储存"><a href="#储存" class="headerlink" title="储存"></a>储存</h3><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
<th>indexDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>除非被清理，否则一直存在</td>
<td>页面关闭就清理</td>
<td>除非被清理，否则一直存在</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>4KB</td>
<td>5M</td>
<td>5M</td>
<td>无限</td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在header中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 有几种方式可以实现存储功能，分别有什么优缺点？什么是 Service Worker？</span><br><span class="line">cookie 已不建议用于存储。若没有大量数据存储需求，可使用 localStorage/sessionStorage 对于不怎么改变的数据尽量使用 localStorage 存储。</span><br><span class="line">1、【cookie】</span><br><span class="line">value - 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</span><br><span class="line">http-only - 不能通过 JS 访问 Cookie，减少 XSS 攻击</span><br><span class="line">secure - 只能在协议为 HTTPS 的请求中携带</span><br><span class="line">same-site - 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</span><br><span class="line">2、【Service Worker】</span><br><span class="line">● Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</span><br><span class="line">使用 Service Worker的话，传输协议必须为 HTTPS。</span><br><span class="line">因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全</span><br><span class="line">● Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监</span><br><span class="line">听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的</span><br><span class="line">方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</span><br><span class="line"></span><br><span class="line">【记录用户状态、信息】：</span><br><span class="line">cookie：保存在客户端浏览器</span><br><span class="line"> 服务器自动发给浏览器   很多浏览器限制一个站点最多保存20个cookie</span><br><span class="line">session：保存在服务器 -- 依据cookie识别用户</span><br><span class="line"> 安全性⬆ 大小原则上无限制 sessionID(第一次访问服务器生成)存在cookie</span><br></pre></td></tr></table></figure>
<h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">数据请求：网络请求 -&gt; 后端处理 -&gt; 浏览器响应</span><br><span class="line">1. 缓存位置</span><br><span class="line">分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络</span><br><span class="line">Service Worker -&gt; Memory Cache -&gt; Disk Cache -&gt; Push Cache -&gt; 网络请求</span><br><span class="line">2、缓存策略</span><br><span class="line">通常分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的</span><br><span class="line">2.1 强缓存</span><br><span class="line">强缓存可通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。</span><br><span class="line">强缓存表示在缓存期间不需要请求，state code 为 200</span><br><span class="line">2.2 协商缓存</span><br><span class="line">● 如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag</span><br><span class="line">● 当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。</span><br><span class="line"></span><br><span class="line">优点：提升页面加载速度、减少带宽消耗、减轻服务器压力</span><br></pre></td></tr></table></figure>
<h3 id="从输入URL-到网页显示的完整过程"><a href="#从输入URL-到网页显示的完整过程" class="headerlink" title="从输入URL 到网页显示的完整过程"></a>从输入URL 到网页显示的完整过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、网络请求：</span><br><span class="line">  DNS查询（得到IP)，建立TCP连接（三次握手）-&gt; 浏览器发送HTTP请求 -&gt; 收到请求响应，得到HTML源码。继续请求静态资源</span><br><span class="line">2、解析：字符串 =&gt; 结构化数据（HTML构建DOM树 -&gt; renter tree）</span><br><span class="line">3、渲染：Render Tree绘制到页面</span><br><span class="line">  ○ 计算DOM的尺寸、定位，最后绘制到页面</span><br><span class="line">  ○ 遇到JS会执行，阻塞HTML解析。如果设置了defer，则并行下载JS，等待HTML解析完，在执行JS；如果设置了async，则并行下载JS，下载完立即执行，在继续解析HTML（JS是单线程的，JS执行和DOM渲染互斥，等JS执行完，在解析渲染DOM）</span><br><span class="line">  ○ 异步CSS、异步图片，可能会触发重新渲染</span><br><span class="line">  </span><br><span class="line">【连环问：网页重绘repaint和重排reflow有什么区别】</span><br><span class="line">● 重绘</span><br><span class="line">  ○ 元素外观改变：如颜色、背景色</span><br><span class="line">  ○ 但元素的尺寸、定位不变，不会影响其他元素的位置</span><br><span class="line">● 重排</span><br><span class="line">  ○ 重新计算尺寸和布局，可能会影响其他元素的位置</span><br><span class="line">  ○ 如元素高度的增加，可能会使相邻的元素位置改变</span><br><span class="line">  ○ 重排必定触发重绘，重绘不一定触发重排。重绘的开销较小，重排的代价较高。</span><br><span class="line">  ○ 减少重排的方法</span><br><span class="line">    ■ 使用BFC特性，不影响其他元素位置</span><br><span class="line">    ■ 频繁触发（resize、scroll）使用节流和防抖</span><br><span class="line">    ■ 使用createDocumentFragment批量操作DOM</span><br></pre></td></tr></table></figure>
<h3 id="常见的web前端攻击方式"><a href="#常见的web前端攻击方式" class="headerlink" title="常见的web前端攻击方式"></a>常见的web前端攻击方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">XSS - Cross Site Script 跨站脚本攻击</span><br><span class="line"> - 手段：黑客将JS代码插入到网页内容中，渲染时执行JS代码</span><br><span class="line"> - 预防：特殊字符串替换（前端或后端）</span><br><span class="line">CSRF - Cross Site Request Forgery 跨站请求伪造</span><br><span class="line"> ● 手段：黑盒诱导用户去访问另一个网站的接口，伪造请求</span><br><span class="line"> ● 预防：严格的跨域限制 + 验证码机制</span><br><span class="line"> 注意：偷取cookie是XSS做的事，CSRF的作用是借用cookie，并不能获取cookie</span><br><span class="line">DDOS - Distribute denial-of-service 分布式拒绝服务</span><br><span class="line"> ● 手段：分布式的大规模的流量访问，使服务器瘫痪</span><br><span class="line"> ● 预防：软件层不好做，需硬件预防（如阿里云的WAF 购买高防）</span><br><span class="line">SQL注入</span><br><span class="line"> ● 手段：黑客提交内容时，写入sql语句，破坏数据库</span><br><span class="line"> ● 预防：处理内容的输入，替换特殊字符</span><br></pre></td></tr></table></figure>
<h3 id="跨域方案"><a href="#跨域方案" class="headerlink" title="跨域方案"></a>跨域方案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">浏览器出于安全考虑，有同源策略。即，如果协议、域名、端口有不同就是跨域，Ajax 请求会失败</span><br><span class="line">1、JSONP</span><br><span class="line"> 利用 &lt;script&gt; 标签没有跨域限制的漏洞。</span><br><span class="line"> 通过 &lt;script&gt; 标签指向一个需要访问的地址并提供一个回调函数来接收数据</span><br><span class="line"> JSONP 使用简单且兼容性不错，但是【只限于 get 请求】</span><br><span class="line">2、CORS - 目前最广泛的解决跨域问题的方案。</span><br><span class="line"> 方案依赖服务端/后端在响应头中添加 Access-Control-Allow-* 头，告知浏览器端通过此请求</span><br><span class="line"> CORS 的实现只需要增加一些 HTTP 头，让服务器能声明允许的访问来源。</span><br><span class="line"> 只要后端实现了 CORS，就实现了跨域</span><br><span class="line">3、nginx反向代理</span><br><span class="line"> nginx 配置跨域，可以为全局配置和单个代理配置（两者不能同时配置）</span><br><span class="line"> 【全局配置】：在nginx.conf文件中的 http 节点加入跨域信息</span><br><span class="line"> 【局部配置（单个代理配置跨域）】： 在路径匹配符中加入跨域信息</span><br><span class="line"> 4、Node 中间层接口转发</span><br><span class="line"> 5、Proxy</span><br><span class="line"> 若是通过vue-cli脚手架工具搭建项目，可通过webpack起一个本地服务器作为请求的代理对象</span><br><span class="line"> 通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用</span><br><span class="line"> 和接口服务器不在一起仍会跨域</span><br><span class="line"> 6、websocket</span><br><span class="line"> webSocket本身不存在跨域问题，可以利用webSocket来进行非同源之间的通信</span><br><span class="line"> 【原理】：利用webSocket的API，可直接new一个socket实例，然后通过open方法内send要传输</span><br><span class="line">  到后台的值，也可以利用message方法接收后台传来的数据。后台是通过new WebSocket.Server(&#123;port:3000&#125;)</span><br><span class="line">  实例，利用message接收数据，利用send向客户端发送数据。</span><br></pre></td></tr></table></figure>
<h3 id="实现网页多标签tab通讯"><a href="#实现网页多标签tab通讯" class="headerlink" title="实现网页多标签tab通讯"></a>实现网页多标签tab通讯</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、通过websocket：无跨域限制，需要服务端支持，成本高</span><br><span class="line">2、通过localStorage同域通讯（推荐）√</span><br><span class="line">  同域的A和B两个页面，A页面设置localStorage，B页面可监听到localStorage值的修改</span><br><span class="line">3、通过SharedWorker通讯</span><br><span class="line">  ○ SharedWorker是WebWorker的一种</span><br><span class="line">  ○ WebWorker可开启子进程执行JS，但不能操作DOM</span><br><span class="line">  ○ SharedWorker可单独开启一个进程，用于同域页面通讯</span><br><span class="line">  ○ SharedWorker兼容性不太好，调试不方便，IE11不支持</span><br></pre></td></tr></table></figure>
<h3 id="如何提高前端页面性能"><a href="#如何提高前端页面性能" class="headerlink" title="如何提高前端页面性能"></a>如何提高前端页面性能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 减少 HTTP 请求：减少静态资源的请求次数，可通过使用 CSS Sprites、合并JS和 CSS 文件等手段实现。</span><br><span class="line">2. 压缩文件大小：压缩 JavaScript、CSS 和图片等文件，可有效减小文件大小，加快下载速度。</span><br><span class="line">3. 避免重复加载：避免重复加载相同的文件或资源，可以通过浏览器缓存、HTTP 缓存和服务端缓存等手段来实现。</span><br><span class="line">4. 异步加载资源：延迟加载非关键资源，可以通过懒加载和异步加载等手段来实现。</span><br><span class="line">5. 减少 DOM 操作：减少不必要的 DOM 操作，可通过避免多次查询 DOM 元素、使用文档片段、事件委托等手段来实现。</span><br><span class="line">6. 优化 CSS 选择器：避免使用过于复杂的 CSS 选择器，可以通过简化选择器、使用 ID 选择器、避免使用通配符等手段来实现。</span><br><span class="line">7. 使用 Web Workers 和 Service Workers：使用 Web Workers 和 Service Workers 可以将一些耗时的计算和 I/O 操作转移到后台线程中，避免阻塞主线程，提高页面响应速度。</span><br><span class="line">8. 移动端优化：移动端页面的性能优化可以通过图片压缩、使用 CSS3 动画代替 JS 动画、避免使用 fixed 定位等手段来实现。</span><br></pre></td></tr></table></figure>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据包是信息传输的基本单位</span><br><span class="line">抓包：截取数据包、分析  --&gt;  获取其中的信息，调试网络问题</span><br><span class="line">工具：wireShark、Fiddler ==&gt; 详细的数据包内容、协议信息、源和目标地址</span><br></pre></td></tr></table></figure>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化：Webpack 读取配置文件（如 webpack.config.js），初始化项目设置。</span><br><span class="line">入口：指定入口文件（如 index.js），Webpack 从这里开始构建依赖图。</span><br><span class="line">模块解析：分析入口文件及其依赖，递归地解析每个模块（JavaScript、CSS、图片等）。</span><br><span class="line">加载器（Loaders）：通过加载器处理不同类型的文件，比如将 ES6 转换为 ES5、将 Sass 转换为 CSS 等。</span><br><span class="line">插件（Plugins）：在构建过程中使用插件进行更复杂的操作，比如压缩代码、提取 CSS、生成 HTML 文件等。</span><br><span class="line">输出：将处理后的文件打包到输出目录（如 dist 文件夹），生成最终的可用文件。</span><br><span class="line">监视（可选）：如果启用，Webpack 可以在文件变化时自动重新构建，提升开发效率。</span><br></pre></td></tr></table></figure>
<h3 id="Vite-为什么快"><a href="#Vite-为什么快" class="headerlink" title="Vite 为什么快"></a>Vite 为什么快</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动快：</span><br><span class="line">【基于浏览器的原生 ES 模块加载】：Vite 不需要像 Webpack 那样在启动时打包所有文件，它直接利用浏览器的原生支持来按需加载模块，因此不需要预先打包整个项目。</span><br><span class="line">【即时编译（依赖预构建）】：Vite 只对项目的依赖进行一次性预编译，大大减少了构建时间，代码变化时只重新编译修改过的部分，避免了大规模重编译。</span><br><span class="line"></span><br><span class="line">打包快：</span><br><span class="line">【依赖预构建】：Vite 在开发时只对项目中使用的依赖库（如第三方模块）进行预构建，避免每次更改代码都重新处理整个项目。</span><br><span class="line">【基于浏览器的模块加载】：Vite 使用浏览器原生的 ES 模块，按需加载文件，减少了打包时对模块的分析和打包工作，使得开发时不需要打包整个应用，速度更快。</span><br></pre></td></tr></table></figure>
<h3 id="微前端iframe"><a href="#微前端iframe" class="headerlink" title="微前端iframe"></a>微前端iframe</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">将前端应用划分为多个微服务，每个微服务负责一个特定的功能或页面</span><br><span class="line"></span><br><span class="line">【解决的问题】</span><br><span class="line">1、大型前端应用的可维护性（对比单页应用）</span><br><span class="line">2、多团队协作的效率</span><br><span class="line">3、技术栈的灵活性（允许每个微服务，使用不同的技术栈）</span><br><span class="line">子工程以npm包的形式</span><br><span class="line"></span><br><span class="line">iframe --- 硬隔离的微前端解决方案 样式隔离，js隔离</span><br><span class="line">但隔离性无法突破：上下文无法共享、组件通信复杂</span><br><span class="line">不同域之间使用iframe的lacation.hash传值，互相通信：postMessage()方法</span><br><span class="line"></span><br><span class="line">将共享的资源放在一个基站应用管理，其他人可以快速引用</span><br></pre></td></tr></table></figure>
<h3 id="less和css区别"><a href="#less和css区别" class="headerlink" title="less和css区别"></a>less和css区别</h3><p>LESS 是一种比 CSS 更灵活的样式语言，它能帮我们写出更简洁和易维护的代码。</p>
<p>它可以：</p>
<ol>
<li><strong>嵌套</strong>：能像 HTML 结构一样嵌套写样式，更清晰。</li>
<li><strong>复用</strong>：支持样式复用和参数传递，减少重复代码。</li>
<li><strong>运算</strong>：支持数学运算，方便计算尺寸和比例。</li>
</ol>
<p>使用 LESS 能让样式代码更简短、易读、好维护，特别适合需要大量样式的项目。</p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">分布式版本控制系统 - 多人协作并行开发</span><br><span class="line">分为：工作区、暂存区、本地仓库、远程仓库</span><br><span class="line"></span><br><span class="line">【 git pull 和 git fetch 】</span><br><span class="line">git pull 相当于 从远程仓库获取最新版本git fetch，然后再与本地分支merge合并，</span><br><span class="line">即git pull = git fetch + git merge</span><br><span class="line"></span><br><span class="line">【 git rebase 和 git merge】</span><br><span class="line">rebase：将一个分支的提交记录应用到另一个分支上，避免合并提交带来的冗余</span><br><span class="line"> git rebase &lt;目标分支&gt;  ----  提交到另一分支</span><br><span class="line"> git rebase -i &lt;目标分支&gt; ---- 修改提交历史</span><br><span class="line"></span><br><span class="line">【 git stach 】</span><br><span class="line">git stach  ---  临时存储代码修改（会把暂存区和工作区的改动进行保存）</span><br></pre></td></tr></table></figure>
<h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">路由前置守卫、路由后置守卫、解析守卫。</span><br><span class="line">作用：</span><br><span class="line">验证用户是否有权限访问某个路由</span><br><span class="line">检查用户是否已登录或其他功能</span><br></pre></td></tr></table></figure>
<h3 id="交接文件readme"><a href="#交接文件readme" class="headerlink" title="交接文件readme"></a>交接文件readme</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、项目概述：名称、目的、功能特点</span><br><span class="line">2、安装指南：安装步骤、所需依赖项、环境配置</span><br><span class="line">3、使用说明：运行步骤、配置文件示例</span><br><span class="line">4、文件结构：各个文件的作用</span><br><span class="line">5、示例和演示：代码示例、截图、链接</span><br><span class="line">6、联系方式</span><br><span class="line">7、版权和许可：开源许可证</span><br></pre></td></tr></table></figure>
<h3 id="文件上线流程"><a href="#文件上线流程" class="headerlink" title="文件上线流程"></a>文件上线流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、准备工具：选择合适的云服务器，安装FinalShell或其它服务器管理工具</span><br><span class="line">2、服务器设置：首先连接云服务器需要重置实例密码，然后配置安全组规则（开启常用端口）</span><br><span class="line">3、项目打包及部署：</span><br><span class="line"> 1. 使用 npm run build 命令打包，打包成功后，原项目文件会产生一个 dist文件夹</span><br><span class="line"> 2. 连接到云服务器，打开FinalShell新建连接，输入服务器公网地址，协议默认，端口选择22，然后点击连接，输入用户名密码</span><br><span class="line"> 3. 上传项目文件，将打包好的静态资源文件上传到云服务器上的合适目录</span><br><span class="line">  更新系统：sudo yum update  安装Nodejs：sudo yum install -y nodejs</span><br><span class="line"> 4. 配置服务器：根据项目需要配置服务器。例如设置Nginx反向代理、配置域名等</span><br></pre></td></tr></table></figure>
<h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><h3 id="instanceof-方法"><a href="#instanceof-方法" class="headerlink" title="instanceof 方法"></a>instanceof 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left); <span class="comment">// 获取对象left原型</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 获取目标构造函数right原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 到达原型链顶端仍未找到目标原型，则返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到目标原型，则返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto); <span class="comment">// 继续查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(p, <span class="title class_">Person</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖：处理频繁触发的事件。函数被连续调用时，只执行最后一次调用。（输入框搜索、窗口调整、按钮点击）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer); <span class="comment">//每一次时间清空，重新计时</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流：限制事件的触发频率，规定时间间隔只执行一次相应操作。（页面滚动、鼠标移动）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浅拷贝和浅拷贝"><a href="#浅拷贝和浅拷贝" class="headerlink" title="浅拷贝和浅拷贝"></a>浅拷贝和浅拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      newObj[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">//查看要拷贝的对象是数组还是对象，如果数组创建空数组，是对象创建空对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// K属性名  obj[k]值</span></span><br><span class="line">    <span class="comment">//判断当前每个元素是否是对象或者数组，若是对象，继续递归拷贝</span></span><br><span class="line">    <span class="comment">//若是值，直接添加到新创建的对象或者数组里</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[k] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      newObj[k] = <span class="title function_">deepClone</span>(obj[k]); <span class="comment">// 递归拷贝完 放入到新对象的属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则是值， 直接添加到新建的 newObj中</span></span><br><span class="line">      newObj[k] = obj[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj; <span class="comment">//返回新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  caches = &#123;&#125;; <span class="comment">// 事件中心</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// eventName事件名-独一无二, fn订阅后执行的自定义行为</span></span><br><span class="line">  on (eventName, fn)&#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">caches</span>[eventName] = <span class="variable language_">this</span>.<span class="property">caches</span>[eventName] || [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">caches</span>[eventName].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布 =&gt; 将订阅的事件进行统一执行</span></span><br><span class="line">  emit (eventName, data) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">caches</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">caches</span>[eventName]</span><br><span class="line">        .<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消订阅 =&gt; 若fn不传, 直接取消该事件所有订阅信息</span></span><br><span class="line">  off (eventName, fn) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">caches</span>[eventName]) &#123;</span><br><span class="line">      <span class="keyword">const</span> newCaches = fn </span><br><span class="line">        ? <span class="variable language_">this</span>.<span class="property">caches</span>[eventName].<span class="title function_">filter</span>(<span class="function"><span class="params">e</span> =&gt;</span> e !== fn) </span><br><span class="line">        : [];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">caches</span>[eventName] = newCaches;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><p>1、使用Token：</p>
<p>   用户登录成功，服务器返回 token  -&gt;  前端将token存在 本地localStorage/cookie 中</p>
<p>   每次请求需要认证的接口：前端将token附加在请求头中，交给服务器验证</p>
<p>2、使用session：</p>
<p>   服务器为每个用户创建一个 session  -&gt;  session ID  存在 cookie 中</p>
<p>   前端将 sessionID 附加在请求头中，交给服务器验证，识别身份</p>
<p>3、OAuth（用户授权第三方应用）</p>
<p>   用户登录 -&gt; 服务器验证 -&gt; 授权第三方应用 -&gt; 返回授权码/token -&gt; 跳转回用户登录页</p>
<p>-&gt; 服务器验证</p>
<p>   不存储token的话，Session ID/JWT/第三方</p>
<p>   不存储token可能会导致一些安全问题：XSS跨域脚本攻击 + token泄露</p>
<h2 id="看代码题"><a href="#看代码题" class="headerlink" title="看代码题"></a>看代码题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="comment">// JS单线程，同步代码优先执行，然后再去处理异步任务（如 setTimeout 和 Promise 的 .then()）。</span></span><br><span class="line"><span class="comment">// 同步代码直接在当前执行栈中运行，异步代码则在 微任务队列 或 宏任务队列 中排队。</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// setTimeout属于【宏任务】，会在所有同步代码和微任务执行完之后再执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Promise的.then() 属于【微任务】，会在当前事件循环的结尾执行，优先级高于 setTimeout</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"><span class="comment">// 输出顺序：2 3 5 4 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  async / await</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，</span></span><br><span class="line"><span class="comment">// 等到触发的异步操作完成，再执行函数体内后面的语句。可理解为:让出线程，跳出了 async 函数体。</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一题</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>))<span class="comment">// 状态返回fulfilled</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)) <span class="comment">// catch中没有报错，状态返回fulfilled，后面的then会执行</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)) <span class="comment">// 1,3</span></span><br><span class="line"><span class="comment">// 整个执行完没有报错，状态返回fulfilled</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二题</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// then中有报错 状态返回rejected,后面的catch会执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)) <span class="comment">// catch中没有报错，状态返回fulfilled，后面的then会执行</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)) <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="comment">// 整个执行完没有报错，状态返回fulfilled</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三题</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;<span class="comment">//then中有报错 状态返回rejected，后面的catch会执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)) <span class="comment">// catch中没有报错，状态返回fulfilled，后面的catch不会执行</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)) <span class="comment">// 1，2</span></span><br><span class="line"><span class="comment">// 整个执行完没有报错，状态返回fulfilled</span></span><br></pre></td></tr></table></figure>
<h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><p>想问下总共有几轮面试、接下来的流程是什么？</p>
<p>您对我个人提升有什么建议？</p>
<p>HC headcount多吗、培养机制</p>
<p>日常职责、技术栈 </p>
<p>主要工作地点</p>
<p>一般多久出结果</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h></h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/">http://www.izdloyl.cn/2024/08/27/interview-%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>IZDLOYL</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-08-27</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-11-08</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/gallery/wallpaper4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端八股</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/23/frontEnd-nodejs/" title="node"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">node</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">IZDLOYL</div><div class="author-info__description">🎬𝙏𝙪𝙧𝙣 𝙤𝙛𝙛 𝙬𝙤𝙧𝙧𝙮✨</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/IZDLOYL-G"><i class="fab fa-github"></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/IZDLOYL-G" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1215472755@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #dfc600;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1174008660" target="_blank" title="Weixin"><i class="fab fa-weixin" style="color: #48b700;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">welcome to my blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E4%BA%AB%E6%B1%87"><span class="toc-text">图享汇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%88%E9%9A%BE%E7%82%B9%E3%80%81%E8%A7%A3%E5%86%B3%EF%BC%89"><span class="toc-text">介绍（难点、解决）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9D%97"><span class="toc-text">登录注册模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91"><span class="toc-text">登录逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81"><span class="toc-text">滑动验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95"><span class="toc-text">第三方扫码登录</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85"><span class="toc-text">axios二次封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%B5%81%E5%92%8C%E9%95%BF%E5%88%97%E8%A1%A8"><span class="toc-text">瀑布流和长列表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%B5%81%E7%BB%84%E4%BB%B6"><span class="toc-text">瀑布流组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%95%BF%E5%88%97%E8%A1%A8"><span class="toc-text">长列表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%A3%81"><span class="toc-text">懒加裁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">图片懒加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">组件懒加载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96"><span class="toc-text">防抖搜索优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-text">移动端适配 - 响应式布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE"><span class="toc-text">人力资源后台项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%88%E9%9A%BE%E7%82%B9%E8%A7%A3%E5%86%B3%EF%BC%89"><span class="toc-text">介绍（难点解决）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90RBAC"><span class="toc-text">权限RBAC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex%E7%AE%A1%E7%90%86"><span class="toc-text">vuex管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="toc-text">excel导入导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%88%97%E8%A1%A8%E8%BD%AC%E6%A0%91"><span class="toc-text">递归列表转树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A7%82%E9%A2%98"><span class="toc-text">主观题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue"><span class="toc-text">vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">vue生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2-3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">vue2&#x2F;3响应式原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3%E5%92%8Cvue2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">vue3和vue2的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-text">v-model 双向绑定原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">vue组件通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F-%E9%80%89%E9%A1%B9%E5%BC%8FAPI"><span class="toc-text">组合式&#x2F;选项式API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E5%92%8Chistory%E8%B7%AF%E7%94%B1"><span class="toc-text">hash和history路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if-%E4%B8%8E-v-show-%E5%8C%BA%E5%88%AB"><span class="toc-text">v-if 与 v-show 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nextTick"><span class="toc-text">nextTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E4%B8%8E-React-%E5%8C%BA%E5%88%AB"><span class="toc-text">Vue 与 React 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">vue 项目的性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86vuex-pinia"><span class="toc-text">状态管理vuex&#x2F;pinia</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-toRef-toRefs"><span class="toc-text">ref &#x2F;toRef&#x2F;toRefs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6"><span class="toc-text">如何封装组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css-%E6%9D%83%E9%87%8D"><span class="toc-text">css 权重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC"><span class="toc-text">BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD1"><span class="toc-text">水平垂直居中1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#em-px-rem-vh-vw-%E5%8C%BA%E5%88%AB"><span class="toc-text">em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flex%E5%B8%83%E5%B1%80"><span class="toc-text">flex布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">CSS3新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D"><span class="toc-text">定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0"><span class="toc-text">隐藏页面元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS%E5%8A%A8%E7%94%BB%E5%92%8C%E8%BF%87%E6%B8%A1"><span class="toc-text">CSS动画和过渡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">css提高性能的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%A0%8F%EF%BC%9A%E5%B7%A6%E5%AE%9A%E5%AE%BD%E5%8F%B3%E8%87%AA%E9%80%82%E5%BA%941"><span class="toc-text">两栏：左定宽右自适应1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E4%B8%80%E6%9D%A10-5px%E7%9A%84%E7%BA%BF"><span class="toc-text">画一条0.5px的线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">画三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%A0%87%E7%AD%BE"><span class="toc-text">表单中常见标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">js 数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">typeof类型判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型和原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">闭包和内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">async&#x2F;await 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E5%BC%82%E6%AD%A5%E6%80%BB%E7%BB%93"><span class="toc-text">promise异步总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">ES6新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">事件机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let%E3%80%81const%E3%80%81var%E5%8C%BA%E5%88%AB"><span class="toc-text">let、const、var区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C"><span class="toc-text">&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-text">数组原生方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">遍历数组对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E4%B8%AD%E7%9A%84this"><span class="toc-text">JS中的this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">new操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="toc-text">微任务宏任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E4%BD%9C%E7%94%A8"><span class="toc-text">请求接口作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM%E5%92%8CDOM"><span class="toc-text">BOM和DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">伪类和伪元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">HTTP和浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">TCP三次握手和四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%8A%A5%E6%96%87%E5%A4%B4"><span class="toc-text">TCP请求头报文头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%82%A8%E5%AD%98"><span class="toc-text">储存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">浏览器缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL-%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B"><span class="toc-text">从输入URL 到网页显示的完整过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84web%E5%89%8D%E7%AB%AF%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-text">常见的web前端攻击方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88"><span class="toc-text">跨域方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E5%A4%9A%E6%A0%87%E7%AD%BEtab%E9%80%9A%E8%AE%AF"><span class="toc-text">实现网页多标签tab通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD"><span class="toc-text">如何提高前端页面性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8C%85"><span class="toc-text">抓包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">前端工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">webpack 构建流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vite-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-text">Vite 为什么快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AFiframe"><span class="toc-text">微前端iframe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#less%E5%92%8Ccss%E5%8C%BA%E5%88%AB"><span class="toc-text">less和css区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git"><span class="toc-text">git</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-text">路由守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8E%A5%E6%96%87%E4%BB%B6readme"><span class="toc-text">交接文件readme</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B"><span class="toc-text">文件上线流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-text">手写代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-%E6%96%B9%E6%B3%95"><span class="toc-text">instanceof 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-text">防抖节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">浅拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-text">发布订阅</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-text">场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD"><span class="toc-text">登录功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E4%BB%A3%E7%A0%81%E9%A2%98"><span class="toc-text">看代码题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E9%97%AE"><span class="toc-text">反问</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端八股"/></a><div class="content"><a class="title" href="/2024/08/29/interview-%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" title="前端八股">前端八股</a><time datetime="2024-08-29T13:06:26.092Z" title="发表于 2024-08-29 21:06:26">2024-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/27/interview-%E6%80%BB%E7%BB%93/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/08/27/interview-%E6%80%BB%E7%BB%93/" title="无题">无题</a><time datetime="2024-08-27T12:58:34.417Z" title="发表于 2024-08-27 20:58:34">2024-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-nodejs/" title="node"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="node"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-nodejs/" title="node">node</a><time datetime="2024-08-23T08:14:35.116Z" title="发表于 2024-08-23 16:14:35">2024-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-JavaScript/" title="JS基本语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS基本语法"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-JavaScript/" title="JS基本语法">JS基本语法</a><time datetime="2024-08-23T08:06:33.574Z" title="发表于 2024-08-23 16:06:33">2024-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/frontEnd-TypeScript/" title="TypeScript"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript"/></a><div class="content"><a class="title" href="/2024/08/23/frontEnd-TypeScript/" title="TypeScript">TypeScript</a><time datetime="2024-08-23T08:06:10.608Z" title="发表于 2024-08-23 16:06:10">2024-08-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By IZDLOYL</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hope you have a nice day!🍭🍭🍭</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 IZDLOYLの前端笔记 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/项目/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 IZDLOYLの项目 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 IZDLOYLの算法笔记 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.izdloyl.cn/categories/面试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 IZDLOYLの面试总结 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://www.izdloyl.cn/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-JavaScript/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper1.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-JavaScript/" alt="">JS基本语法</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-JavaScript/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-TypeScript/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-TypeScript/" alt="">TypeScript</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-TypeScript/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/01/frontEnd-vue3/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" href="2024/08/01/frontEnd-vue3/" alt="">vue3</a><div class="blog-slider__text">vue3学习笔记</div><a class="blog-slider__button" href="2024/08/01/frontEnd-vue3/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/23/frontEnd-nodejs/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/dm2.webb" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-23</span><a class="blog-slider__title" href="2024/08/23/frontEnd-nodejs/" alt="">node</a><div class="blog-slider__text">前端学习笔记</div><a class="blog-slider__button" href="2024/08/23/frontEnd-nodejs/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/01/frontEnd-vue2/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-01</span><a class="blog-slider__title" href="2024/08/01/frontEnd-vue2/" alt="">vue2</a><div class="blog-slider__text">vue2学习笔记</div><a class="blog-slider__button" href="2024/08/01/frontEnd-vue2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-数组/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-数组/" alt="">数组篇</a><div class="blog-slider__text">代码随想录 - 数组篇</div><a class="blog-slider__button" href="2024/08/02/algorithm-数组/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-hot100/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-hot100/" alt="">hot100</a><div class="blog-slider__text">LeetCode - hot100</div><a class="blog-slider__button" href="2024/08/02/algorithm-hot100/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/02/algorithm-字符串/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/gallery/wallpaper3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-02</span><a class="blog-slider__title" href="2024/08/02/algorithm-字符串/" alt="">字符串篇</a><div class="blog-slider__text">代码随想录 - 字符串篇</div><a class="blog-slider__button" href="2024/08/02/algorithm-字符串/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>